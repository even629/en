<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>常想一二，不思八九</title>
  <icon>https://even629.com/icon.png</icon>
  <subtitle>blog</subtitle>
  <link href="https://even629.com/atom.xml" rel="self"/>
  
  <link href="https://even629.com/"/>
  <updated>2025-12-24T03:55:13.000Z</updated>
  <id>https://even629.com/</id>
  
  <author>
    <name>even629</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode热题100 P283 移动零</title>
    <link href="https://even629.com/posts/283/"/>
    <id>https://even629.com/posts/283/</id>
    <published>2025-12-24T03:55:13.000Z</published>
    <updated>2025-12-24T03:55:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-24</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P183 移动零" href="https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P183 移动零</p><p class="url">https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked</p></div></a></div></p><p>冒泡排序写法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">                <span class="type">int</span> k = n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                                j = i;</span><br><span class="line">                                <span class="keyword">while</span> (nums[j] == <span class="number">0</span> &amp;&amp; j &lt; k) &#123;</span><br><span class="line">                                        std::<span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">                                        j++;</span><br><span class="line">                                &#125;</span><br><span class="line">                                k--;                                </span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>双指针:<br>左指针指向已经处理完的元素的下一个，右指针指向左指针后面的第一个非零元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="type">int</span> n = nums.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; n &amp;&amp; nums[left] != <span class="number">0</span>) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                &#125;</span><br><span class="line">                right = left;</span><br><span class="line">                <span class="keyword">while</span> (right &lt; n &amp;&amp; nums[right] == <span class="number">0</span>) &#123;</span><br><span class="line">                        right++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nums[right] != <span class="number">0</span>) &#123;</span><br><span class="line">                                std::<span class="built_in">swap</span>(nums[left], nums[right]);</span><br><span class="line">                                left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        right++;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><!-- flag of hidden posts -->]]></content>
    
    
    <summary type="html">双指针</summary>
    
    
    
    <category term="algorithm" scheme="https://even629.com/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://even629.com/tags/algorithm/"/>
    
    <category term="leetcode热题100" scheme="https://even629.com/tags/leetcode%E7%83%AD%E9%A2%98100/"/>
    
    <category term="双指针" scheme="https://even629.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Linux 单总线</title>
    <link href="https://even629.com/posts/2512233/"/>
    <id>https://even629.com/posts/2512233/</id>
    <published>2025-12-23T11:55:13.000Z</published>
    <updated>2025-12-23T11:55:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-23</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="单总线简介"><a href="#单总线简介" class="headerlink" title="单总线简介"></a>单总线简介</h1><h2 id="单总线概述"><a href="#单总线概述" class="headerlink" title="单总线概述"></a>单总线概述</h2><p><strong>单总线（One-Wire）是一种串行通信协议和硬件总线</strong>，用于在电子设备之间传输数据和控制信号。它是由独立的芯片制造商 Dallas Semiconductor 开发的，并且在多种应用中得到了广泛应用。</p><p>与 SPI I2C 等串行数据通信方式不同，单总线的特点是<strong>只需要一根信号线，既可以传输时钟又可以传输数据，而且数据是双向的</strong>。所以单总线具有节省 IO 口，结构简单，便于扩展和维护等特点。</p><p>单总线用于各种应用，包括<strong>温度传感器，湿度传感器，EEPROM 存储器，时钟</strong>等。它在许多领域中得到了广泛应用，例如工业自动化，家庭自动化，物联网和电子设备监测等。本篇使用温度传感器 DS18b20 进行举例学习单总线。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195437951.png" alt="单总线的硬件结构"></p><ol><li><strong>信号线</strong>：单总线使用一根信号线进行数据传输和通信。这根线被称为数据线，也是提供电源的线路。单总线上的所有设备都连接到这根信号线上。</li><li><strong>上拉电阻</strong>：单总线需要一个上拉电阻连接到信号线和电源之间，以确保在没有设备发送数据时，信号线上的电平保持为高电平（逻辑 1）。上拉电阻的值通常在 4.7 千欧姆到 10 千欧姆之间。(GPIO设置成上拉)</li><li><strong>设备</strong>：单总线支持多个设备连接到信号线上。每个设备都具有唯一的 64 位地址，通过这个地址来识别和选择通信的目标设备。设备可以是各种类型的传感器，存储器，时钟等。</li><li><strong>处理器</strong>：处理器是单总线上的控制器，处理器负责发送命令，读取响应和控制单总线上的从设备</li></ol><h2 id="单总线的通信步骤"><a href="#单总线的通信步骤" class="headerlink" title="单总线的通信步骤"></a>单总线的通信步骤</h2><p>单总线是<strong>主从结构</strong>，<strong>当主机呼叫从机时，从机才会应答</strong>，所以<strong>主机都必须严格遵循单总线的命令时序</strong>。如果命令时序不对，则器件不会响应。</p><p>单总线的通信步骤通常包括以下几个阶段。</p><ol><li><strong>初始化</strong>：通信开始之前，<strong>主设备会发送初始化信号来确保单总线上没有其他设备正在通信</strong>。初始化信号是一个特定的序列，通常是将数据线拉低一段时间然后释放。</li><li><strong>ROM 操作命令</strong></li><li><strong>功能命令</strong></li></ol><h1 id="DS18B20-介绍"><a href="#DS18B20-介绍" class="headerlink" title="DS18B20 介绍"></a>DS18B20 介绍</h1><h2 id="DS18b20-芯片概述"><a href="#DS18b20-芯片概述" class="headerlink" title="DS18b20 芯片概述"></a>DS18b20 芯片概述</h2><p>DS18b20 是一种数字温度传感器芯片，<strong>提供 9 到 12bit 分辨率的温度测量</strong>，可以通过<strong>可编程非易失性存储单元</strong>实现温度的下限和上限报警。</p><p>它是基于单总线通信协议的设备，只需要一根信号线和一根地线。</p><p>DS18b20 能够以较高的精度测量温度精确到 0.0625°C。它具有广泛的测量范围，通常介于-55°C 到+125°C 之间。</p><p>DS18B20 芯片可以通过单总线从主设备获取供电，也可以通过外部电源进行供电。这使得它在一些低功耗应用中能够灵活选择供电方式。</p><p>每个DS18b20 都会有一个全球唯一的 64 位序列号，可以将多个 DS18b20 串联在同一根单总线上进行组网，只需要一个处理器就可以控制分布在大面积区域中的多颗 DS18b20。这种组网方式特别适合 HVAC 环境控制，建筑，设备，粮情测温和工业测温以及过程监测控制等应用领域。</p><h2 id="DS18b20-基本性能"><a href="#DS18b20-基本性能" class="headerlink" title="DS18b20 基本性能"></a>DS18b20 基本性能</h2><p>DS18B20 是一款数字温度传感器芯片，具有以下基本性能特点：</p><ul><li>采用单总线接口仅需一个端口引脚进行通信</li><li>每颗芯片具有全球唯一的 64 位的序列号</li><li>具有多点分布式测温功能无需外围元器件</li><li>可通过数据线供电，供电电压范围为 2.5V~5.5V</li><li>测度测量范围为-55°C 到+125°C</li><li>在-10°C~ 70°C 范围内精确度为±0.4°C</li><li>温度分辨率 9-12 位可选</li><li>最高 12 位精度下，温度转换速度小于 750ms</li><li>具有用户自定义的非易失性温度报警设置</li><li>报警搜索命令识别并标识超过程序设定温度的器件</li><li>超强静电保护能力：HBM 8000V MM 800V</li><li>可提供贴片的 MSOP8，SOP8 封装和 3 脚的 TO-92、TO-92S 封装。</li></ul><h2 id="DS18b20-引脚配置和封装"><a href="#DS18b20-引脚配置和封装" class="headerlink" title="DS18b20 引脚配置和封装"></a>DS18b20 引脚配置和封装</h2><p>DS18B20 芯片引脚配置：</p><ul><li><strong>VDD</strong>：供电引脚，用于提供芯片的正电源。</li><li><strong>DQ</strong>：数据引脚，用于单总线通信和数据传输。</li><li><strong>GND</strong>：地引脚，连接芯片的地（负电源）。</li></ul><p>DS18B20 芯片可用于不同的封装类型，其中最常见的封装是 TO-92 封装和 TO-92-3 封装。这些封装都是具有三个引脚的小型封装，适用于直插式安装和表面贴装。</p><p>TO-92 封装是一种常见的小型塑料封装，引脚按照顺序排列，依次为 VDD、DQ 和 GND。</p><p>TO-92-3 封装与 TO-92 封装类似，但引脚顺序略有不同。TO-92-3 封装的引脚顺序为 GND、DQ 和 VDD。</p><p>除了这些常见的封装类型，DS18B20 还可以在其他封装类型中使用，例如 SOT-23 封装和TO-263 封装等，这些封装类型可能具有不同的引脚排列和尺寸。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195437971.png" alt="DS18B20封装类型"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195438102.png" alt="DC Electrical Characteristics"></p><h2 id="DS18b20-内部结构"><a href="#DS18b20-内部结构" class="headerlink" title="DS18b20 内部结构"></a>DS18b20 内部结构</h2><p>DS18b20 是一种数字温度传感器芯片，其内部结构主要包括以下组成部分，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195438050.png" alt="DS18b20 Block Diagram"></p><ul><li><strong>温度传感器</strong>：DS18B20 内部集成了温度传感器，用于测量环境的温度。传感器通常基于基准电压的变化来检测温度，并将其转换为数字信号。</li><li><strong>A/D 转换器</strong>：DS18B20 芯片内部包含了一种模数转换器（A/D 转换器），用于将传感器测量到的模拟温度值转换为相应的数字表示。这使得温度数据能够以数字形式进行处理和传输。</li><li><strong>存储器</strong>：DS18B20 芯片还具有内部存储器，用于存储配置信息和温度测量结果。存储器可以存储唯一的 64 位地址、温度分辨率和其他相关设置。</li><li><strong>控制逻辑</strong>：DS18B20 芯片包含了控制逻辑电路，用于管理温度测量、通信和其他相关功能。控制逻辑协调各个部分的操作，并与主设备进行通信。</li><li><strong>单总线接口</strong>：DS18B20 采用了单总线通信协议，其内部结构包括一条数据线和一个上拉电阻，用于与主设备进行通信。单总线接口简化了连接和通信的布线，使得多个 DS18B20 传感器能够方便地串联在同一条总线上。</li></ul><p>存储器由 9 个字节组成，其分配如下表所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195438078.png" alt="DS18B20 Memory Map"></p><p>当温度转换命令发布后，经转换所得的温度值以<strong>二字节补码形式</strong>存放在高速暂存存储器的第 0 和第 1 个字节，单片机可通过单线接口读到该数据，读取时低位在前，高位在后，数据格式如下表所示。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195459968.png" alt="Temperature Register Format"></p><h2 id="DS18b20-寄存器介绍"><a href="#DS18b20-寄存器介绍" class="headerlink" title="DS18b20 寄存器介绍"></a>DS18b20 寄存器介绍</h2><p>DS18B20 芯片具有几个重要的寄存器，用于配置和控制传感器的功能。以下是 DS18B20常用的寄存器介绍：</p><ul><li><strong>温度寄存器（Temperature Register）</strong>：温度寄存器存储了最近一次温度测量的结果。它是一个 16 位的寄存器，包含了温度值的原始数据。通过读取温度寄存器中的数据，并结合分辨率设置，可以计算出实际的温度值。</li><li><strong>配置寄存器（Configuration Register）</strong>：配置寄存器用于设置 DS18B20 的工作模式和温度分辨率。它是一个 8 位的寄存器，每个位对应一个配置选项。通过写入配置寄存器，可以选择温度分辨率、触发温度转换和使用电源供电模式等。</li><li><p><strong>精度寄存器（Resolution Register）</strong>：精度寄存器用于设置温度分辨率。它是一个 8 位的寄存器，每个位对应一种分辨率选项。通过写入精度寄存器，可以选择不同的温度分辨率，例如 9 位、10 位、11 位或 12 位。</p></li><li><p><strong>唯一地址寄存器（Unique Address Register）</strong>：唯一地址寄存器存储了 DS18B20 芯片的唯一64 位地址。每个 DS18B20 芯片都有唯一的地址，通过读取唯一地址寄存器中的数据，可以获取芯片的地址信息。</p></li></ul><h3 id="配置寄存器"><a href="#配置寄存器" class="headerlink" title="配置寄存器"></a>配置寄存器</h3><p>配置寄存器用于设置 DS18B20 的工作模式和温度分辨率。它是一个 8 位的寄存器，每个位对应一个配置选项。如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195441591.png" alt="配置寄存器"></p><blockquote><p>注意：上电默认设置 R0=1,R1=1(12 位精度)。</p></blockquote><p><strong>精度和转换时间之间有直接关系</strong>。配置寄存器的位 7 和位 0 到 4 被器件保留，禁止写入。温度分辨率设置表如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195442527.png" alt="硬度和转换时间的关系"></p><h3 id="温度测量寄存器"><a href="#温度测量寄存器" class="headerlink" title="温度测量寄存器"></a>温度测量寄存器</h3><p>DS18B20 芯片的温度寄存器是一个 16 位的寄存器，用于存储最近一次温度测量的原始数据。温度寄存器的位布局如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195504612.png" alt="Temperature Register Format"></p><p>温度寄存器的最低有效位（LSB）是 2^-4 位，表示温度的最小精度为 0.0625°C。其他位依次表示更高的温度精度，分别为: </p><ul><li>2^-3^（0.125）</li><li>2^-2^（0.25）</li><li>2^-1^（0.5）</li><li>2^0^（1）</li><li>2^1^（2）</li><li>2^2^（4）</li><li>2^3^（8）</li></ul><p>DS18B20 芯片的温度寄存器中存储的原始数据可以通过以下步骤计算出实际温度值：</p><ol><li>从温度寄存器读取的 16 位数据可以解释为一个有符号整数，其中最高位（MSB）表示符号位。如果符号位为 0，表示正温度；如果符号位为 1，表示负温度。</li><li>取出温度寄存器中的低 11 位（位 4 到位 15），这些位表示温度的绝对值，其中位值为 1 表示该位对应的温度分辨率有效。</li><li>将这 11 位数据与符号位组合成一个有符号整数。</li><li>根据所选择的温度分辨率，<strong>将有符号整数乘以相应的分辨率因子</strong>，以获得实际的温度值。</li><li>当温度大于 0 时，符号位为 0，测量到的温度值乘以分辨率因子即可得到实际的温度。</li><li>当温度小于 0 时，符号位为 1，测量得到的温度值取反加一再乘以分辨率因子即可得到实际的温度。</li></ol><blockquote><p>举个例子，假设选择了 12 位的温度分辨率，并从温度寄存器读取的数据为 0x1FFF。</p><p>0x1FFF 的二进制表示为：0001 1111 1111 1111。最高位为 0，表示正温度。取出低 11 位：111 1111 1111。将这 11 位与符号位组合，得到有符号整数为：0111 1111 1111（对应 0x07FF）。</p><p>对于 12 位的温度分辨率，分辨率因子为 0.0625°C。将有符号整数 0x07FF乘以分辨率因子：0x07FF * 0.0625 = 127.9375°C。</p><p>因此，从温度寄存器读取的数据 0x1FFF 对应着约 127.94°C 的实际温度值。</p></blockquote><h2 id="DS18b20-指令介绍"><a href="#DS18b20-指令介绍" class="headerlink" title="DS18b20 指令介绍"></a>DS18b20 指令介绍</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>根据 DS18B20 的通讯协议，主机（单片机）控制 DS18B20 完成温度转换必须经过三个步骤：</p><ul><li>每一次读写之前都要对 DS18B20 进行复位操作</li><li>复位成功后发送一条 ROM 指令</li><li>最后发送 RAM 指令，这样才能对 DS18B20 进行预定的操作。</li></ul><p>复位要求主 CPU 将数据线下拉 500 微秒，然后 释放，当 DS18B20 收到信号后等待 16～60 微秒左右，后发出 60～240 微秒的存在低脉冲，主 CPU 收到此信号表示复位成功。</p><p>ROM指令</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195442659.png" alt="ROM指令"></p><p>RAM指令</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195443252.png" alt="DS18B20 Function Command Set"></p><h3 id="操作举例"><a href="#操作举例" class="headerlink" title="操作举例"></a>操作举例</h3><p><strong>当单总线上只有一个 DS18b20 的时候</strong>：</p><ol><li>开始进行温度转换：<ul><li>复位信号</li><li>发送 ROM 指令 OXCC 跳过搜索</li><li>发送 RAM 指令 0x44 进行温度转换。</li></ul></li><li>读温度：<ul><li>复位信号</li><li>发送 ROM 指令 OXCC 跳过搜索</li><li>发送 RAM 指令 0xbe 读暂存器。</li></ul></li><li>设置 ds18b20:<ul><li>复位信号</li><li>发送 ROM 指令 OXCC 跳过搜索</li><li>发送 RAM 指令 0x4e 写暂存器</li><li>要写的数据。</li></ul></li></ol><p><strong>当单总线上有多个 ds18b20 的时候</strong></p><ol><li>开始进行温度转换：<ul><li>复位信号</li><li>发送 ROM 指令 0x55 匹配指令</li><li>发送 DS18b20 的地址</li><li>发送 RAM 指令 0x44 进行温度转换。</li></ul></li><li>读温度：<ul><li>复位信号</li><li>发送 ROM 指令 0x55 匹配指令</li><li>发送 DS18b20 的地址</li><li>发送 RAM 指令 0xbe 读暂存器。</li></ul></li><li>设置 ds18b20:<ul><li>复位信号</li><li>发送 ROM 指令 0x55 匹配指令</li><li>发送 DS18b20 的地址</li><li>发送RAM 指令 0x4e 写暂存器</li><li>要写的数据。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">Linux 单总线</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
    <category term="driver" scheme="https://even629.com/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>面试经典150题 P295 数据流的中位数</title>
    <link href="https://even629.com/posts/295/"/>
    <id>https://even629.com/posts/295/</id>
    <published>2025-12-19T05:46:13.000Z</published>
    <updated>2025-12-19T05:46:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-19</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P295 数据流的中位数" href="https://leetcode.cn/problems/find-median-from-data-stream/description/"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P295 数据流的中位数</p><p class="url">https://leetcode.cn/problems/find-median-from-data-stream/description/</p></div></a></div></p><p>对顶堆，一个最大堆存前半部分，一个最小堆存后半部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::priority_queue;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, std::less&lt;<span class="type">int</span>&gt; &gt; max_heap;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt; &gt; min_heap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MedianFinder</span>()</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (max_heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        max_heap.<span class="built_in">push</span>(num);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((max_heap.<span class="built_in">size</span>() + min_heap.<span class="built_in">size</span>()) &amp; <span class="number">0x1</span>) &#123; <span class="comment">// 奇数</span></span><br><span class="line">                        <span class="type">int</span> curr_median = max_heap.<span class="built_in">top</span>();</span><br><span class="line">                        <span class="keyword">if</span> (num &gt;= curr_median) &#123;</span><br><span class="line">                                min_heap.<span class="built_in">push</span>(num);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                max_heap.<span class="built_in">pop</span>();</span><br><span class="line">                                min_heap.<span class="built_in">push</span>(curr_median);</span><br><span class="line">                                max_heap.<span class="built_in">push</span>(num);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 偶数</span></span><br><span class="line">                        <span class="keyword">if</span> (num &lt;= min_heap.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                                max_heap.<span class="built_in">push</span>(num);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                max_heap.<span class="built_in">push</span>(min_heap.<span class="built_in">top</span>());</span><br><span class="line">                                min_heap.<span class="built_in">pop</span>();</span><br><span class="line">                                min_heap.<span class="built_in">push</span>(num);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> ((max_heap.<span class="built_in">size</span>() + min_heap.<span class="built_in">size</span>()) &amp; <span class="number">0x1</span>) &#123; <span class="comment">// 奇数</span></span><br><span class="line">                        <span class="keyword">return</span> (<span class="type">double</span>)max_heap.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 偶数</span></span><br><span class="line">                        <span class="built_in">return</span> ((<span class="type">double</span>)max_heap.<span class="built_in">top</span>() + (<span class="type">double</span>)min_heap.<span class="built_in">top</span>()) / <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
    
    
    <summary type="html">堆</summary>
    
    
    
    <category term="algorithm" scheme="https://even629.com/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://even629.com/tags/algorithm/"/>
    
    <category term="堆" scheme="https://even629.com/tags/%E5%A0%86/"/>
    
    <category term="leetcode面试经典150题" scheme="https://even629.com/tags/leetcode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Linux 输入子系统</title>
    <link href="https://even629.com/posts/2512183/"/>
    <id>https://even629.com/posts/2512183/</id>
    <published>2025-12-18T12:31:13.000Z</published>
    <updated>2025-12-18T12:31:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-18</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h2 id="输入子系统"><a href="#输入子系统" class="headerlink" title="输入子系统"></a>输入子系统</h2><p>在 Linux 中，input 子系统是专门为处理输入类设备而设计的一个子系统或框架。它提供了一套通用的接口和机制，用于驱动开发人员编写和管理输入设备的驱动程序。输入设备包括键盘、鼠标、触摸屏、游戏手柄等。</p><p>使用 input 子系统的主要目的是规范和简化输入设备驱动的开发过程，以提高驱动的通用性和兼容性。它通过<strong>将输入设备的共同功能和处理逻辑提取出来，编写成通用的代码，将差异化的代码留给具体的设备驱动开发人员</strong>，这种分工合作的方式使得驱动开发人员可以更专注地处理设备特定的细节，从而大大降低工程师的开发难度。</p><p>综上使用 input 子系统的作用如下所示：</p><ul><li><strong>兼容性</strong>： 输入子系统提供了一个统一的框架和接口，使得不同厂家的输入设备都可以按照相同的规范进行驱动开发。无论是键盘、鼠标还是其他输入设备，只要符合输入子系统定义的接口和事件格式，都可以在 Linux 系统中正常工作。这样一来，工程师不需要针对每个厂家的设备编写和维护不同的驱动代码，大大提高了设备的兼容性。</li><li><strong>统一的驱动编程方式</strong>： 输入子系统定义了一套通用的驱动编程方式，工程师只需要按照输入子系统的规范进行开发即可。输入设备的驱动模块需要实现相应的接口函数，如初始化函数、事件处理函数等。这些接口函数的实现方式是相同的，不论是键盘驱动还是鼠标驱动，都可以按照统一的方式进行开发。这样一来，工程师可以更加专注于设备特定的细节，而无需关心通用的驱动框架，简化了开发过程。</li><li><strong>统一的应用操作接口</strong>： 输入子系统通过提供一组统一的应用操作接口，如<code>/dev/input/eventX</code>，使得应用程序可以方便地与输入设备进行交互。应用程序可以通过读取这些设备节点，获取输入事件的信息，并进行相应的处理。无论是哪种类型的输入设备，应用程<br>序都可以使用相同的方式进行访问和操作。这样一来，应用程序的开发人员不需要关心底层输入设备的细节，可以更加专注于应用程序的逻辑开发。</li></ul><h2 id="如何确定输入设备和节点之间的关系"><a href="#如何确定输入设备和节点之间的关系" class="headerlink" title="如何确定输入设备和节点之间的关系"></a>如何确定输入设备和节点之间的关系</h2><p>在输入子系统中，输入设备与设备节点之间有一定的对应关系。以下是判断设备节点与输入设备的方法：</p><ol><li><strong>设备名</strong>： 输入子系统的设备节点可以分为<strong>通用设备名</strong>和<strong>专用设备名</strong>。专用设备名通常可以从设备名中直接识别出设备类型，例如”keyboard”（键盘）或”mouse”（鼠标）。而通用设备名则不能直接确定设备类型。如下图所示，event0-event4 属于通用设备名，而 mouse0 和mouse2 属于专用设备名。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195155210.png" alt="/dev/input"></p><ol><li>试探性方法： 可以使用”cat”命令打开设备节点文件，然后对物理设备进行操作，观察终 端 是 否 有 输 出 。 例 如 ， 对 于 键 盘 设 备 ， 你 可 以 运 行 <code>cat /dev/input/eventX</code> ， 其 中<code>/dev/input/eventX</code>是设备节点的路径，然后按下键盘按键，观察终端是否输出相应的字符。通过这种试探性的方法，你可以判断设备节点与具体设备之间的对应关系。例如使用以下命令来测试鼠标，如下所示：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /dev/input/mouse0</span><br><span class="line"><span class="built_in">sudo</span> hexdump /dev/input/mouse0</span><br></pre></td></tr></table></figure><ol><li>查看输入设备信息：可以使用以下命令查看<code>/proc/bus/input/devices</code>文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/bus/input/devices</span><br></pre></td></tr></table></figure><p>部分打印截图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195158455.png" alt="/proc/bus/input/devices"></p><p>该文件记录了当前系统的所有输入设备的信息在该文件中，你可以找到与设备节点相关的信息，例如设备名称、供应商 ID、产品 ID 等。通过对比设备节点的路径和设备信息中的对应字段，可以确定设备节点与特定输入设备之间的关系，例如可以通过上述打印信息查看到，<br>键盘对应的设备节点为<code>/dev/input/event1</code>，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195413467.png" alt="keyboard"></p><ul><li><code>I: Bus=0011 Vendor=0001 Product=0001 Version=ab41</code></li></ul><p>这一行显示了设备的总线类型、供应商 ID、产品 ID 和固件版本。在这个例子中，该设备的总线类型为 0011，供应商 ID 为 0001，<br>产品 ID 为 0001，固件版本为 ab41。</p><ul><li><code>N: Name=&quot;AT Translated Set 2 keyboard&quot;</code></li></ul><p>这一行显示了设备的名称。在这个例子中，该设备的名称为”AT Translated Set 2 keyboard”。</p><ul><li><code>P: Phys=isa0060/serio0/input0</code></li></ul><p>这一行显示了设备的物理位置。在这个例子中，该设备的物理位置是 <code>isa0060/serio0/input0</code>。</p><ul><li><code>S: Sysfs=/devices/platform/i8042/serio0/input/input1</code></li></ul><p>这一行显示了设备在 sysfs 文件系统中的路径。在这个例子中，该设备的路径是<code>/devices/platform/i8042/serio0/input/input1</code>。</p><ul><li><code>U: Uniq=</code>: </li></ul><p>这一行显示了设备的唯一标识符。在这个例子中，唯一标识符为空。</p><ul><li><p><code>H: Handlers=sysrq kbd event1 leds</code></p><p>这一行显示了设备的处理程序。它指示了处理设备输入事件的程序或模块。在这个例子中，设备有 sysrq、kbd、event1 和 leds 这些处理程序，其中 event1就表示设备节点为<code>/dev/input/event1</code>。</p></li><li><p><code>B: PROP=0</code></p><p>这一行显示了设备的属性。在这个例子中，设备的属性值为 0。</p></li><li><p><code>B: EV=120013</code></p></li></ul><p>这一行显示了设备支持的事件类型。在这个例子中，设备支持 EV_SYN、EV_KEY、EV_MSC 和 EV_LED 这些事件类型。</p><ul><li><code>B: KEY=402000000 3803078f800d001 feffffdfffefffff fffffffffffffffe</code></li></ul><p>这一行显示了设备支持的按键。每个按键对应一个位，1 表示按键被按下，0 表示按键未被按下。该行显示了按键的状态，以 16 进制表示。</p><ul><li><code>B: MSC=10</code></li></ul><p>这一行显示了设备支持的杂项事件。在这个例子中，设备支持 MSC_SCAN事件。</p><ul><li><code>B: LED=7</code></li></ul><p>这一行显示了设备支持的 LED 灯。在这个例子中，设备支持 3 个 LED 灯，使用一个 7 位的二进制数表示灯的状态。</p><h2 id="输入子系统框架"><a href="#输入子系统框架" class="headerlink" title="输入子系统框架"></a>输入子系统框架</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195204498.png" alt="输入子系统框架"></p><ul><li><strong>事件处理层（Event Handling Layer）</strong></li></ul><p>事件处理层是输入子系统的最上层，可以<strong>处理输入设备产生的事件并将其传递给上层应用程序</strong>，并<strong>在操作系统中创建设备节点</strong>，以便应用程序可以通过设备节点与输入设备进行通信。它接收来自核心层的输入事件，并根据事件的类型和属性进行相应的处理。</p><ul><li><p><strong>核心层（Core Layer）</strong></p><p>核心层的主要功能是<strong>作为匹配器位于事件处理层和设备驱动层之间</strong>。它起到协调和连接这两个层级的作用，以<strong>确保输入设备的事件能够正确地传递给相应的事件处理程序</strong>。以下是核心层在输入子系统中的主要功能：</p><ul><li><strong>事件匹配</strong>： 核心层负责<strong>将输入设备产生的原始输入数据与相应的事件处理程序进行匹配</strong>。它会解析原始输入数据，并根据预定义的规则和配置信息，确定应该将输入数据传递给哪个事件处理程序进行处理。</li><li><strong>设备管理和控制</strong>： 核心层负责<strong>维护输入设备的状态、属性和配置信息，并提供设备的注册、注销和管理功能</strong>。它与设备驱动层进行交互，接收来自设备驱动层的输入事件，并将其转化为抽象化的事件表示形式。核心层提供一致的接口，使得上层应用程序可以独立于具体的硬件设备进行操作。</li><li><strong>事件处理和分发</strong>： 核心层<strong>负责事件的处理和分发，将输入事件传递给对应的事件处理层</strong>。它通过事件队列的机制，接收和缓存来自设备驱动层的输入事件，并按照特定的规则将事件分发给对应的事件处理层或应用程序。这样，事件处理层可以通过核心层提供的接口，获取输入事件并进行相应的处理。</li><li><strong>抽象化接口和事件处理机制</strong>： 核心层<strong>为上层应用程序和事件处理层提供了一组抽象化的接口和事件处理机制</strong>。它提供了统一的事件表示形式，使得不同类型的输入设备（如键盘、鼠标、触摸屏等）的事件可以被表示和处理。通过核心层的接口，事件处理层可以注册事件监听器、订阅特定类型的事件，并获取输入设备的状态信息。</li></ul></li><li><p><strong>设备驱动层（Device Driver Layer）</strong></p></li></ul><p>设备驱动层是输入子系统的最底层，负责<strong>与硬件设备进行通信和交互</strong>。它的主要职责是将硬件设备的操作和功能抽象为统一的接口，以便核心层和事件处理层可以与之交互。设备驱动层的代码通常包括硬件的初始化、中断处理、数据传输等操作，以确保输入设备的正常工作。开发者在这一层编写驱动程序，以适配特定的硬件设备。</p><p>Linux 源码中已经写好了核心层相关的代码，所以在后续编写输入子系统驱动的时候，<strong>核心层的代码是不需要编写的</strong>，而事件处理层在 Linux 中也为我们提供了一个模板，除了一些例如固定设备节点的需求外，<strong>一般不需要编写事件处理层的代码</strong>，而设备驱动层由于要面对不同的硬件，每个硬件的初始化方式又都都不同，所以<strong>设备驱动层的代码在编写输入子系统驱动的时候是需要填充的</strong>。</p><h2 id="输入子系统数据结构"><a href="#输入子系统数据结构" class="headerlink" title="输入子系统数据结构"></a>输入子系统数据结构</h2><p>事件处理层的代码位于 <code>drivers/input/evdev.c</code> 文件中,为上层的应用程序提供了统一的事件处理机制。它定义了处理输入设备事件的函数，并提供了读取事件、控制设备等功能的接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/evdev.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> <span class="title">evdev_handler</span> =</span> &#123;</span><br><span class="line">.event= evdev_event, <span class="comment">// 事件处理函数指针，指向名为 evdev_event 的函数，用于处理输入事件</span></span><br><span class="line">.events= evdev_events,<span class="comment">// 批量事件处理函数指针，指向名为 evdev_events 的函数，用于处理输入设备的多个事件</span></span><br><span class="line">.connect= evdev_connect,</span><br><span class="line">.disconnect= evdev_disconnect,</span><br><span class="line">.legacy_minors= <span class="literal">true</span>,</span><br><span class="line">.minor= EVDEV_MINOR_BASE,</span><br><span class="line">.name= <span class="string">&quot;evdev&quot;</span>,<span class="comment">// 设备名称，设置为字符串 &quot;evdev&quot;</span></span><br><span class="line">.id_table= evdev_ids,<span class="comment">// 输入设备 ID 表，指向名为 evdev_ids 的表，用于匹配输入设备的 ID</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">evdev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> input_register_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">evdev_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">input_unregister_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(evdev_init);</span><br><span class="line">module_exit(evdev_exit);</span><br></pre></td></tr></table></figure><p>这里的 <code>input_register_handler</code> 函数会将 <code>evdev handler</code> 添加到输入子系统的 <code>handler</code> 列表中，并分配一个唯一的 <code>handler</code> 编号：</p><h3 id="input-register-handler"><a href="#input-register-handler" class="headerlink" title="input_register_handler()"></a>input_register_handler()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/input.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_register_handler - register a new input handler</span></span><br><span class="line"><span class="comment"> * @handler: handler to be registered</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function registers a new input handler (interface) for input</span></span><br><span class="line"><span class="comment"> * devices in the system and attaches it to all input devices that</span></span><br><span class="line"><span class="comment"> * are compatible with the handler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">input_register_handler</span><span class="params">(<span class="keyword">struct</span> input_handler *handler)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"><span class="comment">// 尝试获取输入互斥锁，以确保在注册处理程序时不会被中断</span></span><br><span class="line">error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"><span class="comment">// 初始化处理程序链表头</span></span><br><span class="line">INIT_LIST_HEAD(&amp;handler-&gt;h_list);</span><br><span class="line"><span class="comment">// 将处理程序添加到全局处理程序链表的末尾，使其能够与输入子系统的其他组件进行交互</span></span><br><span class="line">list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line"><span class="comment">// 遍历输入设备链表，为每个设备附加处理程序，这样可以为每个输入设备建立与处理程序的连接，以便处理设备发送的输入事件</span></span><br><span class="line">list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">input_attach_handler(dev, handler);</span><br><span class="line"><span class="comment">// 唤醒 procfs 读取器，通知其有新的处理程序注册，以便读取器可以及时获取新的输入事件信息。</span></span><br><span class="line">input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放输入互斥锁，以允许其他线程继续访问输入子系统</span></span><br><span class="line">mutex_unlock(&amp;input_mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_register_handler);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="input-handler-结构体"><a href="#input-handler-结构体" class="headerlink" title="input_handler 结构体"></a>input_handler 结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/input.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct input_handler - implements one of interfaces for input devices</span></span><br><span class="line"><span class="comment"> * @private: driver-specific data</span></span><br><span class="line"><span class="comment"> * @event: event handler. This method is being called by input core with</span></span><br><span class="line"><span class="comment"> *interrupts disabled and dev-&gt;event_lock spinlock held and so</span></span><br><span class="line"><span class="comment"> *it may not sleep</span></span><br><span class="line"><span class="comment"> * @events: event sequence handler. This method is being called by</span></span><br><span class="line"><span class="comment"> *input core with interrupts disabled and dev-&gt;event_lock</span></span><br><span class="line"><span class="comment"> *spinlock held and so it may not sleep</span></span><br><span class="line"><span class="comment"> * @filter: similar to @event; separates normal event handlers from</span></span><br><span class="line"><span class="comment"> *&quot;filters&quot;.</span></span><br><span class="line"><span class="comment"> * @match: called after comparing device&#x27;s id with handler&#x27;s id_table</span></span><br><span class="line"><span class="comment"> *to perform fine-grained matching between device and handler</span></span><br><span class="line"><span class="comment"> * @connect: called when attaching a handler to an input device</span></span><br><span class="line"><span class="comment"> * @disconnect: disconnects a handler from input device</span></span><br><span class="line"><span class="comment"> * @start: starts handler for given handle. This function is called by</span></span><br><span class="line"><span class="comment"> *input core right after connect() method and also when a process</span></span><br><span class="line"><span class="comment"> *that &quot;grabbed&quot; a device releases it</span></span><br><span class="line"><span class="comment"> * @legacy_minors: set to %true by drivers using legacy minor ranges</span></span><br><span class="line"><span class="comment"> * @minor: beginning of range of 32 legacy minors for devices this driver</span></span><br><span class="line"><span class="comment"> *can provide</span></span><br><span class="line"><span class="comment"> * @name: name of the handler, to be shown in /proc/bus/input/handlers</span></span><br><span class="line"><span class="comment"> * @id_table: pointer to a table of input_device_ids this driver can</span></span><br><span class="line"><span class="comment"> *handle</span></span><br><span class="line"><span class="comment"> * @h_list: list of input handles associated with the handler</span></span><br><span class="line"><span class="comment"> * @node: for placing the driver onto input_handler_list</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Input handlers attach to input devices and create input handles. There</span></span><br><span class="line"><span class="comment"> * are likely several handlers attached to any given input device at the</span></span><br><span class="line"><span class="comment"> * same time. All of them will get their copy of input event generated by</span></span><br><span class="line"><span class="comment"> * the device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The very same structure is used to implement input filters. Input core</span></span><br><span class="line"><span class="comment"> * allows filters to run first and will not pass event to regular handlers</span></span><br><span class="line"><span class="comment"> * if any of the filters indicate that the event should be filtered (by</span></span><br><span class="line"><span class="comment"> * returning %true from their filter() method).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that input core serializes calls to connect() and disconnect()</span></span><br><span class="line"><span class="comment"> * methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *private;<span class="comment">// 私有数据指针，用于存储特定处理程序的私有数据</span></span><br><span class="line"><span class="comment">// 事件处理函数指针，当输入事件发生时调用，参数包括输入句柄、事件类型、事件代码和事件值</span></span><br><span class="line"><span class="type">void</span> (*event)(<span class="keyword">struct</span> input_handle *handle, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value);</span><br><span class="line"><span class="comment">// 批量事件处理函数指针，当输入设备有多个事件同时发生时调用，参数包括输入句柄、事件值数组和事件数量</span></span><br><span class="line">    <span class="type">void</span> (*events)(<span class="keyword">struct</span> input_handle *handle,</span><br><span class="line">       <span class="type">const</span> <span class="keyword">struct</span> input_value *vals, <span class="type">unsigned</span> <span class="type">int</span> count);</span><br><span class="line"><span class="comment">// 事件过滤函数指针，用于确定是否接收和处理特定类型和代码的事件，返回值为布尔类型，表示是否接受该事件</span></span><br><span class="line">    <span class="type">bool</span> (*filter)(<span class="keyword">struct</span> input_handle *handle, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value);</span><br><span class="line"><span class="comment">// 匹配函数指针，用于确定处理程序是否适用于给定的输入设备，返回值为布尔类型，表示是否适用</span></span><br><span class="line">    <span class="type">bool</span> (*match)(<span class="keyword">struct</span> input_handler *handler, <span class="keyword">struct</span> input_dev *dev);</span><br><span class="line"><span class="comment">// 连接函数指针，用于建立输入设备和处理程序之间的连接，返回值为整数类型，表示连接的结果</span></span><br><span class="line">    <span class="type">int</span> (*connect)(<span class="keyword">struct</span> input_handler *handler, <span class="keyword">struct</span> input_dev *dev, <span class="type">const</span> <span class="keyword">struct</span> input_device_id *id);</span><br><span class="line">    <span class="comment">// 断开连接函数指针，用于断开输入设备和处理程序之间的连接</span></span><br><span class="line"><span class="type">void</span> (*disconnect)(<span class="keyword">struct</span> input_handle *handle);</span><br><span class="line">    <span class="comment">// 启动函数指针，用于启动输入设备的数据传输或处理过程</span></span><br><span class="line"><span class="type">void</span> (*start)(<span class="keyword">struct</span> input_handle *handle);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> legacy_minors;<span class="comment">// 是否使用旧版次设备号</span></span><br><span class="line"><span class="type">int</span> minor;<span class="comment">// 设备次设备号</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;<span class="comment">// 设备名称</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id_table</span>;</span><span class="comment">// 输入设备 ID 表</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">h_list</span>;</span><span class="comment">// 处理程序链表头</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">node</span>;</span><span class="comment">// 处理程序链表节点</span></span><br><span class="line"></span><br><span class="line">ANDROID_KABI_RESERVE(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="input-attach-handler"><a href="#input-attach-handler" class="headerlink" title="input_attach_handler()"></a>input_attach_handler()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/input.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">input_attach_handler</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="keyword">struct</span> input_handler *handler)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"><span class="comment">// 通过输入设备和处理程序的匹配函数来确定是否适用于该设备</span></span><br><span class="line">    <span class="comment">// 这个函数将在处理程序的输入设备 ID 表中查找与给定的输入设备匹配的 ID，</span></span><br><span class="line">    <span class="comment">// 并返回匹配的 ID。如果没有找到匹配的 ID，则返回 NULL</span></span><br><span class="line">id = input_match_device(handler, dev);</span><br><span class="line"><span class="keyword">if</span> (!id)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"><span class="comment">// 调用处理程序的连接函数来建立设备和处理程序之间的连接</span></span><br><span class="line">error = handler-&gt;connect(handler, dev, id);</span><br><span class="line"><span class="keyword">if</span> (error &amp;&amp; error != -ENODEV)</span><br><span class="line">pr_err(<span class="string">&quot;failed to attach handler %s to device %s, error: %d\n&quot;</span>,</span><br><span class="line">       handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="input-match-device"><a href="#input-match-device" class="headerlink" title="input_match_device()"></a>input_match_device()</h3><p>这个函数在输入子系统中的作用是在给定的输入事件处理程序（<code>input_handler）</code>中查找与指定输入设备匹配的输入设备 ID（input device ID）。</p><p>处理程序的输入设备 ID 表是一个以 <code>struct input_device_id</code> 结构为元素的数组，每个元素表示一个可能的输入设备 ID</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/input.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> input_device_id *<span class="title function_">input_match_device</span><span class="params">(<span class="keyword">struct</span> input_handler *handler,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> input_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line"><span class="comment">// 遍历处理程序的输入设备 ID 表，直到找到匹配的 ID 或遍历完所有 ID 为止</span></span><br><span class="line"><span class="keyword">for</span> (id = handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123;</span><br><span class="line"><span class="keyword">if</span> (input_match_device_id(dev, id) &amp;&amp;<span class="comment">// 使用输入设备 ID 匹配函数判断给定的输入设备是否与当前 ID 匹配</span></span><br><span class="line">    (!handler-&gt;match || handler-&gt;match(handler, dev))) &#123;<span class="comment">// 如果输入设备与 ID 匹配，并且处理程序的匹配函数返回 true（或者没有匹配函数），则返回该 ID</span></span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="input-match-device-id"><a href="#input-match-device-id" class="headerlink" title="input_match_device_id()"></a>input_match_device_id()</h4><p><code>input_match_device_id(dev, id)</code>调用输入设备 ID 匹配函数来判断给定的输入设备是否与当前 ID 匹配。匹配函数的作用是比较输入设备的属性与 ID 中指定的属性是否一致，例如厂商 ID、产品 ID 等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">input_match_device_id</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="keyword">struct</span> input_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS)</span><br><span class="line"><span class="keyword">if</span> (id-&gt;bustype != dev-&gt;id.bustype)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VENDOR)</span><br><span class="line"><span class="keyword">if</span> (id-&gt;vendor != dev-&gt;id.vendor)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_PRODUCT)</span><br><span class="line"><span class="keyword">if</span> (id-&gt;product != dev-&gt;id.product)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VERSION)</span><br><span class="line"><span class="keyword">if</span> (id-&gt;version != dev-&gt;id.version)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bitmap_subset(id-&gt;evbit, dev-&gt;evbit, EV_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;keybit, dev-&gt;keybit, KEY_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;relbit, dev-&gt;relbit, REL_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;absbit, dev-&gt;absbit, ABS_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;mscbit, dev-&gt;mscbit, MSC_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;ledbit, dev-&gt;ledbit, LED_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;sndbit, dev-&gt;sndbit, SND_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;ffbit, dev-&gt;ffbit, FF_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;swbit, dev-&gt;swbit, SW_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;propbit, dev-&gt;propbit, INPUT_PROP_MAX)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_match_device_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="input-dev-结构体"><a href="#input-dev-结构体" class="headerlink" title="input_dev 结构体"></a>input_dev 结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input/linux/input.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;<span class="comment">// 设备的名称</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *phys;<span class="comment">// 设备的物理位置</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *uniq;<span class="comment">// 设备的唯一标识符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span><span class="comment">// 输入设备的标识信息</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];<span class="comment">// 设备的属性位图</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> evbit[BITS_TO_LONGS(EV_CNT)];<span class="comment">// 设备支持的事件类型位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> keybit[BITS_TO_LONGS(KEY_CNT)];<span class="comment">// 设备支持的按键位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> relbit[BITS_TO_LONGS(REL_CNT)];<span class="comment">// 设备支持的相对坐标位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> absbit[BITS_TO_LONGS(ABS_CNT)];<span class="comment">// 设备支持的绝对坐标位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)];<span class="comment">// 设备支持的杂项事件位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ledbit[BITS_TO_LONGS(LED_CNT)];<span class="comment">// 设备支持的 LED 位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sndbit[BITS_TO_LONGS(SND_CNT)];<span class="comment">// 设备支持的声音位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ffbit[BITS_TO_LONGS(FF_CNT)];<span class="comment">// 设备支持的力反馈位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> swbit[BITS_TO_LONGS(SW_CNT)];<span class="comment">// 设备支持的开关位图</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> hint_events_per_packet;<span class="comment">// 每个输入事件报告中的事件数量提示</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> keycodemax;<span class="comment">// 支持的按键编码的最大值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> keycodesize;<span class="comment">// 按键编码的字节大小</span></span><br><span class="line"><span class="type">void</span> *keycode;<span class="comment">// 按键编码数据的指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*setkeycode)(<span class="keyword">struct</span> input_dev *dev,</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> input_keymap_entry *ke,</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *old_keycode);<span class="comment">// 设置按键编码的回调函数</span></span><br><span class="line"><span class="type">int</span> (*getkeycode)(<span class="keyword">struct</span> input_dev *dev,</span><br><span class="line">  <span class="keyword">struct</span> input_keymap_entry *ke);<span class="comment">// 获取按键编码的回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ff_device</span> *<span class="title">ff</span>;</span><span class="comment">// 力反馈设备</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev_poller</span> *<span class="title">poller</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> repeat_key;<span class="comment">// 重复按键的编码</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span><span class="comment">// 定时器用于处理重复按键</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rep[REP_CNT];<span class="comment">// 按键重复设置</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_mt</span> *<span class="title">mt</span>;</span><span class="comment">// 多点触摸信息</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_absinfo</span> *<span class="title">absinfo</span>;</span><span class="comment">// 绝对坐标信息</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> key[BITS_TO_LONGS(KEY_CNT)];<span class="comment">// 当前按键状态位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> led[BITS_TO_LONGS(LED_CNT)];<span class="comment">// 当前 LED 状态位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> snd[BITS_TO_LONGS(SND_CNT)];<span class="comment">// 当前声音状态位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sw[BITS_TO_LONGS(SW_CNT)];<span class="comment">// 当前开关状态位图</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*open)(<span class="keyword">struct</span> input_dev *dev);<span class="comment">// 打开设备的回调函数</span></span><br><span class="line"><span class="type">void</span> (*close)(<span class="keyword">struct</span> input_dev *dev);<span class="comment">// 关闭设备的回调函数</span></span><br><span class="line"><span class="type">int</span> (*flush)(<span class="keyword">struct</span> input_dev *dev, <span class="keyword">struct</span> file *file);<span class="comment">// 刷新设备的回调函数</span></span><br><span class="line"><span class="type">int</span> (*event)(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value);<span class="comment">// 处理输入事件的回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> __<span class="title">rcu</span> *<span class="title">grab</span>;</span><span class="comment">// 设备的当前占用者</span></span><br><span class="line"></span><br><span class="line"><span class="type">spinlock_t</span> event_lock;<span class="comment">// 事件锁，用于保护事件队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span><span class="comment">// 互斥锁，用于保护设备状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> users;<span class="comment">// 设备的使用者数量</span></span><br><span class="line"><span class="type">bool</span> going_away;<span class="comment">// 设备是否即将被移除</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span><span class="comment">// 设备结构体</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">h_list</span>;</span><span class="comment">// 用于设备管理的链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">node</span>;</span><span class="comment">// 用于设备管理的链表</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num_vals;<span class="comment">// 输入值的数量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_vals;<span class="comment">// 最大输入值的数量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">vals</span>;</span><span class="comment">// 输入值的数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> devres_managed;<span class="comment">// 是否由设备资源管理</span></span><br><span class="line"></span><br><span class="line"><span class="type">ktime_t</span> timestamp[INPUT_CLK_MAX];<span class="comment">// 输入事件的时间戳数组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> to_input_dev(d) container_of(d, struct input_dev, dev)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="input-handle-结构体"><a href="#input-handle-结构体" class="headerlink" title="input_handle 结构体"></a>input_handle 结构体</h3><p>在调用 connect 函数（evdev的connect函数）之后，会创建一个 <code>input_handle</code> 结构体，用于记录匹配成功的输入处理程序（<code>input_handler</code>）和输入设备（<code>input_dev</code>），并建立它们之间的关系。下面是 <code>input_handle</code> 结构体的定义（位于 <code>include/linux/input.h</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct input_handle - links input device with an input handler</span></span><br><span class="line"><span class="comment"> * @private: handler-specific data</span></span><br><span class="line"><span class="comment"> * @open: counter showing whether the handle is &#x27;open&#x27;, i.e. should deliver</span></span><br><span class="line"><span class="comment"> *events from its device</span></span><br><span class="line"><span class="comment"> * @name: name given to the handle by handler that created it</span></span><br><span class="line"><span class="comment"> * @dev: input device the handle is attached to</span></span><br><span class="line"><span class="comment"> * @handler: handler that works with the device through this handle</span></span><br><span class="line"><span class="comment"> * @d_node: used to put the handle on device&#x27;s list of attached handles</span></span><br><span class="line"><span class="comment"> * @h_node: used to put the handle on handler&#x27;s list of handles from which</span></span><br><span class="line"><span class="comment"> *it gets events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *private;<span class="comment">// 私有数据指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> open;<span class="comment">// 打开计数</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;<span class="comment">// 名称</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span><span class="comment">// 输入设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span><span class="comment">// 输入处理程序</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">d_node</span>;</span><span class="comment">// 指向输入设备链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">h_node</span>;</span><span class="comment">// 指向输入处理程序链表的节点</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="evdev-connect"><a href="#evdev-connect" class="headerlink" title="evdev_connect()"></a>evdev_connect()</h3><p><code>input_handler</code>的connect函数</p><p>该函数的主要功能是建立与输入设备的连接，初始化并注册输入句柄，设置设备属性，并添加字符设备到系统中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> &#123;</span></span><br><span class="line"><span class="type">int</span> open;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> <span class="title">handle</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> __<span class="title">rcu</span> *<span class="title">grab</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">client_list</span>;</span></span><br><span class="line"><span class="type">spinlock_t</span> client_lock; <span class="comment">/* protects client_list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line"><span class="type">bool</span> exist;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> packet_head; <span class="comment">/* [future] position of the first element of next packet */</span></span><br><span class="line"><span class="type">spinlock_t</span> buffer_lock; <span class="comment">/* protects access to buffer, head and tail */</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> wait;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">input_clock_type</span> <span class="title">clk_type</span>;</span></span><br><span class="line"><span class="type">bool</span> revoked;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *evmasks[EV_CNT];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bufsize;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">buffer</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create new evdev device. Note that input core serializes calls</span></span><br><span class="line"><span class="comment"> * to connect and disconnect.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">evdev_connect</span><span class="params">(<span class="keyword">struct</span> input_handler *handler, <span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="keyword">struct</span> input_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span></span><br><span class="line"><span class="type">int</span> minor;</span><br><span class="line"><span class="type">int</span> dev_no;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"><span class="comment">// 获取一个新的次设备号</span></span><br><span class="line">minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (minor &lt; <span class="number">0</span>) &#123;</span><br><span class="line">error = minor;</span><br><span class="line">pr_err(<span class="string">&quot;failed to reserve new minor: %d\n&quot;</span>, error);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 分配并初始化 evdev 结构体</span></span><br><span class="line">evdev = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> evdev), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!evdev) &#123;</span><br><span class="line">error = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err_free_minor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化 evdev 结构体中的成员</span></span><br><span class="line">INIT_LIST_HEAD(&amp;evdev-&gt;client_list);<span class="comment">// 初始化客户端链表</span></span><br><span class="line">spin_lock_init(&amp;evdev-&gt;client_lock);<span class="comment">// 初始化客户端链表的自旋锁</span></span><br><span class="line">mutex_init(&amp;evdev-&gt;mutex);<span class="comment">// 初始化互斥锁</span></span><br><span class="line">evdev-&gt;exist = <span class="literal">true</span>;<span class="comment">// 设置 evdev 存在标志为 true</span></span><br><span class="line"></span><br><span class="line">dev_no = minor;</span><br><span class="line"><span class="comment">/* Normalize device number if it falls into legacy range */</span></span><br><span class="line"><span class="keyword">if</span> (dev_no &lt; EVDEV_MINOR_BASE + EVDEV_MINORS)<span class="comment">// 如果设备号在旧版范围内，则进行标准化处理</span></span><br><span class="line">dev_no -= EVDEV_MINOR_BASE;</span><br><span class="line">dev_set_name(&amp;evdev-&gt;dev, <span class="string">&quot;event%d&quot;</span>, dev_no);<span class="comment">// 设置设备名称</span></span><br><span class="line"></span><br><span class="line">evdev-&gt;handle.dev = input_get_device(dev);<span class="comment">// 设置输入句柄的输入设备</span></span><br><span class="line">evdev-&gt;handle.name = dev_name(&amp;evdev-&gt;dev);<span class="comment">// 设置输入句柄的名称为设备名称</span></span><br><span class="line">evdev-&gt;handle.handler = handler;<span class="comment">// 设置输入句柄的处理程序为传入的处理程序</span></span><br><span class="line">evdev-&gt;handle.private = evdev;<span class="comment">//  设置输入句柄的私有数据指针为 evdev 结构体的指针</span></span><br><span class="line"></span><br><span class="line">evdev-&gt;dev.devt = MKDEV(INPUT_MAJOR, minor);<span class="comment">// 设置设备号</span></span><br><span class="line">evdev-&gt;dev.class = &amp;input_class;<span class="comment">// 设置设备的类</span></span><br><span class="line">evdev-&gt;dev.parent = &amp;dev-&gt;dev;<span class="comment">// 设置设备的父设备</span></span><br><span class="line">evdev-&gt;dev.release = evdev_free;<span class="comment">// 设置设备的释放函数为 evdev_free</span></span><br><span class="line">device_initialize(&amp;evdev-&gt;dev);<span class="comment">// 初始化设备</span></span><br><span class="line"></span><br><span class="line">error = input_register_handle(&amp;evdev-&gt;handle);<span class="comment">// 注册输入句柄</span></span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> err_free_evdev;</span><br><span class="line"></span><br><span class="line">cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops);<span class="comment">// 初始化字符设备结构体</span></span><br><span class="line"></span><br><span class="line">error = cdev_device_add(&amp;evdev-&gt;cdev, &amp;evdev-&gt;dev);<span class="comment">// 添加字符设备</span></span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> err_cleanup_evdev;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_cleanup_evdev:</span><br><span class="line">evdev_cleanup(evdev);<span class="comment">// 清理 evdev 结构体</span></span><br><span class="line">input_unregister_handle(&amp;evdev-&gt;handle);<span class="comment">// 取消注册输入句柄</span></span><br><span class="line"> err_free_evdev:</span><br><span class="line">put_device(&amp;evdev-&gt;dev);<span class="comment">// 释放设备</span></span><br><span class="line"> err_free_minor:</span><br><span class="line">input_free_minor(minor);<span class="comment">// 释放次设备号</span></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="input-register-handle"><a href="#input-register-handle" class="headerlink" title="input_register_handle()"></a>input_register_handle()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_register_handle - register a new input handle</span></span><br><span class="line"><span class="comment"> * @handle: handle to register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function puts a new input handle onto device&#x27;s</span></span><br><span class="line"><span class="comment"> * and handler&#x27;s lists so that events can flow through</span></span><br><span class="line"><span class="comment"> * it once it is opened using input_open_device().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is supposed to be called from handler&#x27;s</span></span><br><span class="line"><span class="comment"> * connect() method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">input_register_handle</span><span class="params">(<span class="keyword">struct</span> input_handle *handle)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> =</span> handle-&gt;handler;<span class="comment">// 获取输入处理程序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> =</span> handle-&gt;dev;<span class="comment">// 获取输入设备</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We take dev-&gt;mutex here to prevent race with</span></span><br><span class="line"><span class="comment"> * input_release_device().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在这里获取 dev-&gt;mutex 锁，以防止与 input_release_device() 的竞争。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">error = mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Filters go to the head of the list, normal handlers</span></span><br><span class="line"><span class="comment"> * to the tail.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将过滤器添加到链表头部，普通处理程序添加到链表尾部。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (handler-&gt;filter)</span><br><span class="line">list_add_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Since we are supposed to be called from -&gt;connect()</span></span><br><span class="line"><span class="comment"> * which is mutually exclusive with -&gt;disconnect()</span></span><br><span class="line"><span class="comment"> * we can&#x27;t be racing with input_unregister_handle()</span></span><br><span class="line"><span class="comment"> * and so separate lock is not needed here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 由于我们假设被从 -&gt;connect() 调用，这与 -&gt;disconnect() 是互斥的，</span></span><br><span class="line"><span class="comment">* 所以我们不能与 input_unregister_handle() 竞争，因此此处不需要额外的锁定。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handler-&gt;start)</span><br><span class="line">handler-&gt;start(handle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_register_handle);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该函数的主要作用是将输入处理程序（<code>input_handler</code>）和输入设备（<code>input_dev</code>）建立关联。对于输入设备来说，可以通过遍历 <code>handler-&gt;h_list</code> 链表来查找与之匹配的输入处理程序。这意味着输入设备可以通过遍历与之相关联的输入处理程序链表来找到相应的处理程序。</p><p>对于输入处理程序来说，可以通过遍历 <code>dev-&gt;h_list</code> 链表来查找与之匹配的输入设备。这意味着输入处理程序可以通过遍历与之相关联的输入设备链表来找到相应的设备。这样，通过建立输入处理程序和输入设备之间的关联关系，可以实现输入处理程序对特定输入设备的处理和控制。</p><h3 id="input-register-device"><a href="#input-register-device" class="headerlink" title="input_register_device()"></a>input_register_device()</h3><p><code>input_handler</code> 结构体要使用 <code>input_register_handler</code> 来注册;</p><p>输入处理程序（<code>input_handler</code>）和输入设备（<code>input_dev</code>）链接的结构体 <code>input_handle</code> 也需要 <code>input_register_handle</code> 函数来注册</p><p>输入设备 <code>input_dev</code> 结构体肯定也需要一个函数来注册，<code>input_dev</code> 结构体的注册函数为<code>input_register_device</code>，定义在 <code>drivers/input/input.c</code> 文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">input_register_device</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> =</span> <span class="literal">NULL</span>;<span class="comment">// 输入设备资源结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span><span class="comment">// 输入处理程序指针</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> packet_size;<span class="comment">// 数据包大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *path;<span class="comment">// 设备路径字符串指针</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (test_bit(EV_ABS, dev-&gt;evbit) &amp;&amp; !dev-&gt;absinfo) &#123;</span><br><span class="line">dev_err(&amp;dev-&gt;dev,</span><br><span class="line"><span class="string">&quot;Absolute device without dev-&gt;absinfo, refusing to register\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;devres_managed) &#123;<span class="comment">// 如果设备资源是由管理的，则分配设备资源结构体</span></span><br><span class="line">devres = devres_alloc(devm_input_device_unregister,</span><br><span class="line">      <span class="keyword">sizeof</span>(*devres), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!devres)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">devres-&gt;input = dev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Every input device generates EV_SYN/SYN_REPORT events. */</span></span><br><span class="line">    <span class="comment">/* 每个输入设备都会产生 EV_SYN/SYN_REPORT 事件。 */</span></span><br><span class="line">__set_bit(EV_SYN, dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* KEY_RESERVED is not supposed to be transmitted to userspace. */</span></span><br><span class="line">    <span class="comment">/* KEY_RESERVED 不应传递给用户空间。 */</span></span><br><span class="line">__clear_bit(KEY_RESERVED, dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. */</span></span><br><span class="line">    <span class="comment">/* 确保未在 dev-&gt;evbit 中提及的位掩码是干净的。 */</span></span><br><span class="line">input_cleanse_bitmasks(dev);</span><br><span class="line"></span><br><span class="line">packet_size = input_estimate_events_per_packet(dev);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;hint_events_per_packet &lt; packet_size)</span><br><span class="line">dev-&gt;hint_events_per_packet = packet_size;</span><br><span class="line"></span><br><span class="line">dev-&gt;max_vals = dev-&gt;hint_events_per_packet + <span class="number">2</span>;</span><br><span class="line">dev-&gt;vals = kcalloc(dev-&gt;max_vals, <span class="keyword">sizeof</span>(*dev-&gt;vals), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;vals) &#123;</span><br><span class="line">error = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err_devres_free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If delay and period are pre-set by the driver, then autorepeating</span></span><br><span class="line"><span class="comment"> * is handled by the driver itself and we don&#x27;t do it in input.c.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果延迟和周期由驱动程序预设，</span></span><br><span class="line"><span class="comment">    * 则自动重复由驱动程序自己处理，我们不在 input.c 中处理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD])</span><br><span class="line">input_enable_softrepeat(dev, <span class="number">250</span>, <span class="number">33</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;getkeycode)</span><br><span class="line">dev-&gt;getkeycode = input_default_getkeycode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;setkeycode)</span><br><span class="line">dev-&gt;setkeycode = input_default_setkeycode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;poller)</span><br><span class="line">input_dev_poller_finalize(dev-&gt;poller);</span><br><span class="line"></span><br><span class="line">error = device_add(&amp;dev-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> err_free_vals;</span><br><span class="line"></span><br><span class="line">path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);</span><br><span class="line">pr_info(<span class="string">&quot;%s as %s\n&quot;</span>,</span><br><span class="line">dev-&gt;name ? dev-&gt;name : <span class="string">&quot;Unspecified device&quot;</span>,</span><br><span class="line">path ? path : <span class="string">&quot;N/A&quot;</span>);</span><br><span class="line">kfree(path);</span><br><span class="line"></span><br><span class="line">error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> err_device_del;</span><br><span class="line"></span><br><span class="line">list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line"><span class="comment">// 遍历输入处理程序链表，将输入设备与每个处理程序建立关联</span></span><br><span class="line">list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;input_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;devres_managed) &#123;</span><br><span class="line">dev_dbg(dev-&gt;dev.parent, <span class="string">&quot;%s: registering %s with devres.\n&quot;</span>,</span><br><span class="line">__func__, dev_name(&amp;dev-&gt;dev));</span><br><span class="line">devres_add(dev-&gt;dev.parent, devres);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_del:</span><br><span class="line">device_del(&amp;dev-&gt;dev);</span><br><span class="line">err_free_vals:</span><br><span class="line">kfree(dev-&gt;vals);</span><br><span class="line">dev-&gt;vals = <span class="literal">NULL</span>;</span><br><span class="line">err_devres_free:</span><br><span class="line">devres_free(devres);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_register_device);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>input_register_device</code> 函数用于注册输入设备（<code>input_dev</code>），将输入设备添加到输入子系统中</p><h3 id="数据结构关系图"><a href="#数据结构关系图" class="headerlink" title="数据结构关系图"></a>数据结构关系图</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195215642.png" alt="输入子系统数据结构图关系图"></p><h2 id="输入子系统源码"><a href="#输入子系统源码" class="headerlink" title="输入子系统源码"></a>输入子系统源码</h2><p>路径：<code>kernel/drivers/input</code></p><div class="table-container"><table><thead><tr><th>文件/目录</th><th>作用</th></tr></thead><tbody><tr><td><code>apm-power.c</code></td><td>提供与 Advanced Power Management (APM) 相关的输入设备接口。</td></tr><tr><td><code>evbug.c</code></td><td>提供用于调试的虚拟输入设备，可以模拟按键、鼠标移动等事件。</td></tr><tr><td><code>evdev.c</code></td><td>提供通用的输入事件层，将所有输入设备的事件转化为标准化的输入事件格式，并提供给上层用户空间程序使用。</td></tr><tr><td><code>ff-core.c</code></td><td>提供力反馈设备的支持，允许输入设备发送力反馈信息。</td></tr><tr><td><code>ff-memless.c</code></td><td>提供一种无需分配内存的力反馈设备支持，适用于资源受限的嵌入式系统。</td></tr><tr><td><code>gameport/</code></td><td>包含支持游戏控制器的驱动程序的目录。</td></tr><tr><td><code>input.c</code></td><td>提供输入子系统的初始化和事件处理等操作。</td></tr><tr><td><code>input-leds.c</code></td><td>提供 LED 指示灯设备的支持，允许控制 LED 指示灯的状态。</td></tr><tr><td><code>joydev.c</code></td><td>提供支持游戏杆的驱动程序，处理游戏杆设备的输入事件。</td></tr><tr><td><code>keyboard/</code></td><td>包含支持键盘的驱动程序的目录。</td></tr><tr><td><code>misc/</code></td><td>包含其他类型输入设备的驱动程序的目录，如红外线遥控器、输入音频等。</td></tr><tr><td><code>remotectl/</code></td><td>提供支持远程控制的驱动程序，处理通过遥控器发送的输入事件。</td></tr><tr><td><code>serio/</code></td><td>提供支持通过串行端口接入的输入设备的驱动程序，处理串行输入设备的通信和处理。</td></tr><tr><td><code>sensors/</code></td><td>包含与传感器相关的驱动程序的目录，用于与各种传感器设备通信和处理。</td></tr><tr><td><code>sparse-keymap.c</code></td><td>提供稀疏键映射的支持，允许按任意键码分配键位，适用于具有非标准键盘布局或特殊功能键的设备。</td></tr><tr><td><code>tablet/</code></td><td>提供支持绘图板和其他类型图形输入设备的驱动程序，处理绘图板设备的输入事件。</td></tr><tr><td><code>touchscreen/</code></td><td>提供支持触摸屏的驱动程序，处理触摸屏设备的输入事件。</td></tr></tbody></table></div><p>在menuconfig中：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Device</span> <span class="type">Drivers</span> <span class="comment">---&gt;</span></span><br><span class="line"><span class="type">Input</span> device sup<span class="keyword">port</span> <span class="comment">---&gt;</span></span><br></pre></td></tr></table></figure><p>如下：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-*- <span class="type">Generic</span> input layer (needed for keyboard, mouse, ...)//input 核心层</span><br><span class="line">│ │   &lt;*&gt;   <span class="type">Export</span> input device <span class="type">LEDs</span> <span class="keyword">in</span> sysfs</span><br><span class="line">│ │   &lt;*&gt;   <span class="type">Support</span> for memoryless force-feedback devices</span><br><span class="line">│ │   -*-   <span class="type">Polled</span> input device skeleton</span><br><span class="line">│ │   &lt; &gt;   <span class="type">Sparse</span> keymap sup<span class="keyword">port</span> library</span><br><span class="line">│ │   -*-   <span class="type">Matrix</span> keymap sup<span class="keyword">port</span> library</span><br><span class="line">│ │</span><br><span class="line">*** <span class="type">Userland</span> interfaces ***</span><br><span class="line">│ │  &lt; &gt;     <span class="type">Mouse</span> interface</span><br><span class="line">│ │  &lt; &gt;     <span class="type">Joystick</span> interface</span><br><span class="line">│ │  &lt;*&gt;     <span class="type">Event</span> interface</span><br><span class="line">│ │  &lt; &gt;     <span class="type">Event</span> debugging</span><br><span class="line">│ │</span><br><span class="line">*** <span class="type">Input</span> <span class="type">Device</span> <span class="type">Drivers</span> ***</span><br><span class="line">│ │  [*]   <span class="type">Keyboards</span>  <span class="comment">---&gt;</span></span><br><span class="line">│ │  [*]   <span class="type">Mice</span>  <span class="comment">---&gt;</span></span><br><span class="line">│ │  [ ]   <span class="type">Joysticks</span>/<span class="type">Gamepads</span>  <span class="comment">----</span></span><br><span class="line">│ │  [ ]   <span class="type">Tablets</span>  <span class="comment">----</span></span><br><span class="line">│ │  [*]   <span class="type">Touchscreens</span>  <span class="comment">---&gt;</span></span><br><span class="line">│ │  &lt;*&gt;   rockchip remotectl  <span class="comment">---&gt;</span></span><br><span class="line">│ │</span><br><span class="line">*** handle all sensors ***</span><br><span class="line">│ │  &lt; &gt;     handle angle,accel,compass,gyroscope,lsensor psensor etc</span><br><span class="line">│ │  [*]   <span class="type">Miscellaneous</span> devices  <span class="comment">---&gt;</span></span><br><span class="line">│ │  &lt; &gt;     <span class="type">Synaptics</span> <span class="type">RMI4</span> bus sup<span class="keyword">port</span></span><br><span class="line">│ │</span><br><span class="line">│ │     <span class="type">Hardware</span> <span class="type">I</span>/<span class="type">O</span> ports  <span class="comment">---&gt;</span></span><br></pre></td></tr></table></figure><p>如果想要对内核裁剪和配置，只需要勾选和取消即可。</p><h2 id="编写最简单的设备驱动层代码"><a href="#编写最简单的设备驱动层代码" class="headerlink" title="编写最简单的设备驱动层代码"></a>编写最简单的设备驱动层代码</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>步骤一：<strong>创建输入设备结构体变量</strong> 在设备驱动的开发中，首先需要创建一个输入设备的结 构 体 变 量 ， 该 结 构 体 变 量 将 用 于 表 示 和 管 理 设 备 的 属 性 和 状 态 。 可 以 使 用<code>input_allocate_device</code> 函数来分配输入设备结构体的内存。</li><li>步骤二：<strong>初始化输入设备结构体变量</strong> 在创建输入设备结构体变量后，需要对其进行初始化。这包括设置设备的名称、支持的事件类型、事件处理函数等。可以使用结构体提供的成员变量和函数来完成初始化过程。</li><li>步骤三：<strong>注册输入设备结构体变量</strong> 在初始化输入设备结构体变量后，需要将其注册到系统中，以便系统能够正确地识别和使用该设备。可以使用 input_register_device 函数来注册输入设备结构体变量。在注册过程中，系统将完成设备的匹配和初始化工作。</li><li>步骤四：<strong>上报事件</strong> 一旦设备注册成功，就可以通过输入设备结构体变量上报事件。这可以通过调用输入设备结构体提供的函数来完成，例如 input_event 函数。根据设备类型和事件类型，可以生成相应的输入事件，并通过调用该函数将事件发送给系统。</li><li>步骤五：<strong>注销和释放输入设备结构体变量</strong> 当设备不再需要使用时，应该进行注销和释放操作，以确保资源的正确释放。可以使用 <code>input_unregister_device</code> 函数来注销输入设备结构体变量，并使用 <code>input_free_device</code> 函数来释放相关资源和内存。</li></ol><h3 id="input-allocate-device"><a href="#input-allocate-device" class="headerlink" title="input_allocate_device()"></a>input_allocate_device()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/input.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_allocate_device - allocate memory for new input device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns prepared struct input_dev or %NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> Use input_free_device() to free devices that have not been</span></span><br><span class="line"><span class="comment"> * registered; input_unregister_device() should be used for already</span></span><br><span class="line"><span class="comment"> * registered devices.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> input_dev *<span class="title function_">input_allocate_device</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">atomic_t</span> input_no = ATOMIC_INIT(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line"><span class="comment">// 分配输入设备结构体的内存</span></span><br><span class="line">dev = kzalloc(<span class="keyword">sizeof</span>(*dev), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (dev) &#123;</span><br><span class="line">        <span class="comment">// 设置设备类型和设备类</span></span><br><span class="line">dev-&gt;dev.type = &amp;input_dev_type;</span><br><span class="line">dev-&gt;dev.class = &amp;input_class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化设备</span></span><br><span class="line">device_initialize(&amp;dev-&gt;dev);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化互斥锁和事件自旋锁</span></span><br><span class="line">mutex_init(&amp;dev-&gt;mutex);</span><br><span class="line">spin_lock_init(&amp;dev-&gt;event_lock);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化定时器</span></span><br><span class="line">timer_setup(&amp;dev-&gt;timer, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化链表头</span></span><br><span class="line">INIT_LIST_HEAD(&amp;dev-&gt;h_list);</span><br><span class="line">INIT_LIST_HEAD(&amp;dev-&gt;node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置设备名称，使用原子变量递增来保证唯一性</span></span><br><span class="line">dev_set_name(&amp;dev-&gt;dev, <span class="string">&quot;input%lu&quot;</span>,</span><br><span class="line">     (<span class="type">unsigned</span> <span class="type">long</span>)atomic_inc_return(&amp;input_no));</span><br><span class="line"><span class="comment">// 增加模块引用计数</span></span><br><span class="line">__module_get(THIS_MODULE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_allocate_device);</span><br></pre></td></tr></table></figure><h3 id="初始化input-dev结构体"><a href="#初始化input-dev结构体" class="headerlink" title="初始化input_dev结构体"></a>初始化input_dev结构体</h3><p>在使用 <code>input_allocate_device</code> 函数创建了一个 <code>input_dev</code> 结构体之后，接下来就要初始化<code>input_dev</code> 结构体内容了，在该步骤中又有两个内容，分别为<strong>设置事件类型</strong>和<strong>设置具体类型</strong>。</p><h4 id="设置事件类型"><a href="#设置事件类型" class="headerlink" title="设置事件类型"></a>设置事件类型</h4><p>在头文件 <code>include/uapi/linux/input-event-codes.h</code> 中，Linux 内核已经为我们定义了一些输入事件类型，它们的含义如下：</p><ul><li>EV_SYN (0x00): 用于<strong>同步事件</strong>，表示一组输入事件的结束。</li><li>EV_KEY (0x01): 用于<strong>按键事件</strong>，表示按下、释放或重复一个键。</li><li>EV_REL (0x02): 用于<strong>相对位移事件</strong>，表示设备的相对位置变化，例如鼠标的移动。</li><li>EV_ABS (0x03): 用于<strong>绝对位移事件</strong>，表示设备的绝对位置变化，例如触摸屏的坐标。</li><li>EV_MSC (0x04): 用于<strong>杂项事件</strong>，包含一些特殊目的的事件类型，例如设备状态变化等。</li><li>EV_SW (0x05): 用于<strong>开关事件</strong>，表示开关的状态变化，例如电源按钮、开合盖等。</li><li>EV_LED (0x11): 用于 <strong>LED 事件</strong>，表示 LED 灯的状态变化。</li><li>EV_SND (0x12): 用于<strong>声音事件</strong>，表示声音的播放相关事件。</li><li>EV_REP (0x14): 用于<strong>重复事件</strong>，表示键盘重复发送事件。</li><li>EV_FF (0x15): 用于<strong>力反馈事件</strong>，表示力反馈设备的输出事件。</li><li>EV_PWR (0x16): 用于<strong>电源事件</strong>，表示电源状态变化。</li><li>EV_FF_STATUS (0x17): 用于<strong>力反馈状态事件</strong>，表示力反馈设备的状态变化。</li><li>EV_MAX (0x1f): 输入事件类型的最大值。</li><li>EV_CNT: 输入事件类型的数量。</li></ul><p>而在 <code>input_dev</code> 结构体中定义了一系列的位图，在输入子系统中用于表示输入设备的能力和支持的功能，具体定义如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; <span class="comment">// 设备的属性位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> evbit[BITS_TO_LONGS(EV_CNT)]; <span class="comment">// 设备支持的事件类型位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> keybit[BITS_TO_LONGS(KEY_CNT)]; <span class="comment">// 设备支持的按键位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> relbit[BITS_TO_LONGS(REL_CNT)]; <span class="comment">// 设备支持的相对坐标位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> absbit[BITS_TO_LONGS(ABS_CNT)]; <span class="comment">// 设备支持的绝对坐标位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)]; <span class="comment">// 设备支持的杂项事件位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ledbit[BITS_TO_LONGS(LED_CNT)]; <span class="comment">// 设备支持的 LED 位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sndbit[BITS_TO_LONGS(SND_CNT)]; <span class="comment">// 设备支持的声音位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ffbit[BITS_TO_LONGS(FF_CNT)]; <span class="comment">// 设备支持的力反馈位图</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> swbit[BITS_TO_LONGS(SW_CNT)]; <span class="comment">// 设备支持的开关位图</span></span><br></pre></td></tr></table></figure><ul><li>evbit（事件类型位图）是一个长度为 EV_CNT 的数组，每个元素对应一个事件类型。通过设置相应的位，可以指示设备支持的事件类型，如按键事件、相对位移事件、绝对位移事件、杂项事件等。</li><li>keybit（按键类型位图）表示输入设备支持的按键类型，通常与 EV_KEY 事件类型相关。通过设置相应的位，可以指示设备支持的按键。</li><li>relbit（相对位移类型位图）表示输入设备支持的相对位移类型，通常与 EV_REL 事件类型相关。通过设置相应的位，可以指示设备支持的相对位移，例如鼠标的移动。</li><li>absbit（绝对位移类型位图）表示输入设备支持的绝对位移类型，通常与 EV_ABS 事件类型相关。通过设置相应的位，可以指示设备支持的绝对位移，例如触摸屏的坐标。</li><li>mscbit（杂项类型位图）表示输入设备支持的杂项类型，通常与 EV_MSC 事件类型相关。通过设置相应的位，可以指示设备支持的杂项事件，例如设备状态变化等。</li><li>ledbit（LED 类型位图）表示输入设备支持的 LED 类型，通常与 EV_LED 事件类型相关。通过设置相应的位，可以指示设备支持的 LED 灯控制。</li><li>sndbit（声音类型位图）表示输入设备支持的声音类型，通常与 EV_SND 事件类型相关。通过设置相应的位，可以指示设备支持的声音事件。</li><li>ffbit（力反馈类型位图）表示输入设备支持的力反馈类型，通常与 EV_FF 事件类型相关。通过设置相应的位，可以指示设备支持的力反馈事件。</li><li>swbit（开关类型位图）表示输入设备支持的开关类型，通常与 EV_SW 事件类型相关。通过设置相应的位，可以指示设备支持的开关状态变化。</li></ul><p><code>__set_bit</code> 是一个位操作函数，用于设置一个位图中的特定位，例如可以通过下面的代码将输入设备设置为支持按键事件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__set_bit(EV_KEY,myinput_dev-&gt;evbit)</span><br></pre></td></tr></table></figure><h4 id="设置具体类型"><a href="#设置具体类型" class="headerlink" title="设置具体类型"></a>设置具体类型</h4><p>设 置 完 事 件 类 型 之 后 ， 还 需 要 设 置 具 体 类 型 ， 宏 定 义 仍 旧 定 义 在 头 文 件<code>include/uapi/linux/input-event-codes.h</code> 中，部分内容如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_RESERVED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_ESC 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_1 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_2 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_3 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_4 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_5 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_6 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_7 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_8 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_9 10</span></span><br></pre></td></tr></table></figure><p>上一小节只是将输入设备设置为了按键事件，但具体要表示什么呢，是按键 1 还是按键 2亦或者其他按键，都无法确定，所以仍旧需要使用<code>__set_bit</code> 函数来确定具体类型，例如使用以下程序将该输入设备设置为按键 1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__set_bit(KEY_1,myinput_dev-&gt;keybit)</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">myinput_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">myinput_dev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配输入设备结构体</span></span><br><span class="line">    myinput_dev = input_allocate_device();</span><br><span class="line">    <span class="keyword">if</span> (myinput_dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;input_allocate_device error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置输入设备的名称</span></span><br><span class="line">    myinput_dev-&gt;name = <span class="string">&quot;myinput_dev&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置输入设备支持的事件类型</span></span><br><span class="line">    __set_bit(EV_KEY, myinput_dev-&gt;evbit);    <span class="comment">// 设置支持按键事件</span></span><br><span class="line">    __set_bit(KEY_1, myinput_dev-&gt;keybit);    <span class="comment">// 设置支持按键1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册输入设备</span></span><br><span class="line">    ret = input_register_device(myinput_dev);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;input_register_device error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    <span class="comment">// 注册失败，释放输入设备结构体</span></span><br><span class="line">    input_free_device(myinput_dev);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">myinput_dev_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销输入设备</span></span><br><span class="line">    input_unregister_device(myinput_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(myinput_dev_init);</span><br><span class="line">module_exit(myinput_dev_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意这里没有上报事件。</p><h2 id="分析匹配规则"><a href="#分析匹配规则" class="headerlink" title="分析匹配规则"></a>分析匹配规则</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">input_register_device</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> =</span> <span class="literal">NULL</span>;<span class="comment">// 输入设备资源结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span><span class="comment">// 输入处理程序指针</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> packet_size;<span class="comment">// 数据包大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *path;<span class="comment">// 设备路径字符串指针</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (test_bit(EV_ABS, dev-&gt;evbit) &amp;&amp; !dev-&gt;absinfo) &#123;</span><br><span class="line">dev_err(&amp;dev-&gt;dev,</span><br><span class="line"><span class="string">&quot;Absolute device without dev-&gt;absinfo, refusing to register\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;devres_managed) &#123;<span class="comment">// 如果设备资源是由管理的，则分配设备资源结构体</span></span><br><span class="line">devres = devres_alloc(devm_input_device_unregister,</span><br><span class="line">      <span class="keyword">sizeof</span>(*devres), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!devres)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">devres-&gt;input = dev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Every input device generates EV_SYN/SYN_REPORT events. */</span></span><br><span class="line">    <span class="comment">/* 每个输入设备都会产生 EV_SYN/SYN_REPORT 事件。 */</span></span><br><span class="line">__set_bit(EV_SYN, dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* KEY_RESERVED is not supposed to be transmitted to userspace. */</span></span><br><span class="line">    <span class="comment">/* KEY_RESERVED 不应传递给用户空间。 */</span></span><br><span class="line">__clear_bit(KEY_RESERVED, dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. */</span></span><br><span class="line">    <span class="comment">/* 确保未在 dev-&gt;evbit 中提及的位掩码是干净的。 */</span></span><br><span class="line">input_cleanse_bitmasks(dev);</span><br><span class="line"></span><br><span class="line">packet_size = input_estimate_events_per_packet(dev);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;hint_events_per_packet &lt; packet_size)</span><br><span class="line">dev-&gt;hint_events_per_packet = packet_size;</span><br><span class="line"></span><br><span class="line">dev-&gt;max_vals = dev-&gt;hint_events_per_packet + <span class="number">2</span>;</span><br><span class="line">dev-&gt;vals = kcalloc(dev-&gt;max_vals, <span class="keyword">sizeof</span>(*dev-&gt;vals), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;vals) &#123;</span><br><span class="line">error = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err_devres_free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If delay and period are pre-set by the driver, then autorepeating</span></span><br><span class="line"><span class="comment"> * is handled by the driver itself and we don&#x27;t do it in input.c.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果延迟和周期由驱动程序预设，</span></span><br><span class="line"><span class="comment">    * 则自动重复由驱动程序自己处理，我们不在 input.c 中处理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD])</span><br><span class="line">input_enable_softrepeat(dev, <span class="number">250</span>, <span class="number">33</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;getkeycode)</span><br><span class="line">dev-&gt;getkeycode = input_default_getkeycode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;setkeycode)</span><br><span class="line">dev-&gt;setkeycode = input_default_setkeycode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;poller)</span><br><span class="line">input_dev_poller_finalize(dev-&gt;poller);</span><br><span class="line"></span><br><span class="line">error = device_add(&amp;dev-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> err_free_vals;</span><br><span class="line"></span><br><span class="line">path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);</span><br><span class="line">pr_info(<span class="string">&quot;%s as %s\n&quot;</span>,</span><br><span class="line">dev-&gt;name ? dev-&gt;name : <span class="string">&quot;Unspecified device&quot;</span>,</span><br><span class="line">path ? path : <span class="string">&quot;N/A&quot;</span>);</span><br><span class="line">kfree(path);</span><br><span class="line"></span><br><span class="line">error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> err_device_del;</span><br><span class="line"></span><br><span class="line">list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line"><span class="comment">// 遍历输入处理程序链表，将输入设备与每个处理程序建立关联</span></span><br><span class="line">list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;input_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;devres_managed) &#123;</span><br><span class="line">dev_dbg(dev-&gt;dev.parent, <span class="string">&quot;%s: registering %s with devres.\n&quot;</span>,</span><br><span class="line">__func__, dev_name(&amp;dev-&gt;dev));</span><br><span class="line">devres_add(dev-&gt;dev.parent, devres);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_del:</span><br><span class="line">device_del(&amp;dev-&gt;dev);</span><br><span class="line">err_free_vals:</span><br><span class="line">kfree(dev-&gt;vals);</span><br><span class="line">dev-&gt;vals = <span class="literal">NULL</span>;</span><br><span class="line">err_devres_free:</span><br><span class="line">devres_free(devres);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_register_device);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重点是<code>input_attach_handler()</code>函数</p><h3 id="input-attach-handler-1"><a href="#input-attach-handler-1" class="headerlink" title="input_attach_handler()"></a>input_attach_handler()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/input.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">input_attach_handler</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="keyword">struct</span> input_handler *handler)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 通过输入设备和处理程序的匹配函数来确定是否适用于该设备</span></span><br><span class="line">    <span class="comment">// 这个函数将在处理程序的输入设备 ID 表中查找与给定的输入设备匹配的 ID，</span></span><br><span class="line">    <span class="comment">// 并返回匹配的 ID。如果没有找到匹配的 ID，则返回 NULL</span></span><br><span class="line">id = input_match_device(handler, dev);</span><br><span class="line"><span class="keyword">if</span> (!id)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 调用处理程序的连接函数来建立设备和处理程序之间的连接</span></span><br><span class="line">error = handler-&gt;connect(handler, dev, id);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (error &amp;&amp; error != -ENODEV)</span><br><span class="line">pr_err(<span class="string">&quot;failed to attach handler %s to device %s, error: %d\n&quot;</span>,</span><br><span class="line">       handler-&gt;name, kobject_name(&amp;dev-&gt;dev.kobj), error);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="input-match-device-1"><a href="#input-match-device-1" class="headerlink" title="input_match_device()"></a>input_match_device()</h3><p>这个函数在输入子系统中的作用是在给定的输入事件处理程序（<code>input_handler）</code>中查找与指定输入设备匹配的输入设备 ID（input device ID）。</p><p>处理程序的输入设备 ID 表是一个以 <code>struct input_device_id</code> 结构为元素的数组，每个元素表示一个可能的输入设备 ID</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/input.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> input_device_id *<span class="title function_">input_match_device</span><span class="params">(<span class="keyword">struct</span> input_handler *handler,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> input_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line"><span class="comment">// 遍历处理程序的输入设备 ID 表，直到找到匹配的 ID 或遍历完所有 ID 为止</span></span><br><span class="line"><span class="keyword">for</span> (id = handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123;</span><br><span class="line"><span class="keyword">if</span> (input_match_device_id(dev, id) &amp;&amp; <span class="comment">// 使用输入设备 ID 匹配函数判断给定的输入设备是否与当前 ID 匹配</span></span><br><span class="line">    (!handler-&gt;match || handler-&gt;match(handler, dev))) &#123;<span class="comment">// 如果输入设备与 ID 匹配，并且处理程序的匹配函数返回 true（或者没有匹配函数），则返回该 ID</span></span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看下evdev的<code>input_handler</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> <span class="title">evdev_ids</span>[] =</span> &#123;</span><br><span class="line">&#123; .driver_info = <span class="number">1</span> &#125;,<span class="comment">/* Matches all devices */</span></span><br><span class="line">&#123; &#125;,<span class="comment">/* Terminating zero entry */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MODULE_DEVICE_TABLE(input, evdev_ids);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> <span class="title">evdev_handler</span> =</span> &#123;</span><br><span class="line">.event= evdev_event,</span><br><span class="line">.events= evdev_events,</span><br><span class="line">.connect= evdev_connect,</span><br><span class="line">.disconnect= evdev_disconnect,</span><br><span class="line">.legacy_minors= <span class="literal">true</span>,</span><br><span class="line">.minor= EVDEV_MINOR_BASE,</span><br><span class="line">.name= <span class="string">&quot;evdev&quot;</span>,</span><br><span class="line">.id_table= evdev_ids,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于 <code>driver_info</code> 为 1，所以<code>input_match_device()</code>中的 for 循环的条件就会一直成立，在每一次的循环中都会判定 id 是不是匹配，即匹配所有的<code>input_dev</code>。</p><h3 id="input-match-device-id-1"><a href="#input-match-device-id-1" class="headerlink" title="input_match_device_id()"></a>input_match_device_id()</h3><p><code>input_match_device_id(dev, id)</code>调用输入设备 ID 匹配函数来判断给定的输入设备是否与当前 ID 匹配。匹配函数的作用是比较输入设备的属性与 ID 中指定的属性是否一致，例如厂商 ID、产品 ID 等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">input_match_device_id</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="keyword">struct</span> input_device_id *id)</span><span class="comment">// id = handler-&gt;id_table数组中的一项</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS)</span><br><span class="line"><span class="keyword">if</span> (id-&gt;bustype != dev-&gt;id.bustype)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VENDOR)</span><br><span class="line"><span class="keyword">if</span> (id-&gt;vendor != dev-&gt;id.vendor)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_PRODUCT)</span><br><span class="line"><span class="keyword">if</span> (id-&gt;product != dev-&gt;id.product)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VERSION)</span><br><span class="line"><span class="keyword">if</span> (id-&gt;version != dev-&gt;id.version)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bitmap_subset(id-&gt;evbit, dev-&gt;evbit, EV_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;keybit, dev-&gt;keybit, KEY_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;relbit, dev-&gt;relbit, REL_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;absbit, dev-&gt;absbit, ABS_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;mscbit, dev-&gt;mscbit, MSC_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;ledbit, dev-&gt;ledbit, LED_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;sndbit, dev-&gt;sndbit, SND_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;ffbit, dev-&gt;ffbit, FF_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;swbit, dev-&gt;swbit, SW_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;propbit, dev-&gt;propbit, INPUT_PROP_MAX)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_match_device_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而我们上面写的最简单的输入设备驱动层代码并没有由于在编写的最简单的设备驱动层代码中并未定义 id 的 flags 参数，所以第 5、10、15、20 中的判断都不成立。</p><blockquote><p><code>bitmap_subset</code>是一个内联函数，用于判断两个位图是否具有子集关系，即<strong>判断第一个位图是否是第二个位图的子集</strong>。</p></blockquote><p>id 中并未定义 evbit、keybit、relbit 等，所以 25-34 行的 if 判断也不成立，最终该函数会返回 true，当然这仅仅只是对 evdev.c 这一通用事件处理代码进行的分析，返回 true， 之后然后回到 <code>input_attach_handler</code> 函数，然后会调用 <code>handler-&gt;connect</code> 建立与输入设备的连接。</p><h2 id="多对多匹配分析"><a href="#多对多匹配分析" class="headerlink" title="多对多匹配分析"></a>多对多匹配分析</h2><p><code>drivers/input/joydev.c</code> 文件的 <code>input_handler</code> 结构体内容如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> <span class="title">joydev_ids</span>[] =</span> &#123;</span><br><span class="line">&#123;<span class="comment">// 第一个标识符，匹配 X 轴（ABS_X）的绝对事件</span></span><br><span class="line">.flags = INPUT_DEVICE_ID_MATCH_EVBIT |</span><br><span class="line">INPUT_DEVICE_ID_MATCH_ABSBIT,</span><br><span class="line">.evbit = &#123; BIT_MASK(EV_ABS) &#125;,<span class="comment">// 匹配的事件类型是 EV_ABS（绝对事件）</span></span><br><span class="line">.absbit = &#123; BIT_MASK(ABS_X) &#125;,<span class="comment">// 匹配的绝对事件类型是 ABS_X（X 轴</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;<span class="comment">// 第二个标识符，匹配 Z 轴（ABS_Z）的绝对事件</span></span><br><span class="line">.flags = INPUT_DEVICE_ID_MATCH_EVBIT |</span><br><span class="line">INPUT_DEVICE_ID_MATCH_ABSBIT,</span><br><span class="line">.evbit = &#123; BIT_MASK(EV_ABS) &#125;,<span class="comment">// 匹配的事件类型是 EV_ABS（绝对事件）</span></span><br><span class="line">.absbit = &#123; BIT_MASK(ABS_Z) &#125;,<span class="comment">// 匹配的绝对事件类型是 ABS_Z（Z 轴）</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;<span class="comment">// 第三个标识符，匹配滚轮（ABS_WHEEL）的绝对事件</span></span><br><span class="line">.flags = INPUT_DEVICE_ID_MATCH_EVBIT |</span><br><span class="line">INPUT_DEVICE_ID_MATCH_ABSBIT,</span><br><span class="line">.evbit = &#123; BIT_MASK(EV_ABS) &#125;,<span class="comment">// 匹配的事件类型是 EV_ABS（绝对事件</span></span><br><span class="line">.absbit = &#123; BIT_MASK(ABS_WHEEL) &#125;,<span class="comment">// 匹配的绝对事件类型是 ABS_WHEEL（滚轮）</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;<span class="comment">// 第四个标识符，匹配油门（ABS_THROTTLE）的绝对事件</span></span><br><span class="line">.flags = INPUT_DEVICE_ID_MATCH_EVBIT |</span><br><span class="line">INPUT_DEVICE_ID_MATCH_ABSBIT,</span><br><span class="line">.evbit = &#123; BIT_MASK(EV_ABS) &#125;,<span class="comment">// 匹配的事件类型是 EV_ABS（绝对事件）</span></span><br><span class="line">.absbit = &#123; BIT_MASK(ABS_THROTTLE) &#125;,<span class="comment">// 匹配的绝对事件类型是 ABS_THROTTLE（油门）</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;<span class="comment">// 第五个标识符，匹配游戏杆（BTN_JOYSTICK）的按键事件</span></span><br><span class="line">.flags = INPUT_DEVICE_ID_MATCH_EVBIT |</span><br><span class="line">INPUT_DEVICE_ID_MATCH_KEYBIT,</span><br><span class="line">.evbit = &#123; BIT_MASK(EV_KEY) &#125;,<span class="comment">// 匹配的事件类型是 EV_KEY（按键事件）</span></span><br><span class="line">.keybit = &#123;[BIT_WORD(BTN_JOYSTICK)] = BIT_MASK(BTN_JOYSTICK) &#125;,<span class="comment">// 匹配的按键类型是BTN_JOYSTICK（游戏杆）</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;<span class="comment">// 第六个标识符，匹配游戏手柄（BTN_GAMEPAD）的按键事件</span></span><br><span class="line">.flags = INPUT_DEVICE_ID_MATCH_EVBIT |</span><br><span class="line">INPUT_DEVICE_ID_MATCH_KEYBIT,</span><br><span class="line">.evbit = &#123; BIT_MASK(EV_KEY) &#125;,<span class="comment">// 匹配的事件类型是 EV_KEY（按键事件）</span></span><br><span class="line">.keybit = &#123; [BIT_WORD(BTN_GAMEPAD)] = BIT_MASK(BTN_GAMEPAD) &#125;,<span class="comment">// 匹配的按键类型是BTN_GAMEPAD（游戏手柄）</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;<span class="comment">// 第七个标识符，匹配快乐键（BTN_TRIGGER_HAPPY）的按键事件</span></span><br><span class="line">.flags = INPUT_DEVICE_ID_MATCH_EVBIT |</span><br><span class="line">INPUT_DEVICE_ID_MATCH_KEYBIT,</span><br><span class="line">.evbit = &#123; BIT_MASK(EV_KEY) &#125;,<span class="comment">// 匹配的事件类型是 EV_KEY（按键事件</span></span><br><span class="line">.keybit = &#123; [BIT_WORD(BTN_TRIGGER_HAPPY)] = BIT_MASK(BTN_TRIGGER_HAPPY) &#125;,<span class="comment">// 匹配的按键类型是 BTN_TRIGGER_HAPPY（快乐键）</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123; &#125;<span class="comment">/* Terminating entry */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MODULE_DEVICE_TABLE(input, joydev_ids);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> <span class="title">joydev_handler</span> =</span> &#123;</span><br><span class="line">.event= joydev_event,</span><br><span class="line">.match= joydev_match,</span><br><span class="line">.connect= joydev_connect,</span><br><span class="line">.disconnect= joydev_disconnect,</span><br><span class="line">.legacy_minors= <span class="literal">true</span>,</span><br><span class="line">.minor= JOYDEV_MINOR_BASE,</span><br><span class="line">.name= <span class="string">&quot;joydev&quot;</span>,</span><br><span class="line">.id_table= joydev_ids,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">joydev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> input_register_handler(&amp;joydev_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">joydev_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">input_unregister_handler(&amp;joydev_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(joydev_init);</span><br><span class="line">module_exit(joydev_exit);</span><br></pre></td></tr></table></figure><p>与上面的通用设备驱动层 <code>evdev.c</code> 的 <code>evdev_handler</code> 结构体不同的是，<code>joydev_handler</code>结构体中有着对应的匹配函数，也就是说当设备驱动层与事件处理层进行匹配的时候，需要joydev_ids 结构体数组和相应的匹配函数共同决定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/evdev.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> <span class="title">evdev_ids</span>[] =</span> &#123;</span><br><span class="line">&#123; .driver_info = <span class="number">1</span> &#125;,<span class="comment">/* Matches all devices */</span></span><br><span class="line">&#123; &#125;,<span class="comment">/* Terminating zero entry */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体 <code>input_device_id</code> 的作用是<strong>描述输入设备的特征</strong>，以便内核能够识别和匹配正确的驱动程序。在通用设备驱动层 evdev.c 中的 evdev_ids 结构体数组设置的是 <code>driver_info</code> 表示匹配全部设备，而 joydev.c 中的 <code>joydev_ids</code> 结构体数组包含以下字段：</p><ul><li>flags ： 标 识 符 的 标 志 位 ， 用 于 指 定 匹 配 方 式 。 在 这 里 ， 使 用 flags 字 段 的<code>INPUT_DEVICE_ID_MATCH_EVBIT</code> 和 <code>INPUT_DEVICE_ID_MATCH_ABSBIT</code> 标志表示匹配事件类型和绝对事件类型。</li><li>evbit：事件类型的位掩码，用于指定要匹配的事件类型。在这里，evbit 字段的位掩码表示匹配的事件类型是 EV_ABS（绝对事件）或 EV_KEY（按键事件）。</li><li>absbit：绝对事件类型的位掩码，用于指定要匹配的绝对事件类型。在这里，absbit字段的位掩码表示匹配的绝对事件类型是 ABS_X（X 轴）、ABS_Z（Z 轴）、ABS_WHEEL（滚轮）或 ABS_THROTTLE（油门）。</li><li>keybit：按键类型的位掩码，用于指定要匹配的按键类型。在这里，keybit 字段的位掩码表示匹配的按键类型是 BTN_JOYSTICK（游戏杆）、BTN_GAMEPAD（游戏手柄）或BTN_TRIGGER_HAPPY（快乐键）。</li></ul><p>对于我们之前写的最简单的input设备驱动层代码：</p><p><code>input_match_device()</code>中的 for 循环中由于每个 <code>joydev_ids</code> 结构体数组中虽然<code>driver_info</code>没有设置，但是 flags 参数都存在且值不为零，所以 for 循环的条件是成立的，在 for 循环中会调用 <code>input_match_device_id</code> 函数判定给定的输入设备是否与当前 ID 匹配。</p><p>由于<code>id_table</code>中没有设置bustype, vendor, product, version, 因此检查设备的总线类型，厂商ID，产品ID，设备的版本号是否匹配都能匹配成功。但是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!bitmap_subset(id-&gt;evbit, dev-&gt;evbit, EV_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;keybit, dev-&gt;keybit, KEY_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;relbit, dev-&gt;relbit, REL_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;absbit, dev-&gt;absbit, ABS_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;mscbit, dev-&gt;mscbit, MSC_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;ledbit, dev-&gt;ledbit, LED_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;sndbit, dev-&gt;sndbit, SND_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;ffbit, dev-&gt;ffbit, FF_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;swbit, dev-&gt;swbit, SW_MAX) ||</span><br><span class="line">    !bitmap_subset(id-&gt;propbit, dev-&gt;propbit, INPUT_PROP_MAX)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bitmap_subset</code> 用于<strong>判断第一个位图是否是第二个位图的子集</strong>。在编写的最简单的设备驱动层代码中的设置如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__set_bit(EV_KEY, myinput_dev-&gt;evbit); <span class="comment">// 设置支持按键事件</span></span><br><span class="line">__set_bit(KEY_1, myinput_dev-&gt;keybit); <span class="comment">// 设置支持按键 1</span></span><br></pre></td></tr></table></figure><p>判断<code>input_handler</code>的事件位图是否为<code>input_dev</code>设置的事件位图的子集，这是要求事件处理层要求的事件处理设备驱动层必须都要支持。</p><p>可以加一个打印：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!bitmap_subset(id-&gt;evbit, dev-&gt;evbit, EV_MAX) ||</span><br><span class="line">!bitmap_subset(id-&gt;keybit, dev-&gt;keybit, KEY_MAX) ||</span><br><span class="line">!bitmap_subset(id-&gt;relbit, dev-&gt;relbit, REL_MAX) ||</span><br><span class="line">!bitmap_subset(id-&gt;absbit, dev-&gt;absbit, ABS_MAX) ||</span><br><span class="line">!bitmap_subset(id-&gt;mscbit, dev-&gt;mscbit, MSC_MAX) ||</span><br><span class="line">!bitmap_subset(id-&gt;ledbit, dev-&gt;ledbit, LED_MAX) ||</span><br><span class="line">!bitmap_subset(id-&gt;sndbit, dev-&gt;sndbit, SND_MAX) ||</span><br><span class="line">!bitmap_subset(id-&gt;ffbit, dev-&gt;ffbit, FF_MAX) ||</span><br><span class="line">!bitmap_subset(id-&gt;swbit, dev-&gt;swbit, SW_MAX) ||</span><br><span class="line">!bitmap_subset(id-&gt;propbit, dev-&gt;propbit, INPUT_PROP_MAX)) &#123;</span><br><span class="line">printk(<span class="string">&quot;input dev is error %s\n&quot;</span>, dev-&gt;name);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;input dev is ok %s\n&quot;</span>, dev-&gt;name);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195222786.png" alt="多对多匹配测试"></p><p>总结：</p><p>在输入子系统中，输入设备和输入处理器之间的关系是多对多的。</p><p>这意味着<strong>一个输入设备可以与多个输入处理器关联，而一个输入处理器也可以处理多个输入设备的事件</strong>。</p><h2 id="完善设备驱动层代码"><a href="#完善设备驱动层代码" class="headerlink" title="完善设备驱动层代码"></a>完善设备驱动层代码</h2><h3 id="上报事件"><a href="#上报事件" class="headerlink" title="上报事件"></a>上报事件</h3><p><strong>上报事件是指在设备驱动层中，当输入设备产生事件时，将该事件通知给输入子系统</strong>。</p><p>在上报事件之前，首先要确定要上报的事件类型。事件类型可以是按键事件、相对位置事件、绝对位置事件等，取决于输入设备的特性和能力。</p><p>在 Linux 内核中，事件类型由预定义的常量表示，如 EV_KEY 表示按键事件，EV_REL 表示相对位置事件，EV_ABS 表示绝对位置事件等。<br>在前面编写的最简单的设备驱动层代码的第二个步骤中已经对事件类型和具体事件进行了确认。 </p><p>而在确定事件类型之后，就需要使用相应的上报函数将事件数据传递给输入子系统。常用的上报函数包括：</p><ul><li><code>input_report_key()</code>：上报按键事件，用于通知按键的按下和释放状态。</li><li><code>input_report_rel()</code>：上报相对位置事件，用于通知设备的相对移动量，如鼠标的移动。</li><li><code>input_report_abs()</code>：上报绝对位置事件，用于通知设备的绝对位置，如触摸屏的坐标。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195226891.png" alt="上报事件"></p><h3 id="上报函数"><a href="#上报函数" class="headerlink" title="上报函数"></a>上报函数</h3><h4 id="input-report-key"><a href="#input-report-key" class="headerlink" title="input_report_key()"></a>input_report_key()</h4><div class="table-container"><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td><strong>头文件</strong></td><td><code>&lt;linux/input.h&gt;</code></td></tr><tr><td><strong>函数原型</strong></td><td><code>void input_report_key(struct input_dev *dev, unsigned int code, int value)</code></td></tr><tr><td><strong>参数</strong></td><td>- <code>dev</code>：指向输入设备结构体 <code>input_dev</code> 的指针 - <code>code</code>：按键事件码（如 <code>KEY_A</code>, <code>BTN_TOUCH</code> 等） - <code>value</code>：按键状态（0 = 释放，非 0 = 按下）</td></tr><tr><td><strong>返回值</strong></td><td>无（<code>void</code>）</td></tr><tr><td><strong>作用</strong></td><td>上报一个 <strong>按键事件（EV_KEY）</strong>。用于键盘、按钮、触摸屏点击等场景。</td></tr></tbody></table></div><hr><h4 id="input-report-rel"><a href="#input-report-rel" class="headerlink" title="input_report_rel()"></a>input_report_rel()</h4><div class="table-container"><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td><strong>头文件</strong></td><td><code>&lt;linux/input.h&gt;</code></td></tr><tr><td><strong>函数原型</strong></td><td><code>void input_report_rel(struct input_dev *dev, unsigned int code, int value)</code></td></tr><tr><td><strong>参数</strong></td><td>- <code>dev</code>：指向 <code>input_dev</code> 的指针 - <code>code</code>：相对轴类型（如 <code>REL_X</code>, <code>REL_Y</code>, <code>REL_WHEEL</code>） - <code>value</code>：相对于上一次位置的偏移量（可正可负）</td></tr><tr><td><strong>返回值</strong></td><td>无（<code>void</code>）</td></tr><tr><td><strong>作用</strong></td><td>上报一个 <strong>相对坐标事件（EV_REL）</strong>。常用于鼠标、滚轮等设备。</td></tr></tbody></table></div><h4 id="input-report-abs"><a href="#input-report-abs" class="headerlink" title="input_report_abs()"></a>input_report_abs()</h4><div class="table-container"><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td><strong>头文件</strong></td><td><code>&lt;linux/input.h&gt;</code></td></tr><tr><td><strong>函数原型</strong></td><td><code>void input_report_abs(struct input_dev *dev, unsigned int code, int value)</code></td></tr><tr><td><strong>参数</strong></td><td>- <code>dev</code>：指向 <code>input_dev</code> 的指针 - <code>code</code>：绝对轴类型（如 <code>ABS_X</code>, <code>ABS_Y</code>, <code>ABS_MT_POSITION_X</code>） - <code>value</code>：当前的绝对坐标值</td></tr><tr><td><strong>返回值</strong></td><td>无（<code>void</code>）</td></tr><tr><td><strong>作用</strong></td><td>上报一个 <strong>绝对坐标事件（EV_ABS）</strong>。用于触摸屏、手写板、游戏手柄摇杆等设备。</td></tr></tbody></table></div><hr><h4 id="input-report-ff-status"><a href="#input-report-ff-status" class="headerlink" title="input_report_ff_status()"></a>input_report_ff_status()</h4><div class="table-container"><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td><strong>头文件</strong></td><td><code>&lt;linux/input.h&gt;</code></td></tr><tr><td><strong>函数原型</strong></td><td><code>void input_report_ff_status(struct input_dev *dev, unsigned int code, int value)</code></td></tr><tr><td><strong>参数</strong></td><td>- <code>dev</code>：指向 <code>input_dev</code> 的指针 - <code>code</code>：力反馈效果 ID（通常由用户空间分配） - <code>value</code>：力反馈状态（0 = 停止，非 0 = 正在播放）</td></tr><tr><td><strong>返回值</strong></td><td>无（<code>void</code>）</td></tr><tr><td><strong>作用</strong></td><td>上报 <strong>力反馈（Force Feedback）状态事件（EV_FF_STATUS）</strong>，用于通知用户空间某个力反馈效果的当前运行状态。</td></tr></tbody></table></div><blockquote><p>⚠️ 注：该函数较少使用，多数力反馈由内核主动控制，而非设备上报状态。</p></blockquote><hr><h4 id="input-report-switch"><a href="#input-report-switch" class="headerlink" title="input_report_switch()"></a>input_report_switch()</h4><div class="table-container"><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td><strong>头文件</strong></td><td><code>&lt;linux/input.h&gt;</code></td></tr><tr><td><strong>函数原型</strong></td><td><code>void input_report_switch(struct input_dev *dev, unsigned int code, int value)</code></td></tr><tr><td><strong>参数</strong></td><td>- <code>dev</code>：指向 <code>input_dev</code> 的指针 - <code>code</code>：开关类型（如 <code>SW_LID</code>, <code>SW_TABLET_MODE</code>） - <code>value</code>：开关状态（0 = 关闭/打开盖子，非 0 = 打开/合上盖子，具体含义依类型而定）</td></tr><tr><td><strong>返回值</strong></td><td>无（<code>void</code>）</td></tr><tr><td><strong>作用</strong></td><td>上报一个 <strong>开关状态事件（EV_SW）</strong>。常用于笔记本翻盖检测、平板模式切换等硬件开关。</td></tr></tbody></table></div><hr><h4 id="input-sync"><a href="#input-sync" class="headerlink" title="input_sync()"></a>input_sync()</h4><div class="table-container"><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td><strong>头文件</strong></td><td><code>&lt;linux/input.h&gt;</code></td></tr><tr><td><strong>函数原型</strong></td><td><code>void input_sync(struct input_dev *dev)</code></td></tr><tr><td><strong>参数</strong></td><td>- <code>dev</code>：指向 <code>input_dev</code> 的指针</td></tr><tr><td><strong>返回值</strong></td><td>无（<code>void</code>）</td></tr><tr><td><strong>作用</strong></td><td>发送一个 <strong>同步事件（EV_SYN / SYN_REPORT）</strong>，表示一组相关事件已完整上报。用户空间会将此前所有未同步的事件视为“同一时间发生”的一个事件包。<strong>每次上报完一组数据后必须调用此函数</strong>，否则事件可能不会被处理。</td></tr></tbody></table></div><h4 id="input-event"><a href="#input-event" class="headerlink" title="input_event()"></a>input_event()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_event() - report new input event</span></span><br><span class="line"><span class="comment"> * @dev: device that generated the event</span></span><br><span class="line"><span class="comment"> * @type: type of the event</span></span><br><span class="line"><span class="comment"> * @code: event code</span></span><br><span class="line"><span class="comment"> * @value: value of the event</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function should be used by drivers implementing various input</span></span><br><span class="line"><span class="comment"> * devices to report input events. See also input_inject_event().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> input_event() may be safely used right after input device was</span></span><br><span class="line"><span class="comment"> * allocated with input_allocate_device(), even before it is registered</span></span><br><span class="line"><span class="comment"> * with input_register_device(), but the event will not reach any of the</span></span><br><span class="line"><span class="comment"> * input handlers. Such early invocation of input_event() may be used</span></span><br><span class="line"><span class="comment"> * to &#x27;seed&#x27; initial state of a switch or initial position of absolute</span></span><br><span class="line"><span class="comment"> * axis, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params"> <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_event_supported(type, dev-&gt;evbit, EV_MAX)) &#123;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">input_handle_event(dev, type, code, value);</span><br><span class="line">spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_event);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><ul><li>所有上述函数均为 <strong>内联函数（inline）</strong>，内部最终调用 <code>input_event(dev, type, code, value)</code>。</li><li>事件类型（<code>type</code>）由函数隐式确定：<ul><li><code>input_report_key</code> → <code>EV_KEY</code></li><li><code>input_report_rel</code> → <code>EV_REL</code></li><li><code>input_report_abs</code> → <code>EV_ABS</code></li><li><code>input_report_ff_status</code> → <code>EV_FF_STATUS</code></li><li><code>input_report_switch</code> → <code>EV_SW</code></li><li><code>input_sync</code> → <code>EV_SYN</code>（<code>code = SYN_REPORT</code>）</li></ul></li></ul><p>这些函数是 Linux 输入子系统驱动开发中最核心的 API，用于将硬件产生的原始数据转换为标准输入事件供用户空间（如 evdev、libinput、X11/Wayland）使用。</p><p>在使用上报函数之后，通常会调用 <code>input_sync()</code>函数进行同步。同步事件的目的是告知输入子系统事件的结束，以便子系统可以将事件传递给相应的应用程序或系统组件进行处理。同步事件的调用可以防止事件数据的丢失或混乱。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>驱动，使用定时器每隔一段时间上报事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">myinput_dev</span>;</span>  <span class="comment">// 输入设备结构体指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timer_function</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span>;</span><br><span class="line"></span><br><span class="line">DEFINE_TIMER(test_timer, timer_function);  <span class="comment">// 定义定时器</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timer_function</span><span class="params">(<span class="keyword">struct</span> timer_list *t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value = <span class="number">0</span>;  <span class="comment">// 静态变量用于切换键值</span></span><br><span class="line"></span><br><span class="line">    value = value ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    input_event(myinput_dev, EV_KEY, KEY_1, value);      <span class="comment">// 发送按键事件</span></span><br><span class="line">    input_event(myinput_dev, EV_SYN, SYN_REPORT, <span class="number">0</span>);     <span class="comment">// 发送同步事件</span></span><br><span class="line"></span><br><span class="line">    mod_timer(&amp;test_timer, jiffies + msecs_to_jiffies(<span class="number">1000</span>));  <span class="comment">// 更新定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">myinput_dev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    myinput_dev = input_allocate_device();  <span class="comment">// 分配输入设备</span></span><br><span class="line">    <span class="keyword">if</span> (myinput_dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;input_allocate_device error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    myinput_dev-&gt;name = <span class="string">&quot;myinput_dev&quot;</span>;  <span class="comment">// 设置设备名</span></span><br><span class="line"></span><br><span class="line">    set_bit(EV_KEY, myinput_dev-&gt;evbit);   <span class="comment">// 支持按键事件</span></span><br><span class="line">    set_bit(EV_SYN, myinput_dev-&gt;evbit);   <span class="comment">// 支持同步事件</span></span><br><span class="line">    set_bit(KEY_1, myinput_dev-&gt;keybit);   <span class="comment">// 支持 KEY_1 按键</span></span><br><span class="line"></span><br><span class="line">    ret = input_register_device(myinput_dev);  <span class="comment">// 注册输入设备</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;input_register_device error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mod_timer(&amp;test_timer, jiffies + msecs_to_jiffies(<span class="number">1000</span>));  <span class="comment">// 启动定时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    input_free_device(myinput_dev);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">myinput_dev_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    del_timer(&amp;test_timer);           <span class="comment">// 删除定时器</span></span><br><span class="line">    input_unregister_device(myinput_dev);  <span class="comment">// 取消注册输入设备</span></span><br><span class="line">    input_free_device(myinput_dev);   <span class="comment">// 释放输入设备内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(myinput_dev_init);</span><br><span class="line">module_exit(myinput_dev_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="应用层获取上报数据"><a href="#应用层获取上报数据" class="headerlink" title="应用层获取上报数据"></a>应用层获取上报数据</h2><h3 id="input-event-结构体"><a href="#input-event-结构体" class="headerlink" title="input_event 结构体"></a>input_event 结构体</h3><p>应用层读取的数据为<code>input_event</code>结构体:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (__BITS_PER_LONG != 32 || !defined(__USE_TIME_BITS64)) &amp;&amp; !defined(__KERNEL__)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> input_event_sec time.tv_sec</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> input_event_usec time.tv_usec</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">__kernel_ulong_t</span> __sec;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__sparc__) &amp;&amp; defined(__arch64__)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __usec;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __pad;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">__kernel_ulong_t</span> __usec;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> input_event_sec  __sec</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> input_event_usec __usec</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">__u16 type;<span class="comment">// 类型</span></span><br><span class="line">__u16 code;<span class="comment">// 具体事件</span></span><br><span class="line">__s32 value;<span class="comment">// 对应的取值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>type</strong>：type 用于描述发生了哪一种类型的事件（对事件的分类），Linux 系统所支持的输入事件类型如下所示，这些宏定义同样在<code>&lt;linux/input.h&gt;</code>头文件中，所以在应用程序中需要包含该头文件；<ul><li>EV_SYN (0x00): 用于<strong>同步事件</strong>，表示一组输入事件的结束。</li><li>EV_KEY (0x01): 用于<strong>按键事件</strong>，表示按下、释放或重复一个键。</li><li>EV_REL (0x02): 用于<strong>相对位移事件</strong>，表示设备的相对位置变化，例如鼠标的移动。</li><li>EV_ABS (0x03): 用于<strong>绝对位移事件</strong>，表示设备的绝对位置变化，例如触摸屏的坐标。</li><li>EV_MSC (0x04): 用于<strong>杂项事件</strong>，包含一些特殊目的的事件类型，例如设备状态变化等。</li><li>EV_SW (0x05): 用于<strong>开关事件</strong>，表示开关的状态变化，例如电源按钮、开合盖等。</li><li>EV_LED (0x11): 用于 <strong>LED 事件</strong>，表示 LED 灯的状态变化。</li><li>EV_SND (0x12): 用于<strong>声音事件</strong>，表示声音的播放相关事件。</li><li>EV_REP (0x14): 用于<strong>重复事件</strong>，表示键盘重复发送事件。</li><li>EV_FF (0x15): 用于<strong>力反馈事件</strong>，表示力反馈设备的输出事件。</li><li>EV_PWR (0x16): 用于<strong>电源事件</strong>，表示电源状态变化。</li><li>EV_FF_STATUS (0x17): 用于<strong>力反馈状态事件</strong>，表示力反馈设备的状态变化。</li><li>EV_MAX (0x1f): 输入事件类型的最大值。</li><li>EV_CNT: 输入事件类型的数量。</li></ul></li><li><strong>code</strong>：code 表示该类事件中的哪一个具体事件，以上列举的每一种事件类型中都包含了一系列具体事件，譬如一个键盘上通常有很多按键，而 code 变量则告知应用程序是哪一个按键发生了输入事件。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_RESERVED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_ESC 1 <span class="comment">//ESC 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_1 2  <span class="comment">//数字 1 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_2 3  <span class="comment">//数字 2 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_3 4  <span class="comment">//数字 3 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_4 5  <span class="comment">//数字 4 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_5 6  <span class="comment">//数字 5 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_6 7 <span class="comment">//数字 6 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_7 8 <span class="comment">//数字 7 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_8 9 <span class="comment">//数字 8 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_9 10 <span class="comment">//数字 9 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_0 11 <span class="comment">//数字 0 键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_MINUS 12 <span class="comment">//减号键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_EQUAL 13<span class="comment">//加号键</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_BACKSPACE 14 <span class="comment">//回退键</span></span></span><br></pre></td></tr></table></figure><p>对于其他输入事件的 code 值 ，可以查看 <code>input-event-codes.h</code> 头文件 （该头文件被<code>&lt;linux/input.h&gt;</code>所包含）。</p><ul><li><strong>value</strong>: 核每次上报事件都会向应用层发送一个数据 value，对 value 值的解释随着 code的变化而变化。<ul><li>譬如对于按键事件来说，如果 value 等于 1，则表示按键按下；value 等于 0 表示按键松开，如果 value 等于 2 则表示按键长按。</li><li>而在绝对位移事件中（type=3），如果code=0（触摸点 X 坐标 ABS_X），那么 value 值就等于触摸点的 X 轴坐标值；如果 code=1（触摸点 Y 坐标 ABS_Y），此时 value 值便等于触摸点的 Y 轴坐标值。</li></ul></li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;  <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">int</span> ret;  <span class="comment">// 返回值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span>  <span class="comment">// 输入事件结构体</span></span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/input/event4&quot;</span>, O_RDWR);  <span class="comment">// 打开输入设备文件</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开错误\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ret = read(fd, &amp;event, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> input_event));  <span class="comment">// 读取输入事件</span></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;读取错误\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event.type == EV_KEY) &#123;  <span class="comment">// 判断事件类型为键盘事件</span></span><br><span class="line">            <span class="keyword">if</span> (event.code == KEY_1) &#123;  <span class="comment">// 判断键码为1</span></span><br><span class="line">                <span class="keyword">if</span> (event.value == <span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;值为1\n&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (event.value == <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;值为0\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="上报数据格式"><a href="#上报数据格式" class="headerlink" title="上报数据格式"></a>上报数据格式</h3><p>以使用命令<code>hexdump /dev/input/event4</code>来查看上报的信息。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195236276.png" alt="hexdump /dev/input/event4"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (__BITS_PER_LONG != 32 || !defined(__USE_TIME_BITS64)) &amp;&amp; !defined(__KERNEL__)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> input_event_sec time.tv_sec</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> input_event_usec time.tv_usec</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">__kernel_ulong_t</span> __sec;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__sparc__) &amp;&amp; defined(__arch64__)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __usec;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __pad;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">__kernel_ulong_t</span> __usec;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> input_event_sec  __sec</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> input_event_usec __usec</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">__u16 type;<span class="comment">// 类型</span></span><br><span class="line">__u16 code;<span class="comment">// 具体事件</span></span><br><span class="line">__s32 value;<span class="comment">// 对应的取值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在 <code>input_event</code> 数据包中，有四个成员变量：time, type, code, value。<ul><li><code>time.tv_sec</code> 和 <code>time.tv_usec</code> 的类型是 long int,占 8 个字节，所以<code>time</code>占16个字节</li><li><code>__u16 type</code> 的类型是 unsigned short int,占 2 个字节</li><li><code>__u16 code</code> 的类型是 unsigned short int,占 2 个字节</li><li><code>__s32 value</code> 的类型是 unsigned int，占 4 个字节</li></ul></li></ul><p>因此，一个 input_event 数据包所占字节的大小为 8+8+2+2+4 =24 个字节</p><blockquote><p> 一般情况下，<code>input_event</code> 数据包的字节顺序是小端字节序（Little Endian）。这意味着较低的字节位于较高的内存地址处。</p></blockquote><p>假设 hexdump 输出的数据（以 16 进制表示）如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@topeet:~$ hexdump /dev/input/event2</span><br><span class="line"><span class="number">0000000</span> <span class="number">0f</span>09 <span class="number">65</span>d3 <span class="number">0000</span> <span class="number">0000</span> <span class="number">36f</span>b <span class="number">0001</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000010</span> <span class="number">0003</span> <span class="number">0039</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0f</span>09 <span class="number">65</span>d3 <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000020</span> <span class="number">36f</span>b <span class="number">0001</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0003</span> <span class="number">0035</span> <span class="number">00f</span>5 <span class="number">0000</span></span><br><span class="line"><span class="number">0000030</span> <span class="number">0f</span>09 <span class="number">65</span>d3 <span class="number">0000</span> <span class="number">0000</span> <span class="number">36f</span>b <span class="number">0001</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000040</span> <span class="number">0003</span> <span class="number">0036</span> <span class="number">02b</span>2 <span class="number">0000</span> <span class="number">0f</span>09 <span class="number">65</span>d3 <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000050</span> <span class="number">36f</span>b <span class="number">0001</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0003</span> <span class="number">0030</span> <span class="number">0021</span> <span class="number">0000</span></span><br></pre></td></tr></table></figure><p>第一个<code>input_event</code>对应成员如下：</p><ul><li><strong>tv_sec</strong>        0f09 65d3 0000 0000</li><li><strong>tv_usec</strong>     36fb 0001 0000 0000</li><li><strong>type</strong>           0003</li><li><strong>code</strong>           0039</li><li><strong>value</strong>         0000 0000</li></ul><h2 id="通用事件处理层-evdev"><a href="#通用事件处理层-evdev" class="headerlink" title="通用事件处理层 evdev"></a>通用事件处理层 evdev</h2><h3 id="connect-函数分析"><a href="#connect-函数分析" class="headerlink" title="connect 函数分析"></a>connect 函数分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/input/evdev.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> <span class="title">evdev_handler</span> =</span> &#123;</span><br><span class="line">.event= evdev_event, <span class="comment">// 事件处理函数指针，指向名为 evdev_event 的函数，用于处理输入事件</span></span><br><span class="line">.events= evdev_events,<span class="comment">// 批量事件处理函数指针，指向名为 evdev_events 的函数，用于处理输入设备的多个事件</span></span><br><span class="line">.connect= evdev_connect,<span class="comment">// 当 input_dev 和 input_handler 匹配成功之后执行的连接处理函数</span></span><br><span class="line">.disconnect= evdev_disconnect,<span class="comment">// 断开连接处理函数</span></span><br><span class="line">.legacy_minors= <span class="literal">true</span>,<span class="comment">// 设置为 true,表示支持传统次设备号，如果设置为 false,则使用动态的次设备号分配方式</span></span><br><span class="line">.minor= EVDEV_MINOR_BASE,<span class="comment">// 输入设备的基础次设备号</span></span><br><span class="line">.name= <span class="string">&quot;evdev&quot;</span>,<span class="comment">// 设备名称，设置为字符串 &quot;evdev&quot;</span></span><br><span class="line">.id_table= evdev_ids,<span class="comment">// 输入设备 ID 表，指向名为 evdev_ids 的表，用于匹配输入设备的 ID</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">evdev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> input_register_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="evdev-结构体"><a href="#evdev-结构体" class="headerlink" title="evdev 结构体"></a>evdev 结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> &#123;</span></span><br><span class="line"><span class="type">int</span> open;<span class="comment">// 记录 evdev 设备打开的状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> <span class="title">handle</span>;</span><span class="comment">// 输入事件处理器的句柄</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> __<span class="title">rcu</span> *<span class="title">grab</span>;</span><span class="comment">// 指向当前占用 evdev 设备的客户端</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">client_list</span>;</span><span class="comment">// 与 evdev 设备关联的客户端链表</span></span><br><span class="line"><span class="type">spinlock_t</span> client_lock; <span class="comment">/* protects client_list */</span> <span class="comment">// 用于保护客户端链表的自旋锁</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span><span class="comment">// 用于保护对 evdev 设备的互斥访问</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span><span class="comment">// 与 evdev 设备关联的设备结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">// evdev 设备的字符设备结构</span></span><br><span class="line"><span class="type">bool</span> exist;<span class="comment">// 表示 evdev 设备是否存在</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>open</strong>: 记录 evdev 设备的打开状态，可能的取值为 0（关闭）或 1（打开）。</li><li><strong>handle</strong>: 用于处理输入事件的句柄，包含了与事件处理器相关的信息，如打开的输入设备和事件处理函数等。</li><li><strong>grab</strong>: 指向当前占用 evdev 设备的客户端。当某个客户端占用了 evdev 设备时，其他客户端无法访问该设备。</li><li><strong>client_list</strong>:  与 evdev 设备关联的客户端链表，用于管理连接到该设备的客户端。</li><li><strong>client_lock</strong>: 用于保护客户端链表的自旋锁，确保在多线程环境下对客户端链表的操作线程是安全的。</li><li><strong>mutex</strong>: 用于保护对 evdev 设备的互斥访问，确保在多线程环境下对设备的操作是互斥的。</li><li><strong>dev</strong>: 与 evdev 设备关联的设备结构体，用于表示设备的特定信息，如设备名称，设备号等。</li><li><strong>cdev</strong>: evdev 设备的字符设备结构，用于注册和管理字符设备。</li><li><strong>exist</strong>: 表示 evdev 设备是否存在的标志。如果设备存在，则为 true;否则为 false。</li></ul><h4 id="evdev-client-结构体"><a href="#evdev-client-结构体" class="headerlink" title="evdev_client 结构体"></a>evdev_client 结构体</h4><p>这个结构体定义了一个 evdev 客户端的相关信息和状态，用于管理与 evdev 设备相关联的客户端，<strong>在应用程序中每打开一遍 event 设备节点，就会用一个 <code>evdev_client</code> 结构体来表示</strong>，系统可以为每个 evdev 设备维护多个客户端，并管理每个客户端的状态和属性。</p><p>在 evdev.c 中，也会对这个结构体进行操作，并根据客户端的状态和属性，将接收到的事件写入缓冲区或通知客户端。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head; <span class="comment">// 缓冲区的头指针，指向下一个可写入的位置</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail; <span class="comment">// 缓冲区的尾指针，指向下一个可读取的位置</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> packet_head; <span class="comment">/* [future] position of the first element of next packet */</span> <span class="comment">// [未来] 下一个数据包的第一个元素的位置</span></span><br><span class="line"><span class="type">spinlock_t</span> buffer_lock; <span class="comment">/* protects access to buffer, head and tail */</span> <span class="comment">// 用于保护对缓冲区、头指针和尾指针的访问的自旋锁</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> wait;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span><span class="comment">// 用于异步通知的结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span><span class="comment">// 与客户端关联的 evdev 设备指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span><span class="comment">// 与 evdev 设备关联的客户端链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">input_clock_type</span> <span class="title">clk_type</span>;</span><span class="comment">// 输入时钟类型</span></span><br><span class="line"><span class="type">bool</span> revoked;<span class="comment">// 标志，指示客户端是否被撤销</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *evmasks[EV_CNT];<span class="comment">// 用于事件掩码的数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bufsize;<span class="comment">// 缓冲区的大小</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">buffer</span>[];</span><span class="comment">// 输入事件缓冲区，可变长度数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>head</strong>: 缓冲区的头指针，指向下一个可写入的位置。</li><li><strong>tail</strong>:缓冲区的尾指针，指向下一个可读取的位置。</li><li><strong>packet_head</strong>:下一个数据包的第一个元素的位置。</li><li><strong>buffer_lock</strong>：用于保护对缓冲区，头指针和尾指针的访问的自旋锁，在多线程环境下确保对缓冲区的操作线程是安全的。</li><li><strong>fasync</strong>:用于异步通知的结构体指针，在需要异步通知时，将其设置为相应的值。</li><li><strong>evdev</strong>:与客户端关联的 evdev 设备指针，表示客户端所属的 evdev 设备。</li><li><strong>node</strong>:与 evdev 设备关联的客户端链表节点，用于管理与设备关联的客户端。</li><li><strong>clk_type</strong>:输入时钟类型，表示客户端使用的输入时钟类型。</li><li><strong>revoked</strong>:标志，指示客户端是否被撤销。</li><li><strong>evmasks</strong>:用于事件掩码的数组，存储了不同类型事件的掩码，数组的大小由 EV_CNT 定义。</li><li><strong>bufsize</strong>:缓冲区的大小，表示缓冲区可以容纳的输入事件数量。</li><li><strong>buffer[]</strong>:输入事件缓冲区，是一个可变长度数组，存储了输入事件数据。</li></ul><h4 id="evdev-connect-1"><a href="#evdev-connect-1" class="headerlink" title="evdev_connect()"></a>evdev_connect()</h4><p><code>input_handler</code>的connect函数。</p><p><code>input_register_handler()</code>中调用<code>input_attach_handler()</code>，该函数又调用<code>input_handler</code>的connect函数，<code>error = handler-&gt;connect(handler, dev, id)</code>即<code>evdev_connect()</code></p><p>该函数的主要功能是建立与输入设备的连接，初始化并注册输入句柄，设置设备属性，并添加字符设备到系统中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EVDEV_MINOR_BASE64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVDEV_MINORS32</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create new evdev device. Note that input core serializes calls</span></span><br><span class="line"><span class="comment"> * to connect and disconnect.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">evdev_connect</span><span class="params">(<span class="keyword">struct</span> input_handler *handler, <span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="keyword">struct</span> input_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span></span><br><span class="line"><span class="type">int</span> minor;</span><br><span class="line"><span class="type">int</span> dev_no;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"><span class="comment">// 获取一个新的次设备号</span></span><br><span class="line">minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (minor &lt; <span class="number">0</span>) &#123;</span><br><span class="line">error = minor;</span><br><span class="line">pr_err(<span class="string">&quot;failed to reserve new minor: %d\n&quot;</span>, error);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 分配并初始化 evdev 结构体</span></span><br><span class="line">evdev = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> evdev), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!evdev) &#123;</span><br><span class="line">error = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err_free_minor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化 evdev 结构体中的成员</span></span><br><span class="line">INIT_LIST_HEAD(&amp;evdev-&gt;client_list);<span class="comment">// 初始化客户端链表</span></span><br><span class="line">spin_lock_init(&amp;evdev-&gt;client_lock);<span class="comment">// 初始化客户端链表的自旋锁</span></span><br><span class="line">mutex_init(&amp;evdev-&gt;mutex);<span class="comment">// 初始化互斥锁</span></span><br><span class="line">evdev-&gt;exist = <span class="literal">true</span>;<span class="comment">// 设置 evdev 存在标志为 true，表示 evdev 存在。</span></span><br><span class="line"></span><br><span class="line">dev_no = minor;<span class="comment">// 根据次设备号计算设备号 dev_no,并根据情况将其归一化为传统范围内的设备号。</span></span><br><span class="line"><span class="comment">/* Normalize device number if it falls into legacy range */</span></span><br><span class="line"><span class="keyword">if</span> (dev_no &lt; EVDEV_MINOR_BASE + EVDEV_MINORS)<span class="comment">// 如果设备号在旧版范围内，则进行标准化处理</span></span><br><span class="line">dev_no -= EVDEV_MINOR_BASE;</span><br><span class="line">dev_set_name(&amp;evdev-&gt;dev, <span class="string">&quot;event%d&quot;</span>, dev_no);<span class="comment">// 设置设备名称</span></span><br><span class="line"></span><br><span class="line">evdev-&gt;handle.dev = input_get_device(dev);<span class="comment">// 设置输入句柄的输入设备</span></span><br><span class="line">evdev-&gt;handle.name = dev_name(&amp;evdev-&gt;dev);<span class="comment">// 设置输入句柄的名称为设备名称</span></span><br><span class="line">evdev-&gt;handle.handler = handler;<span class="comment">// 设置输入句柄的处理程序为传入的处理程序</span></span><br><span class="line">evdev-&gt;handle.private = evdev;<span class="comment">//  设置输入句柄的私有数据指针为 evdev 结构体的指针</span></span><br><span class="line"></span><br><span class="line">evdev-&gt;dev.devt = MKDEV(INPUT_MAJOR, minor);<span class="comment">// 设置设备号</span></span><br><span class="line">evdev-&gt;dev.class = &amp;input_class;<span class="comment">// 设置设备的类</span></span><br><span class="line">evdev-&gt;dev.parent = &amp;dev-&gt;dev;<span class="comment">// 设置设备的父设备</span></span><br><span class="line">evdev-&gt;dev.release = evdev_free;<span class="comment">// 设置设备的释放函数为 evdev_free</span></span><br><span class="line">device_initialize(&amp;evdev-&gt;dev);<span class="comment">// 初始化设备</span></span><br><span class="line"></span><br><span class="line">error = input_register_handle(&amp;evdev-&gt;handle);<span class="comment">// 注册输入句柄</span></span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> err_free_evdev;</span><br><span class="line"></span><br><span class="line">cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops);<span class="comment">// 初始化字符设备结构体</span></span><br><span class="line"></span><br><span class="line">error = cdev_device_add(&amp;evdev-&gt;cdev, &amp;evdev-&gt;dev);<span class="comment">// 添加字符设备</span></span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> err_cleanup_evdev;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_cleanup_evdev:</span><br><span class="line">evdev_cleanup(evdev);<span class="comment">// 清理 evdev 结构体</span></span><br><span class="line">input_unregister_handle(&amp;evdev-&gt;handle);<span class="comment">// 取消注册输入句柄</span></span><br><span class="line"> err_free_evdev:</span><br><span class="line">put_device(&amp;evdev-&gt;dev);<span class="comment">// 释放设备</span></span><br><span class="line"> err_free_minor:</span><br><span class="line">input_free_minor(minor);<span class="comment">// 释放次设备号</span></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见 <code>connect</code> 函数的主要任务是将输入设备与事件处理器关联起来，以便在事件发生时调用相应的处理函数。</p><p>它通过注册输入处理器和设置回调函数来实现这一关联，并确保正确的事件处理器被调用。这种关联机制允许开发者根据需要自定义处理函数，以便根据输入设备上报的事件进行相应的处理。</p><h3 id="分配设备号分析"><a href="#分配设备号分析" class="headerlink" title="分配设备号分析"></a>分配设备号分析</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195244328.png" alt="次设备号"></p><p>从上图中可以发现由 evdev.c 程序创建的设备节点 event0,event1,event2,event3 的主设备号都是 13，次设备号是 64,65,66,67。所有设备号的规律是主设备号全部都是 13，次设备号从 64 开始依次往后类推。</p><h4 id="主设备号"><a href="#主设备号" class="headerlink" title="主设备号"></a>主设备号</h4><p>在 connect 函数中，使用 <code>evdev-&gt;dev.devt = MKDEV(INPUT_MAJOR, minor);</code>设置了主设备号，主设备号为INPUT_MAJOR,也就是 13</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/uapi/linux/major.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MAJOR13</span></span><br></pre></td></tr></table></figure><h4 id="次设备号"><a href="#次设备号" class="headerlink" title="次设备号"></a>次设备号</h4><p>在 connect 函数中，使用了<code>minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, true);</code>函数获取了次设备号。而</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EVDEV_MINOR_BASE64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVDEV_MINORS32</span></span><br></pre></td></tr></table></figure><h5 id="input-get-new-minor"><a href="#input-get-new-minor" class="headerlink" title="input_get_new_minor()"></a>input_get_new_minor()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_get_new_minor - allocates a new input minor number</span></span><br><span class="line"><span class="comment"> * @legacy_base: beginning or the legacy range to be searched</span></span><br><span class="line"><span class="comment"> * @legacy_num: size of legacy range</span></span><br><span class="line"><span class="comment"> * @allow_dynamic: whether we can also take ID from the dynamic range</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function allocates a new device minor for from input major namespace.</span></span><br><span class="line"><span class="comment"> * Caller can request legacy minor by specifying @legacy_base and @legacy_num</span></span><br><span class="line"><span class="comment"> * parameters and whether ID can be allocated from dynamic range if there are</span></span><br><span class="line"><span class="comment"> * no free IDs in legacy range.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">input_get_new_minor</span><span class="params">(<span class="type">int</span> legacy_base, <span class="type">unsigned</span> <span class="type">int</span> legacy_num,</span></span><br><span class="line"><span class="params"><span class="type">bool</span> allow_dynamic)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function should be called from input handler&#x27;s -&gt;connect()</span></span><br><span class="line"><span class="comment"> * methods, which are serialized with input_mutex, so no additional</span></span><br><span class="line"><span class="comment"> * locking is needed here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (legacy_base &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> minor = ida_simple_get(&amp;input_ida,</span><br><span class="line">   legacy_base,</span><br><span class="line">   legacy_base + legacy_num,</span><br><span class="line">   GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (minor &gt;= <span class="number">0</span> || !allow_dynamic)</span><br><span class="line"><span class="keyword">return</span> minor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ida_simple_get(&amp;input_ida,</span><br><span class="line">      INPUT_FIRST_DYNAMIC_DEV, INPUT_MAX_CHAR_DEVICES,</span><br><span class="line">      GFP_KERNEL);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_get_new_minor);</span><br></pre></td></tr></table></figure><p>上面的函数用于获取一个新的次设备号。主要功能是根据指定的条件获取一个新的次设备号。如果指定了 legacy_base，则优先从该范围内获取次设备号，如果获取失败或不允许动态分配，则尝试从动态分配的范围内获取次设备号。最终返回获取到的次设备号。</p><ul><li><p>如果 legacy_base 大于等于 0，则执行以下逻辑：</p><ul><li><p>使用 <code>ida_simple_get()</code> 函数从 <code>input_ida</code> 中获取一个次设备号 <code>minor</code>,范围为 <code>legacy_base</code> 到 <code>legacy_base+legacy_num</code></p></li><li><p>如果获取到的次设备号 minor 大于等于 0 或者不允许动态分配（<code>allow_dynamic</code> 为 false），则返回次设备号 minor。</p></li></ul></li><li><p>如果上述条件不满足，则执行以下逻辑：</p><ul><li>使 用 <code>ida_simple_get()</code> 函 数 从<code>input_ida</code> 中 获 取 一 个 次 设 备 号<code>minor</code> ， 范 围 为<code>INPUT_FIRST_DYNAMIC_DEV</code> 到 <code>INPUT_MAX_CHAR_DEVICES</code>。</li></ul></li></ul><p>而<code>ida_simple_get()</code>定义为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ida_simple_get(ida, start, end, gfp)\</span></span><br><span class="line"><span class="meta">ida_alloc_range(ida, start, (end) - 1, gfp)</span></span><br></pre></td></tr></table></figure><p><code>ida_alloc_range</code>函数用于在 ID 分配器中分配一个连续的 ID 范围。宏的参数解释如下：</p><ul><li><strong>ida</strong>:    表示 IDA 对象的指针，用于管理 ID 范围的分配和释放。</li><li><strong>start</strong>: 表示分配的 ID 范围的起始 ID。</li><li><strong>end</strong>:  表示分配的 ID 范围的结束 ID。</li><li><strong>gfp</strong>:   表示用于内存分配的 GFP 标志。</li></ul><h3 id="文件操作集函数"><a href="#文件操作集函数" class="headerlink" title="文件操作集函数"></a>文件操作集函数</h3><p>在 <code>connect</code> 函数中，通过<code>cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops);</code>创建字符设备，创建字符设备中最重要的操作是实现文件操作集中的函数，如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">evdev_fops</span> =</span> &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.read= evdev_read,</span><br><span class="line">.write= evdev_write,</span><br><span class="line">.poll= evdev_poll,</span><br><span class="line">.open= evdev_open,</span><br><span class="line">.release= evdev_release,</span><br><span class="line">.unlocked_ioctl= evdev_ioctl,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_ioctl= evdev_ioctl_compat,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.fasync= evdev_fasync,</span><br><span class="line">.llseek= no_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="open-函数分析"><a href="#open-函数分析" class="headerlink" title="open 函数分析"></a>open 函数分析</h4><p>在 <code>connect</code> 函数中，通过<code>cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops);</code>创建字符设备，创建字符设备中最重要的操作是实现文件操作集中的函数，如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">evdev_fops</span> =</span> &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.read= evdev_read,</span><br><span class="line">.write= evdev_write,</span><br><span class="line">.poll= evdev_poll,</span><br><span class="line">.open= evdev_open,</span><br><span class="line">.release= evdev_release,</span><br><span class="line">.unlocked_ioctl= evdev_ioctl,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">.compat_ioctl= evdev_ioctl_compat,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.fasync= evdev_fasync,</span><br><span class="line">.llseek= no_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="evdev-open"><a href="#evdev-open" class="headerlink" title="evdev_open()"></a>evdev_open()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">evdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从 inode 的 i_cdev 成员中获取 evdev 结构体的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> evdev, cdev);</span><br><span class="line">    <span class="comment">// 计算缓冲区大小</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bufsize = evdev_compute_buffer_size(evdev-&gt;handle.dev);</span><br><span class="line">    <span class="comment">// 定义 evdev_client 结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span>;</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存用于存储 evdev_client 结构体和输入事件缓冲区</span></span><br><span class="line">client = kvzalloc(struct_size(client, buffer, bufsize), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!client)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待队列初始化</span></span><br><span class="line">init_waitqueue_head(&amp;client-&gt;wait);</span><br><span class="line">    <span class="comment">// 初始化 client 结构体的成员变量</span></span><br><span class="line">client-&gt;bufsize = bufsize;</span><br><span class="line">spin_lock_init(&amp;client-&gt;buffer_lock);</span><br><span class="line">client-&gt;evdev = evdev;</span><br><span class="line">    <span class="comment">// 将 client 添加到 evdev 的客户端列表中</span></span><br><span class="line">evdev_attach_client(evdev, client);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开底层设备</span></span><br><span class="line">error = evdev_open_device(evdev);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> err_free_client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 client 结构体设置为文件的私有数据</span></span><br><span class="line">file-&gt;private_data = client;</span><br><span class="line">    <span class="comment">// 使用stream_open打开,标记文件是no_seekable的，不支持随机访问</span></span><br><span class="line">stream_open(inode, file);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_free_client:</span><br><span class="line">    <span class="comment">// 打开设备失败，需要进行错误处理，从 evdev 的客户端列表中移除 client</span></span><br><span class="line">evdev_detach_client(evdev, client);</span><br><span class="line">    <span class="comment">// 释放 client 分配的内存</span></span><br><span class="line">kvfree(client);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="stream-open"><a href="#stream-open" class="headerlink" title="stream_open()"></a>stream_open()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stream_open is used by subsystems that want stream-like file descriptors.</span></span><br><span class="line"><span class="comment"> * Such file descriptors are not seekable and don&#x27;t have notion of position</span></span><br><span class="line"><span class="comment"> * (file.f_pos is always 0 and ppos passed to .read()/.write() is always NULL).</span></span><br><span class="line"><span class="comment"> * Contrary to file descriptors of other regular files, .read() and .write()</span></span><br><span class="line"><span class="comment"> * can run simultaneously.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * stream_open never fails and is marked to return int so that it could be</span></span><br><span class="line"><span class="comment"> * directly used as file_operations.open .</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stream_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;f_mode &amp;= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE | FMODE_ATOMIC_POS);</span><br><span class="line">filp-&gt;f_mode |= FMODE_STREAM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(stream_open);</span><br></pre></td></tr></table></figure><h5 id="edev-open-device"><a href="#edev-open-device" class="headerlink" title="edev_open_device()"></a>edev_open_device()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">evdev_open_device</span><span class="params">(<span class="keyword">struct</span> evdev *evdev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">retval = mutex_lock_interruptible(&amp;evdev-&gt;mutex);<span class="comment">// 获取输入设备的互斥锁</span></span><br><span class="line"><span class="keyword">if</span> (retval)<span class="comment">// 如果无法获取锁，函数将返回相应的错误码</span></span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!evdev-&gt;exist)<span class="comment">// 如果该字段为假（0），表示输入设备不存在</span></span><br><span class="line">retval = -ENODEV;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!evdev-&gt;open++) &#123;</span><br><span class="line">retval = input_open_device(&amp;evdev-&gt;handle);<span class="comment">// 调用 input_open_device 函数打开输入设备，并将返回值存储在 retval 变量中</span></span><br><span class="line"><span class="keyword">if</span> (retval)<span class="comment">// 如果打开设备失败，函数会将 evdev-&gt;open 减一，表示设备的打开计数器递减</span></span><br><span class="line">evdev-&gt;open--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;evdev-&gt;mutex); <span class="comment">// 释放输入设备的互斥锁</span></span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="input-open-device"><a href="#input-open-device" class="headerlink" title="input_open_device()"></a>input_open_device()</h5><p><code>evdev_open_device()</code>中调用 <code>input_open_device()</code> 函数打开输入设备。该函数会调用<code>input_dev</code>的 <code>open()</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_open_device - open input device</span></span><br><span class="line"><span class="comment"> * @handle: handle through which device is being accessed</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function should be called by input handlers when they</span></span><br><span class="line"><span class="comment"> * want to start receive events from given input device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">input_open_device</span><span class="params">(<span class="keyword">struct</span> input_handle *handle)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> =</span> handle-&gt;dev;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">retval = mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;going_away) &#123;</span><br><span class="line">retval = -ENODEV;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle-&gt;open++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;users++) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Device is already opened, so we can exit immediately and</span></span><br><span class="line"><span class="comment"> * report success.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;open) &#123;</span><br><span class="line">retval = dev-&gt;open(dev);</span><br><span class="line"><span class="keyword">if</span> (retval) &#123;</span><br><span class="line">dev-&gt;users--;</span><br><span class="line">handle-&gt;open--;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Make sure we are not delivering any more events</span></span><br><span class="line"><span class="comment"> * through this handle</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">synchronize_rcu();</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;poller)</span><br><span class="line">input_dev_poller_start(dev-&gt;poller);</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_open_device);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="ioctl-函数分析"><a href="#ioctl-函数分析" class="headerlink" title="ioctl 函数分析"></a>ioctl 函数分析</h4><h5 id="evdev-ioctl"><a href="#evdev-ioctl" class="headerlink" title="evdev_ioctl()"></a>evdev_ioctl()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">evdev_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用 evdev_ioctl_handler 函数来处理 IO 控制操作，传递给它 file 指针，cmd 和</span></span><br><span class="line">    <span class="comment">// 类型转换后的 arg 作为参数。函数将 arg 转换为 void __user *类型，以便在用户空间和内核空</span></span><br><span class="line">    <span class="comment">// 间之间传递指针。函数将 evdev_ioctl_handler 的返回值作为自己的返回值，并将其直接返回给调用者</span></span><br><span class="line"><span class="keyword">return</span> evdev_ioctl_handler(file, cmd, (<span class="type">void</span> __user *)arg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="evdev-ioctl-handler"><a href="#evdev-ioctl-handler" class="headerlink" title="evdev_ioctl_handler()"></a>evdev_ioctl_handler()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">evdev_ioctl_handler</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params"><span class="type">void</span> __user *p, <span class="type">int</span> compat_mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从文件结构获取指向 evdev_client 的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;</span><br><span class="line">    <span class="comment">// 从 evdev_client 获取指向 evdev 的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> client-&gt;evdev;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取 evdev 的互斥锁，如果无法获取则返回相应的错误码</span></span><br><span class="line">retval = mutex_lock_interruptible(&amp;evdev-&gt;mutex);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 检查设备是否存在或者客户端是否已被撤销</span></span><br><span class="line"><span class="keyword">if</span> (!evdev-&gt;exist || client-&gt;revoked) &#123;</span><br><span class="line">retval = -ENODEV;<span class="comment">// 如果设备不存在或客户端已被撤销，则返回设备不存在的错误码</span></span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 evdev_do_ioctl 函数来执行实际的 IO 控制操作，并将返回值存储在 retval 变量中</span></span><br><span class="line">retval = evdev_do_ioctl(file, cmd, p, compat_mode);</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">mutex_unlock(&amp;evdev-&gt;mutex);<span class="comment">// 解锁 evdev 的互斥锁</span></span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="evdev-do-ioctl"><a href="#evdev-do-ioctl" class="headerlink" title="evdev_do_ioctl()"></a>evdev_do_ioctl()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">evdev_do_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">   <span class="type">void</span> __user *p, <span class="type">int</span> compat_mode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> client-&gt;evdev;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> =</span> evdev-&gt;handle.dev;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_absinfo</span> <span class="title">abs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_mask</span> <span class="title">mask</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ff_effect</span> <span class="title">effect</span>;</span></span><br><span class="line"><span class="type">int</span> __user *ip = (<span class="type">int</span> __user *)p;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i, t, u, v;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* First we check for fixed-length commands */</span></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVIOCGVERSION:</span><br><span class="line"><span class="keyword">return</span> put_user(EV_VERSION, ip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVIOCGID:</span><br><span class="line"><span class="keyword">if</span> (copy_to_user(p, &amp;dev-&gt;id, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> input_id)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVIOCGREP:</span><br><span class="line"><span class="keyword">if</span> (!test_bit(EV_REP, dev-&gt;evbit))</span><br><span class="line"><span class="keyword">return</span> -ENOSYS;</span><br><span class="line"><span class="keyword">if</span> (put_user(dev-&gt;rep[REP_DELAY], ip))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (put_user(dev-&gt;rep[REP_PERIOD], ip + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVIOCSREP:</span><br><span class="line"><span class="keyword">if</span> (!test_bit(EV_REP, dev-&gt;evbit))</span><br><span class="line"><span class="keyword">return</span> -ENOSYS;</span><br><span class="line"><span class="keyword">if</span> (get_user(u, ip))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (get_user(v, ip + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">input_inject_event(&amp;evdev-&gt;handle, EV_REP, REP_DELAY, u);</span><br><span class="line">input_inject_event(&amp;evdev-&gt;handle, EV_REP, REP_PERIOD, v);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVIOCRMFF:</span><br><span class="line"><span class="keyword">return</span> input_ff_erase(dev, (<span class="type">int</span>)(<span class="type">unsigned</span> <span class="type">long</span>) p, file);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVIOCGEFFECTS:</span><br><span class="line">i = test_bit(EV_FF, dev-&gt;evbit) ?</span><br><span class="line">dev-&gt;ff-&gt;max_effects : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (put_user(i, ip))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVIOCGRAB:</span><br><span class="line"><span class="keyword">if</span> (p)</span><br><span class="line"><span class="keyword">return</span> evdev_grab(evdev, client);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> evdev_ungrab(evdev, client);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVIOCREVOKE:</span><br><span class="line"><span class="keyword">if</span> (p)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> evdev_revoke(evdev, client, file);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVIOCGMASK: &#123;</span><br><span class="line"><span class="type">void</span> __user *codes_ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;mask, p, <span class="keyword">sizeof</span>(mask)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">codes_ptr = (<span class="type">void</span> __user *)(<span class="type">unsigned</span> <span class="type">long</span>)mask.codes_ptr;</span><br><span class="line"><span class="keyword">return</span> evdev_get_mask(client,</span><br><span class="line">      mask.type, codes_ptr, mask.codes_size,</span><br><span class="line">      compat_mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVIOCSMASK: &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">void</span> __user *codes_ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;mask, p, <span class="keyword">sizeof</span>(mask)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">codes_ptr = (<span class="type">const</span> <span class="type">void</span> __user *)(<span class="type">unsigned</span> <span class="type">long</span>)mask.codes_ptr;</span><br><span class="line"><span class="keyword">return</span> evdev_set_mask(client,</span><br><span class="line">      mask.type, codes_ptr, mask.codes_size,</span><br><span class="line">      compat_mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVIOCSCLOCKID:</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;i, p, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> evdev_set_clk_type(client, i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVIOCGKEYCODE:</span><br><span class="line"><span class="keyword">return</span> evdev_handle_get_keycode(dev, p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVIOCSKEYCODE:</span><br><span class="line"><span class="keyword">return</span> evdev_handle_set_keycode(dev, p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVIOCGKEYCODE_V2:</span><br><span class="line"><span class="keyword">return</span> evdev_handle_get_keycode_v2(dev, p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EVIOCSKEYCODE_V2:</span><br><span class="line"><span class="keyword">return</span> evdev_handle_set_keycode_v2(dev, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size = _IOC_SIZE(cmd);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now check variable-length commands */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVIOC_MASK_SIZE(nr)((nr) &amp; ~(_IOC_SIZEMASK &lt;&lt; _IOC_SIZESHIFT))</span></span><br><span class="line"><span class="keyword">switch</span> (EVIOC_MASK_SIZE(cmd)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="title function_">EVIOCGPROP</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">bits_to_user</span><span class="params">(dev-&gt;propbit, INPUT_PROP_MAX,</span></span><br><span class="line"><span class="params">    size, p, compat_mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="title function_">EVIOCGMTSLOTS</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">evdev_handle_mt_request</span><span class="params">(dev, size, ip)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="title function_">EVIOCGKEY</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">evdev_handle_get_val</span><span class="params">(client, dev, EV_KEY, dev-&gt;key,</span></span><br><span class="line"><span class="params">    KEY_MAX, size, p, compat_mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="title function_">EVIOCGLED</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">evdev_handle_get_val</span><span class="params">(client, dev, EV_LED, dev-&gt;led,</span></span><br><span class="line"><span class="params">    LED_MAX, size, p, compat_mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="title function_">EVIOCGSND</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">evdev_handle_get_val</span><span class="params">(client, dev, EV_SND, dev-&gt;snd,</span></span><br><span class="line"><span class="params">    SND_MAX, size, p, compat_mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="title function_">EVIOCGSW</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">evdev_handle_get_val</span><span class="params">(client, dev, EV_SW, dev-&gt;sw,</span></span><br><span class="line"><span class="params">    SW_MAX, size, p, compat_mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="title function_">EVIOCGNAME</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">str_to_user</span><span class="params">(dev-&gt;name, size, p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="title function_">EVIOCGPHYS</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">str_to_user</span><span class="params">(dev-&gt;phys, size, p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="title function_">EVIOCGUNIQ</span><span class="params">(<span class="number">0</span>)</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">str_to_user</span><span class="params">(dev-&gt;uniq, size, p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="title function_">EVIOC_MASK_SIZE</span><span class="params">(EVIOCSFF)</span>:</span><br><span class="line"><span class="title function_">if</span> <span class="params">(input_ff_effect_from_user(p, size, &amp;effect))</span></span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">error = input_ff_upload(dev, &amp;effect, file);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (put_user(effect.id, &amp;(((<span class="keyword">struct</span> ff_effect __user *)p)-&gt;id)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Multi-number variable-length handlers */</span></span><br><span class="line"><span class="keyword">if</span> (_IOC_TYPE(cmd) != <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_IOC_DIR(cmd) == _IOC_READ) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((_IOC_NR(cmd) &amp; ~EV_MAX) == _IOC_NR(EVIOCGBIT(<span class="number">0</span>, <span class="number">0</span>)))</span><br><span class="line"><span class="keyword">return</span> handle_eviocgbit(dev,</span><br><span class="line">_IOC_NR(cmd) &amp; EV_MAX, size,</span><br><span class="line">p, compat_mode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((_IOC_NR(cmd) &amp; ~ABS_MAX) == _IOC_NR(EVIOCGABS(<span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;absinfo)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">t = _IOC_NR(cmd) &amp; ABS_MAX;</span><br><span class="line"><span class="built_in">abs</span> = dev-&gt;absinfo[t];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(p, &amp;<span class="built_in">abs</span>, <span class="type">min_t</span>(<span class="type">size_t</span>,</span><br><span class="line">size, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> input_absinfo))))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_IOC_DIR(cmd) == _IOC_WRITE) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((_IOC_NR(cmd) &amp; ~ABS_MAX) == _IOC_NR(EVIOCSABS(<span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;absinfo)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">t = _IOC_NR(cmd) &amp; ABS_MAX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;<span class="built_in">abs</span>, p, <span class="type">min_t</span>(<span class="type">size_t</span>,</span><br><span class="line">size, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> input_absinfo))))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> input_absinfo))</span><br><span class="line"><span class="built_in">abs</span>.resolution = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We can&#x27;t change number of reserved MT slots */</span></span><br><span class="line"><span class="keyword">if</span> (t == ABS_MT_SLOT)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Take event lock to ensure that we are not</span></span><br><span class="line"><span class="comment"> * changing device parameters in the middle</span></span><br><span class="line"><span class="comment"> * of event.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">spin_lock_irq(&amp;dev-&gt;event_lock);</span><br><span class="line">dev-&gt;absinfo[t] = <span class="built_in">abs</span>;</span><br><span class="line">spin_unlock_irq(&amp;dev-&gt;event_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码中的这些命令解释如下</p><ul><li>EVIOCGVERSION: 获取去掉版本号</li><li>EVIOCGID：获取输入设备的 ID 信息</li><li>EVIOCSREP：获取按键重复设置</li><li>EVIOCGKEYCODE: 获取按键码</li><li>EVIOCGKEYCODE_V2: 获取按键映射表</li><li>EVIOCSKEYCODE：设置按键值</li><li>EVIOCSKEYCODE_V2：设置按键映射表</li><li>EVIOCGNAME(len)：获取设备名称</li><li>EVIOCGPHYS(len)：获取物理位置</li><li>EVIOCGUNIQ(len)：获取唯一标识符</li><li>EVIOCGPROP(len)：获取设备属性</li><li>EVIOCGMTSLOTS(len)：获取多点触控信息</li><li>EVIOCGKEY(len)：获取全局按键状态</li><li>EVIOCGLED(len)：获取所有 LED 状态</li><li>EVIOCGSND(len)：获取所有声音状态</li><li>EVIOCGSW(len)：获取所有开关状态</li><li>EVIOCGBIT(ev,len)：获取事件位图</li><li>EVIOCGABS(abs)：获取绝对值/范围</li><li>EVIOCSABS(abs)：设置绝对值/范围</li><li>EVIOCSFF：发送力反馈效果到力反馈设备</li><li>EVIOCRMFF：删除力反馈效果</li><li>EVIOCGEFFECTS：报告同时可播放的效果数量</li><li>EVIOCGRAB：占用/释放输入设备</li><li>EVIOCREVOKE：撤销设备访问权限</li><li>EVIOCGMASK：检索当前事件掩码</li><li>EVIOCSMASK：设置事件掩码</li><li>EVIOCSCLOCKID：设置用于时间戳的时钟标识</li></ul><h4 id="poll-函数分析"><a href="#poll-函数分析" class="headerlink" title="poll 函数分析"></a>poll 函数分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* No kernel lock - fine */</span></span><br><span class="line"><span class="type">static</span> <span class="type">__poll_t</span> <span class="title function_">evdev_poll</span><span class="params">(<span class="keyword">struct</span> file *file, poll_table *wait)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取文件私有数据中的 evdev_client 结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;</span><br><span class="line">    <span class="comment">// 获取 evdev_client 结构体中的 evdev 指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> client-&gt;evdev;</span><br><span class="line"><span class="type">__poll_t</span> mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前进程加入到等待队列中，等待 evdev-&gt;wait 的唤醒事件</span></span><br><span class="line">poll_wait(file, &amp;client-&gt;wait, wait);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 evdev-&gt;exist 和 client-&gt;revoked 的值</span></span><br><span class="line"><span class="keyword">if</span> (evdev-&gt;exist &amp;&amp; !client-&gt;revoked)</span><br><span class="line">        <span class="comment">// 如果 evdev 存在且 client 未被撤销，设置 mask 为 EPOLLOUT | EPOLLWRNORM</span></span><br><span class="line">mask = EPOLLOUT | EPOLLWRNORM;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，设置 mask 为 EPOLLHUP | EPOLLERR</span></span><br><span class="line">mask = EPOLLHUP | EPOLLERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 client 中的 packet_head 和 tail 的值</span></span><br><span class="line"><span class="keyword">if</span> (client-&gt;packet_head != client-&gt;tail)</span><br><span class="line">        <span class="comment">// 如果 packet_head 和 tail 不相等，设置 mask 为 mask | EPOLLIN | EPOLLRDNORM</span></span><br><span class="line">mask |= EPOLLIN | EPOLLRDNORM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="fasync-函数分析"><a href="#fasync-函数分析" class="headerlink" title="fasync 函数分析"></a>fasync 函数分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">evdev_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取文件私有数据中的 evdev_client 结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 fasync_helper 函数来处理进程的异步通知</span></span><br><span class="line"><span class="comment">// 该函数会根据 on 的值，将进程添加到或从异步通知的列表中</span></span><br><span class="line"><span class="comment">// 并将通知相关的数据存储在 client-&gt;fasync </span></span><br><span class="line"><span class="keyword">return</span> fasync_helper(fd, file, on, &amp;client-&gt;fasync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="llseek-函数分析"><a href="#llseek-函数分析" class="headerlink" title="llseek 函数分析"></a>llseek 函数分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">loff_t</span> <span class="title function_">no_llseek</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">loff_t</span> offset, <span class="type">int</span> whence)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> -ESPIPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>-ESPIPE</code> 作为返回值直接返回。这个函数的作用是阻止对设备文件执行 llseek 操作，也就是不允许通过改变文件位置指针来随机访问设备文件。</p><h4 id="release-函数分析"><a href="#release-函数分析" class="headerlink" title="release 函数分析"></a>release 函数分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">evdev_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取文件私有数据中的 evdev_client 结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;</span><br><span class="line">    <span class="comment">// 获取 evdev_client 结构体中的 evdev 指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> client-&gt;evdev;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 evdev 的互斥锁，确保对 evdev 的操作是原子的</span></span><br><span class="line">mutex_lock(&amp;evdev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 evdev-&gt;exist 和 client-&gt;revoked 的值</span></span><br><span class="line"><span class="keyword">if</span> (evdev-&gt;exist &amp;&amp; !client-&gt;revoked)</span><br><span class="line">        <span class="comment">// 如果 evdev 存在且 client 未被撤销，调用 input_flush_device 函数刷新设备的输入缓冲区</span></span><br><span class="line">input_flush_device(&amp;evdev-&gt;handle, file);</span><br><span class="line"><span class="comment">// 释放 evdev 的抢占状态，将客户端从抢占列表中移除</span></span><br><span class="line">evdev_ungrab(evdev, client);</span><br><span class="line">    <span class="comment">// 解锁 evdev 的互斥锁</span></span><br><span class="line">mutex_unlock(&amp;evdev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 evdev 中分离并释放客户端</span></span><br><span class="line">evdev_detach_client(evdev, client);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放客户端的事件掩码内存</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; EV_CNT; ++i)</span><br><span class="line">bitmap_free(client-&gt;evmasks[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放客户端的内存</span></span><br><span class="line">kvfree(client);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭 evdev 设备</span></span><br><span class="line">evdev_close_device(evdev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数据上报流程"><a href="#数据上报流程" class="headerlink" title="数据上报流程"></a>数据上报流程</h3><p>使用读函数来读取输入设备上报的数据时，驱动程序中的文件操作集会执行 <code>evdev_read</code> 函数。同样地，当我们使用写函数向输入设备写入数据时，驱动程序中的文件操作集会执行 <code>evdev_write</code> 函数。</p><p>设备输入层负责处理输入设备的数据，并将其传递给驱动程序。当输入设备上报数据时，设备输入层会接收到这些数据，并将其转发给注册的驱动程序。</p><h4 id="event-函数分析"><a href="#event-函数分析" class="headerlink" title="event 函数分析"></a>event 函数分析</h4><h5 id="input-event-1"><a href="#input-event-1" class="headerlink" title="input_event()"></a>input_event()</h5><p>上报事件时需要调用<code>input_event</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input_event() - report new input event</span></span><br><span class="line"><span class="comment"> * @dev: device that generated the event</span></span><br><span class="line"><span class="comment"> * @type: type of the event</span></span><br><span class="line"><span class="comment"> * @code: event code</span></span><br><span class="line"><span class="comment"> * @value: value of the event</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function should be used by drivers implementing various input</span></span><br><span class="line"><span class="comment"> * devices to report input events. See also input_inject_event().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> input_event() may be safely used right after input device was</span></span><br><span class="line"><span class="comment"> * allocated with input_allocate_device(), even before it is registered</span></span><br><span class="line"><span class="comment"> * with input_register_device(), but the event will not reach any of the</span></span><br><span class="line"><span class="comment"> * input handlers. Such early invocation of input_event() may be used</span></span><br><span class="line"><span class="comment"> * to &#x27;seed&#x27; initial state of a switch or initial position of absolute</span></span><br><span class="line"><span class="comment"> * axis, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params"> <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">// 用于保存中断标志</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 检查输入设备是否支持指定的事件类型</span></span><br><span class="line"><span class="keyword">if</span> (is_event_supported(type, dev-&gt;evbit, EV_MAX)) &#123;</span><br><span class="line"><span class="comment">// 获取事件锁，确保对事件的处理是原子的</span></span><br><span class="line">spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">        <span class="comment">// 调用 input_handle_event 函数处理输入事件</span></span><br><span class="line">input_handle_event(dev, type, code, value);</span><br><span class="line">        <span class="comment">// 释放事件锁</span></span><br><span class="line">spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(input_event);</span><br></pre></td></tr></table></figure><h5 id="input-handle-event"><a href="#input-handle-event" class="headerlink" title="input_handle_event()"></a>input_handle_event()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">input_handle_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params">       <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取输入事件的处理方式, 即判断事件是应该被忽略、传递给设备还是传递给处理程序</span></span><br><span class="line"><span class="type">int</span> disposition = input_get_disposition(dev, type, code, &amp;value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果事件不应被忽略且不是 EV_SYN 类型的事件，则将事件的类型、代码和值添加到输入随机数池中</span></span><br><span class="line"><span class="keyword">if</span> (disposition != INPUT_IGNORE_EVENT &amp;&amp; type != EV_SYN)</span><br><span class="line">add_input_randomness(type, code, value);</span><br><span class="line"><span class="comment">// 如果事件应该传递给设备且设备有事件处理函数，则调用事件处理函数</span></span><br><span class="line"><span class="keyword">if</span> ((disposition &amp; INPUT_PASS_TO_DEVICE) &amp;&amp; dev-&gt;event)</span><br><span class="line">dev-&gt;event(dev, type, code, value);</span><br><span class="line"><span class="comment">// 如果输入设备没有值列表，则直接返回</span></span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;vals)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 如果事件应该传递给处理程序</span></span><br><span class="line"><span class="keyword">if</span> (disposition &amp; INPUT_PASS_TO_HANDLERS) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果事件需要传递给处理程序的槽位，则将槽位信息添加到值列表中</span></span><br><span class="line"><span class="keyword">if</span> (disposition &amp; INPUT_SLOT) &#123;</span><br><span class="line">v = &amp;dev-&gt;vals[dev-&gt;num_vals++];</span><br><span class="line">v-&gt;type = EV_ABS;</span><br><span class="line">v-&gt;code = ABS_MT_SLOT;</span><br><span class="line">v-&gt;value = dev-&gt;mt-&gt;slot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将事件的类型、代码和值添加到值列表中</span></span><br><span class="line">v = &amp;dev-&gt;vals[dev-&gt;num_vals++];</span><br><span class="line">v-&gt;type = type;</span><br><span class="line">v-&gt;code = code;</span><br><span class="line">v-&gt;value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果事件需要刷新值列表</span></span><br><span class="line"><span class="keyword">if</span> (disposition &amp; INPUT_FLUSH) &#123;</span><br><span class="line">        <span class="comment">// 如果值列表中的值大于等于 2，则传递值列表中的值给设备的处理函数</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;num_vals &gt;= <span class="number">2</span>)</span><br><span class="line">input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals);</span><br><span class="line">dev-&gt;num_vals = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reset the timestamp on flush so we won&#x27;t end up</span></span><br><span class="line"><span class="comment"> * with a stale one. Note we only need to reset the</span></span><br><span class="line"><span class="comment"> * monolithic one as we use its presence when deciding</span></span><br><span class="line"><span class="comment"> * whether to generate a synthetic timestamp.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 重置刷新时的时间戳，以避免出现过时的时间戳。</span></span><br><span class="line"><span class="comment">* 注意，我们只需要重置单一时间戳（INPUT_CLK_MONO），</span></span><br><span class="line"><span class="comment">* 因为在决定是否生成合成时间戳时，我们使用它的存在。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dev-&gt;timestamp[INPUT_CLK_MONO] = ktime_set(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;num_vals &gt;= dev-&gt;max_vals - <span class="number">2</span>) &#123;<span class="comment">// 如果值列表中的值大于等于设备的最大值减去 2</span></span><br><span class="line">        <span class="comment">// 将同步事件添加到值列表中</span></span><br><span class="line">dev-&gt;vals[dev-&gt;num_vals++] = input_value_sync;</span><br><span class="line">        <span class="comment">// 传递值列表中的值给设备的处理函数</span></span><br><span class="line">input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals);</span><br><span class="line">dev-&gt;num_vals = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="input-get-disposition"><a href="#input-get-disposition" class="headerlink" title="input_get_disposition()"></a>input_get_disposition()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">input_get_disposition</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> *pval)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> disposition = INPUT_IGNORE_EVENT;<span class="comment">// 事件的处理方式，默认为忽略</span></span><br><span class="line"><span class="type">int</span> value = *pval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EV_SYN:</span><br><span class="line"><span class="keyword">switch</span> (code) &#123;</span><br><span class="line"><span class="keyword">case</span> SYN_CONFIG:</span><br><span class="line">disposition = INPUT_PASS_TO_ALL;<span class="comment">// 将事件传递给所有处理程序</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SYN_REPORT:</span><br><span class="line">disposition = INPUT_PASS_TO_HANDLERS | INPUT_FLUSH;<span class="comment">// 将事件传递给处理程序，并刷新值列表</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SYN_MT_REPORT:</span><br><span class="line">disposition = INPUT_PASS_TO_HANDLERS;<span class="comment">// 将事件传递给处理程序</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EV_KEY:</span><br><span class="line"><span class="keyword">if</span> (is_event_supported(code, dev-&gt;keybit, KEY_MAX)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* auto-repeat bypasses state updates */</span></span><br><span class="line">            <span class="comment">// 自动重复事件不更新状态，直接传递给处理程序</span></span><br><span class="line"><span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">disposition = INPUT_PASS_TO_HANDLERS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断按键状态是否改变，若改变则更新状态并传递给处理程序</span></span><br><span class="line"><span class="keyword">if</span> (!!test_bit(code, dev-&gt;key) != !!value) &#123;</span><br><span class="line"></span><br><span class="line">__change_bit(code, dev-&gt;key);</span><br><span class="line">disposition = INPUT_PASS_TO_HANDLERS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EV_SW:</span><br><span class="line"><span class="keyword">if</span> (is_event_supported(code, dev-&gt;swbit, SW_MAX) &amp;&amp;</span><br><span class="line">    !!test_bit(code, dev-&gt;sw) != !!value) &#123;</span><br><span class="line"><span class="comment">// 判断开关状态是否改变，若改变则更新状态并传递给处理程序</span></span><br><span class="line">__change_bit(code, dev-&gt;sw);</span><br><span class="line">disposition = INPUT_PASS_TO_HANDLERS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EV_ABS:</span><br><span class="line"><span class="keyword">if</span> (is_event_supported(code, dev-&gt;absbit, ABS_MAX))</span><br><span class="line">disposition = input_handle_abs_event(dev, code, &amp;value);<span class="comment">// 处理绝对事件的特殊情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EV_REL:</span><br><span class="line"><span class="keyword">if</span> (is_event_supported(code, dev-&gt;relbit, REL_MAX) &amp;&amp; value)</span><br><span class="line">disposition = INPUT_PASS_TO_HANDLERS;<span class="comment">// 将事件传递给处理程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EV_MSC:</span><br><span class="line"><span class="keyword">if</span> (is_event_supported(code, dev-&gt;mscbit, MSC_MAX))</span><br><span class="line">disposition = INPUT_PASS_TO_ALL;<span class="comment">// 将事件传递给所有处理程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EV_LED:</span><br><span class="line"><span class="keyword">if</span> (is_event_supported(code, dev-&gt;ledbit, LED_MAX) &amp;&amp;</span><br><span class="line">    !!test_bit(code, dev-&gt;led) != !!value) &#123;</span><br><span class="line"><span class="comment">// 判断 LED 状态是否改变，若改变则更新状态并传递给所有处理程序</span></span><br><span class="line">__change_bit(code, dev-&gt;led);</span><br><span class="line">disposition = INPUT_PASS_TO_ALL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EV_SND:</span><br><span class="line"><span class="keyword">if</span> (is_event_supported(code, dev-&gt;sndbit, SND_MAX)) &#123;</span><br><span class="line"><span class="comment">// 判断声音状态是否改变，若改变则更新状态并传递给所有处理程序</span></span><br><span class="line"><span class="keyword">if</span> (!!test_bit(code, dev-&gt;snd) != !!value)</span><br><span class="line">__change_bit(code, dev-&gt;snd);</span><br><span class="line">disposition = INPUT_PASS_TO_ALL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EV_REP:</span><br><span class="line"><span class="keyword">if</span> (code &lt;= REP_MAX &amp;&amp; value &gt;= <span class="number">0</span> &amp;&amp; dev-&gt;rep[code] != value) &#123;</span><br><span class="line">            <span class="comment">// 更新重复事件的设置，并将事件传递给所有处理程序</span></span><br><span class="line">dev-&gt;rep[code] = value;</span><br><span class="line">disposition = INPUT_PASS_TO_ALL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EV_FF:</span><br><span class="line"><span class="keyword">if</span> (value &gt;= <span class="number">0</span>)</span><br><span class="line">disposition = INPUT_PASS_TO_ALL;<span class="comment">// 将事件传递给所有处理程序</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> EV_PWR:</span><br><span class="line">disposition = INPUT_PASS_TO_ALL;<span class="comment">// 将事件传递给所有处理程序</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pval = value; <span class="comment">// 将事件的值更新为处理后的值</span></span><br><span class="line"><span class="keyword">return</span> disposition; <span class="comment">// 返回事件的处理方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该函数用于根据输入设备的类型、代码和值，确定事件的处理方式。首先，根据事件的类型进行分支判断。每个分支中会根据事件的类型和代码判断事件的处理方式，并相应地更新 disposition（事件的处理方式）。disposition 有以下几种方式</p><ul><li><code>INPUT_IGNORE_EVENT</code>：表示忽略该输入事件，不进行任何处理</li><li><code>INPUT_PASS_TO_HANDLERS</code> ：表示将输入事件传递给处理程序进行处理。处理程序可以是输入驱动程序中的回调函数，也可以是用户空间的应用程序或服务进程。</li><li><code>INPUT_PASS_TO_DEVICE</code> ：表示将输入事件传递给设备进行处理。设备可能包括物理设备（如键盘，鼠标）或虚拟设备（如触摸屏模拟器）。</li><li><code>INPUT_SLOT</code>：用于触摸屏模拟器，表示输入事件是触摸屏幕上的特定槽位的事件，通常，在处理多点触摸事件时，每个触点都对应一个槽位。</li><li><code>INPUT_FLUSH</code>：表示需要刷新输入事件队列。当输入事件队列积累到一定数量或满时，以使用此标志刷新队列，将事件传递给设备进行处理。</li><li><code>INPUT_PASS_TO_ALL</code> (<code>INPUT_PASS_TO_HANDLERS</code> | <code>INPUT_PASS_TO_DEVICE</code>)：表示将输入事件同时传递给处理程序和设备进行处理，即综合使用 <code>INPUT_PASS_TO_HANDLERS</code> 和 <code>INPUT_PASS_TO_DEVICE</code> 的功能。</li></ul><h5 id="input-pass-values"><a href="#input-pass-values" class="headerlink" title="input_pass_values()"></a>input_pass_values()</h5><p>该函数用于将输入设备的值传递给相应的句柄进行处理，并触发按键事件的自动重复。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pass values first through all filters and then, if event has not been</span></span><br><span class="line"><span class="comment"> * filtered out, through all open handles. This function is called with</span></span><br><span class="line"><span class="comment"> * dev-&gt;event_lock held and interrupts disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">input_pass_values</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> input_value *vals, <span class="type">unsigned</span> <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> *<span class="title">handle</span>;</span><span class="comment">// 输入设备的句柄</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span><span class="comment">// 当前处理的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!count)</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">// 如果值的数量为 0，则直接返回</span></span><br><span class="line"></span><br><span class="line">rcu_read_lock();<span class="comment">// 读取 RCU 锁</span></span><br><span class="line"></span><br><span class="line">handle = rcu_dereference(dev-&gt;grab);<span class="comment">// 获取设备的句柄</span></span><br><span class="line"><span class="keyword">if</span> (handle) &#123;</span><br><span class="line">count = input_to_handler(handle, vals, count);<span class="comment">// 将值传递给句柄进行处理，并更新值的数量</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历设备的句柄列表，将值传递给每个已打开的句柄进行处理，并更新值的数量</span></span><br><span class="line">list_for_each_entry_rcu(handle, &amp;dev-&gt;h_list, d_node)</span><br><span class="line"><span class="keyword">if</span> (handle-&gt;open) &#123;</span><br><span class="line">count = input_to_handler(handle, vals, count);</span><br><span class="line"><span class="keyword">if</span> (!count)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rcu_read_unlock();<span class="comment">// 解锁 RCU 锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* trigger auto repeat for key events */</span></span><br><span class="line">    <span class="comment">/* 触发按键事件的自动重复 */</span></span><br><span class="line"><span class="keyword">if</span> (test_bit(EV_REP, dev-&gt;evbit) &amp;&amp; test_bit(EV_KEY, dev-&gt;evbit)) &#123;</span><br><span class="line">        <span class="comment">// 遍历值列表，对于类型为 EV_KEY 且值不为 2 的事件：</span></span><br><span class="line">        <span class="comment">// 如果值为真，则启动按键的自动重复；</span></span><br><span class="line">        <span class="comment">// 如果值为假，则停止按键的自动重复</span></span><br><span class="line"><span class="keyword">for</span> (v = vals; v != vals + count; v++) &#123;</span><br><span class="line"><span class="keyword">if</span> (v-&gt;type == EV_KEY &amp;&amp; v-&gt;value != <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (v-&gt;value)</span><br><span class="line">input_start_autorepeat(dev, v-&gt;code);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">input_stop_autorepeat(dev);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="input-to-handler"><a href="#input-to-handler" class="headerlink" title="input_to_handler()"></a>input_to_handler()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pass event first through all filters and then, if event has not been</span></span><br><span class="line"><span class="comment"> * filtered out, through all open handles. This function is called with</span></span><br><span class="line"><span class="comment"> * dev-&gt;event_lock held and interrupts disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">input_to_handler</span><span class="params">(<span class="keyword">struct</span> input_handle *handle,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> input_value *vals, <span class="type">unsigned</span> <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> =</span> handle-&gt;handler; <span class="comment">// 输入句柄对应的处理程序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">end</span> =</span> vals; <span class="comment">// 已处理的值的末尾</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span> <span class="comment">// 当前处理的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handler-&gt;filter) &#123;</span><br><span class="line">        <span class="comment">// 如果处理程序定义了过滤器函数，则对值列表中的每个值进行过滤</span></span><br><span class="line"><span class="keyword">for</span> (v = vals; v != vals + count; v++) &#123;</span><br><span class="line"><span class="keyword">if</span> (handler-&gt;filter(handle, v-&gt;type, v-&gt;code, v-&gt;value))</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">// 如果过滤器函数返回真，则跳过当前值</span></span><br><span class="line"><span class="keyword">if</span> (end != v)</span><br><span class="line">*end = *v;<span class="comment">// 将当前值复制到已处理的值的末尾</span></span><br><span class="line">end++;</span><br><span class="line">&#125;</span><br><span class="line">count = end - vals;<span class="comment">// 更新处理后的值的数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!count)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 如果处理后的值的数量为 0，则直接返回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handler-&gt;events)</span><br><span class="line">handler-&gt;events(handle, vals, count);<span class="comment">// 如果处理程序定义了事件处理函数，则将处理后的值传递给事件处理函数</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (handler-&gt;event)<span class="comment">//// 如果处理程序定义了单个事件处理函数，则对每个值调用事件处理函数</span></span><br><span class="line"><span class="keyword">for</span> (v = vals; v != vals + count; v++)</span><br><span class="line">handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到：根据处理程序的定义，如果定义了事件处理函数（events 不为 NULL），它将处理后的值传递给事件处理函数。否则，如果只定义了单个事件处理函数（event 不为 NULL），它将对每个值调用事件处理函数，传递句柄、类型、代码和值作为参数。</p><h5 id="evdev-event"><a href="#evdev-event" class="headerlink" title="evdev_event()"></a>evdev_event()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">evdev_event</span><span class="params">(<span class="keyword">struct</span> input_handle *handle,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> <span class="title">vals</span>[] =</span> &#123; &#123; type, code, value &#125; &#125;;</span><br><span class="line"></span><br><span class="line">evdev_events(handle, vals, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>edev_event</code>就是调用<code>evdev_events</code></p><h5 id="evdev-events"><a href="#evdev-events" class="headerlink" title="evdev_events()"></a>evdev_events()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pass incoming events to all connected clients.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">evdev_events</span><span class="params">(<span class="keyword">struct</span> input_handle *handle,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="keyword">struct</span> input_value *vals, <span class="type">unsigned</span> <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> handle-&gt;private;<span class="comment">// 获取输入句柄的私有数据，这里是 evdev 结构体类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span>;</span><span class="comment">// 定义 evdev 客户端指针</span></span><br><span class="line"><span class="type">ktime_t</span> *ev_time = input_get_timestamp(handle-&gt;dev);<span class="comment">// 获取输入设备的时间戳</span></span><br><span class="line"></span><br><span class="line">rcu_read_lock();<span class="comment">// 开始读取 RCU 保护区域</span></span><br><span class="line"></span><br><span class="line">client = rcu_dereference(evdev-&gt;grab);<span class="comment">// RCU 安全地获取当前的 evdev 客户端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (client)<span class="comment">// 如果存在抢占的客户端，则将值传递给抢占的客户端</span></span><br><span class="line">evdev_pass_values(client, vals, count, ev_time);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">list_for_each_entry_rcu(client, &amp;evdev-&gt;client_list, node)</span><br><span class="line">evdev_pass_values(client, vals, count, ev_time);<span class="comment">// 否则，将值传递给所有注册的客户端</span></span><br><span class="line"></span><br><span class="line">rcu_read_unlock();<span class="comment">// 结束读取 RCU 保护区域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="edev-pass-values"><a href="#edev-pass-values" class="headerlink" title="edev_pass_values()"></a>edev_pass_values()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">evdev_pass_values</span><span class="params">(<span class="keyword">struct</span> evdev_client *client,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="keyword">struct</span> input_value *vals, <span class="type">unsigned</span> <span class="type">int</span> count,</span></span><br><span class="line"><span class="params"><span class="type">ktime_t</span> *ev_time)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span><span class="comment">// 当前处理的输入值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span><span class="comment">// 输入事件结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">ts</span>;</span><span class="comment">// 时间戳</span></span><br><span class="line"><span class="type">bool</span> wakeup = <span class="literal">false</span>;<span class="comment">// 是否需要唤醒等待线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (client-&gt;revoked)</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">// 如果客户端已被撤销，则直接返回</span></span><br><span class="line"></span><br><span class="line">ts = ktime_to_timespec64(ev_time[client-&gt;clk_type]);<span class="comment">// 将 ev_time 转换为 struct timespec64 类型的时间戳</span></span><br><span class="line">event.input_event_sec = ts.tv_sec;<span class="comment">// 输入事件的秒字段设置为时间戳的秒值</span></span><br><span class="line">event.input_event_usec = ts.tv_nsec / NSEC_PER_USEC;<span class="comment">// 输入事件的微秒字段设置为时间戳的纳秒值除以 1000 得到的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Interrupts are disabled, just acquire the lock. */</span></span><br><span class="line">    <span class="comment">/* 关中断，只需获取锁即可。 */</span></span><br><span class="line">spin_lock(&amp;client-&gt;buffer_lock);<span class="comment">// 获取客户端的缓冲区锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (v = vals; v != vals + count; v++) &#123;</span><br><span class="line"><span class="keyword">if</span> (__evdev_is_filtered(client, v-&gt;type, v-&gt;code))</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">// 如果输入值被过滤，则跳过当前值的处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (v-&gt;type == EV_SYN &amp;&amp; v-&gt;code == SYN_REPORT) &#123;</span><br><span class="line"><span class="comment">/* drop empty SYN_REPORT */</span></span><br><span class="line">            <span class="comment">/* 丢弃空的 SYN_REPORT */</span></span><br><span class="line"><span class="keyword">if</span> (client-&gt;packet_head == client-&gt;head)</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">// 如果客户端的数据包头和数据头相同，则跳过当前值的处理</span></span><br><span class="line"></span><br><span class="line">wakeup = <span class="literal">true</span>;<span class="comment">// 设置唤醒标志为真</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.type = v-&gt;type;<span class="comment">// 设置输入事件的类型字段为当前值的类型</span></span><br><span class="line">event.code = v-&gt;code;<span class="comment">// 设置输入事件的代码字段为当前值的代码</span></span><br><span class="line">event.value = v-&gt;value;<span class="comment">// 设置输入事件的值字段为当前值的值</span></span><br><span class="line">__pass_event(client, &amp;event);<span class="comment">// 将输入事件传递给客户端的事件处理函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;client-&gt;buffer_lock);<span class="comment">// 释放客户端的缓冲区锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (wakeup)<span class="comment">// 如果需要唤醒等待线程，则唤醒等待队列中的线程</span></span><br><span class="line">wake_up_interruptible_poll(&amp;client-&gt;wait,</span><br><span class="line">EPOLLIN | EPOLLOUT | EPOLLRDNORM | EPOLLWRNORM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="pass-event"><a href="#pass-event" class="headerlink" title="__pass_event()"></a>__pass_event()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __pass_event(<span class="keyword">struct</span> evdev_client *client,</span><br><span class="line"> <span class="type">const</span> <span class="keyword">struct</span> input_event *event)</span><br><span class="line">&#123;</span><br><span class="line">client-&gt;buffer[client-&gt;head++] = *event;<span class="comment">// 将事件复制到客户端的缓冲区中，然后将缓冲区头指针递增</span></span><br><span class="line">client-&gt;head &amp;= client-&gt;bufsize - <span class="number">1</span>; <span class="comment">// 将缓冲区头指针掩码处理，确保其在缓冲区范围内</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(client-&gt;head == client-&gt;tail)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This effectively &quot;drops&quot; all unconsumed events, leaving</span></span><br><span class="line"><span class="comment"> * EV_SYN/SYN_DROPPED plus the newest event in the queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这实际上&quot;丢弃&quot;了所有未消耗的事件，只保留了 EV_SYN/SYN_DROPPED 加上最新的事件。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">client-&gt;tail = (client-&gt;head - <span class="number">2</span>) &amp; (client-&gt;bufsize - <span class="number">1</span>);<span class="comment">// 更新缓冲区尾指针，使其指向倒数第二个事件</span></span><br><span class="line"></span><br><span class="line">client-&gt;buffer[client-&gt;tail] = (<span class="keyword">struct</span> input_event) &#123;</span><br><span class="line">.input_event_sec = event-&gt;input_event_sec,</span><br><span class="line">.input_event_usec = event-&gt;input_event_usec,</span><br><span class="line">.type = EV_SYN,</span><br><span class="line">.code = SYN_DROPPED,</span><br><span class="line">.value = <span class="number">0</span>,</span><br><span class="line">&#125;;<span class="comment">// 在缓冲区尾指针位置插入一个 EV_SYN/SYN_DROPPED 事件，表示丢弃了事件</span></span><br><span class="line"></span><br><span class="line">client-&gt;packet_head = client-&gt;tail;<span class="comment">// 更新数据包头指针为缓冲区尾指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (event-&gt;type == EV_SYN &amp;&amp; event-&gt;code == SYN_REPORT) &#123;</span><br><span class="line">client-&gt;packet_head = client-&gt;head;<span class="comment">// 更新数据包头指针为缓冲区头指针</span></span><br><span class="line">kill_fasync(&amp;client-&gt;fasync, SIGIO, POLL_IN);<span class="comment">// 向注册的异步通知处理函数发送 SIGIO 信号，通知有新的事件可读取</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="read-函数分析"><a href="#read-函数分析" class="headerlink" title="read 函数分析"></a>read 函数分析</h4><p>驱动程序可以通过注册到设备输入层的回调函数来获取输入设备上报的数据。在驱动程序中，<code>evdev_read</code> 函数就是用于从设备输入层获取输入设备上报的数据的函数。</p><h5 id="edev-read"><a href="#edev-read" class="headerlink" title="edev_read()"></a>edev_read()</h5><p><code>edev_read()</code>从 evdev 设备读取输入事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">evdev_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buffer,</span></span><br><span class="line"><span class="params">  <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;<span class="comment">// 获取文件私有数据中的 evdev 客户端结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> client-&gt;evdev;<span class="comment">// 获取客户端结构体中的 evdev 结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span><span class="comment">// 定义一个输入事件结构体</span></span><br><span class="line"><span class="type">size_t</span> read = <span class="number">0</span>;<span class="comment">// 已读取的字节数</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count != <span class="number">0</span> &amp;&amp; count &lt; input_event_size())</span><br><span class="line"><span class="keyword">return</span> -EINVAL;<span class="comment">// 如果 count 不为 0 且小于输入事件大小，返回无效参数错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;<span class="comment">// 循环读取输入事件并将其复制到用户空间缓冲区中</span></span><br><span class="line"><span class="keyword">if</span> (!evdev-&gt;exist || client-&gt;revoked)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;<span class="comment">// 如果 evdev 设备不存在或客户端已撤销，则返回设备不存在错误码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (client-&gt;packet_head == client-&gt;tail &amp;&amp;</span><br><span class="line">    (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line"><span class="keyword">return</span> -EAGAIN;<span class="comment">// 如果数据包头等于尾且文件标志中设置了非阻塞标志，返回暂无数据可读错误码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * count == 0 is special - no IO is done but we check</span></span><br><span class="line"><span class="comment"> * for error conditions (see above).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>)<span class="comment">// 如果 count 为 0，退出循环，不执行 IO 操作，但仍检查错误条件</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (read + input_event_size() &lt;= count &amp;&amp;</span><br><span class="line">       evdev_fetch_next_event(client, &amp;event)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (input_event_to_user(buffer + read, &amp;event))<span class="comment">// 将输入事件数据复制到用户空间缓冲区中</span></span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">read += input_event_size();<span class="comment">// 更新已读取的字节数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (read)</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">// 如果已读取的字节数大于 0，退出循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(file-&gt;f_flags &amp; O_NONBLOCK)) &#123;</span><br><span class="line">error = wait_event_interruptible(client-&gt;wait,</span><br><span class="line">client-&gt;packet_head != client-&gt;tail ||</span><br><span class="line">!evdev-&gt;exist || client-&gt;revoked);<span class="comment">// 等待事件的发生，阻塞当前线程</span></span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;<span class="comment">// 如果等待被中断，返回错误码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> read;<span class="comment">// 返回已读取的字节数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="write-函数分析"><a href="#write-函数分析" class="headerlink" title="write 函数分析"></a>write 函数分析</h4><p>当我们在应用程序中使用写函数向输入设备写入数据时，输入数据会被传递到驱动程序的 <code>evdev_write</code> 函数。驱动程序可以根据需要对这些写入的数据进行处理和响应。</p><h5 id="edev-write"><a href="#edev-write" class="headerlink" title="edev_write()"></a>edev_write()</h5><p>该函数将输入事件写入到 evdev 设备的缓冲区中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">evdev_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer,</span></span><br><span class="line"><span class="params">   <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;<span class="comment">// 获取文件私有数据中的 evdev 客户端结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> =</span> client-&gt;evdev;<span class="comment">// 获取客户端结构体中的 evdev 结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span><span class="comment">// 定义一个输入事件结构体</span></span><br><span class="line"><span class="type">int</span> retval = <span class="number">0</span>;<span class="comment">// 返回值变量，默认为 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count != <span class="number">0</span> &amp;&amp; count &lt; input_event_size())</span><br><span class="line"><span class="keyword">return</span> -EINVAL;<span class="comment">// 如果 count 不为 0 且小于输入事件大小，返回无效参数错误</span></span><br><span class="line"></span><br><span class="line">retval = mutex_lock_interruptible(&amp;evdev-&gt;mutex);<span class="comment">// 对 evdev 的互斥锁进行上锁，可中断</span></span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">return</span> retval;<span class="comment">// 如果上锁失败，返回错误码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!evdev-&gt;exist || client-&gt;revoked) &#123;<span class="comment">// 如果 evdev 设备不存在或客户端已撤销，则返回设备不存在的错误码</span></span><br><span class="line">retval = -ENODEV;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (retval + input_event_size() &lt;= count) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (input_event_from_user(buffer + retval, &amp;event)) &#123;<span class="comment">// 从用户空间复制输入事件到 event 结构体中</span></span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">retval += input_event_size();<span class="comment">// 更新 retval，增加一个输入事件的大小</span></span><br><span class="line"></span><br><span class="line">input_inject_event(&amp;evdev-&gt;handle,</span><br><span class="line">   event.type, event.code, event.value);<span class="comment">// 将输入事件注入到evdev 事件处理器中</span></span><br><span class="line">cond_resched();<span class="comment">// 条件调度，让出 CPU 给其他线程执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">mutex_unlock(&amp;evdev-&gt;mutex);<span class="comment">// 解锁 evdev 的互斥锁</span></span><br><span class="line"><span class="keyword">return</span> retval;<span class="comment">// 返回 retval 作为写入的字节数或错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="核心层代码分析"><a href="#核心层代码分析" class="headerlink" title="核心层代码分析"></a>核心层代码分析</h2><p>输入子系统的核心层主要由 <code>kernel/drivers/input/input.c</code> 文件实现的，它是 Linux 内核中处理输入设备的关键组件之一。input.c 文件负责注册，管理和处理输入设备，提供与输入设备相关的核心功能和接口。</p><p>核心层的主要作用如下：</p><ol><li><strong>设备注册和管理</strong>：核心层负责注册和管理输入设备。它通过与设备驱动程序进行交互，将输入设备与相应的驱动程序进行匹配，并创建与设备相关的数据结构。这些数据结构包含设备的状态，属性和操作函数等信息。</li><li><strong>事件处理</strong>：核心层负责处理输入设备产生的事件。当输入设备发生触摸，按键或其他操作时，核心层会收到相应的事件数据，并进行处理。它将事件数据传递给上层应用程序或其他子系统，以便实现相应的交互操作。</li><li><strong>事件分发</strong>：核心层负责将事件分发给注册了对应设备的应用程序或子系统。它根据设备的类型和属性，将事件传递给相应的处理程序。这样，应用程序或子系统就可以根据事件类型来执行相应的操作，例如处理触摸事件，响应按键输入等。</li><li><strong>设备节点管理</strong>：核心层负责创建和管理输入设备的设备节点。设备节点通常位于<code>/dev/input</code>目录下，提供了对输入设备的访问接口。核心层会根据设备的类型和属性，在设备节点中创建相应的信息，并确保设备节点的正确性和一致性。</li><li><strong>设备驱动程序的接口</strong>：核心层为设备驱动程序提供了接口，使其可以与输入子系统进行交互。驱动程序可以通过注册回调函数等方式，与核心层进行通信和数据交换，实现了输入设备的初始化，事件处理等功能。</li></ol><h3 id="input-init"><a href="#input-init" class="headerlink" title="input_init()"></a>input_init()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivesr/input/input.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">input_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">err = class_register(&amp;input_class);<span class="comment">// 尝试注册 input_dev 类</span></span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;unable to register input_dev class\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = input_proc_init();<span class="comment">// 初始化输入子系统的 proc 文件系统接口。这个接口用于在/proc 文件系统中提供有关输入设备的信息</span></span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> fail1;</span><br><span class="line"></span><br><span class="line">err = register_chrdev_region(MKDEV(INPUT_MAJOR, <span class="number">0</span>),</span><br><span class="line">     INPUT_MAX_CHAR_DEVICES, <span class="string">&quot;input&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;unable to register char major %d&quot;</span>, INPUT_MAJOR);</span><br><span class="line"><span class="keyword">goto</span> fail2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> fail2:input_proc_exit();</span><br><span class="line"> fail1:class_unregister(&amp;input_class);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">input_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">input_proc_exit();</span><br><span class="line">unregister_chrdev_region(MKDEV(INPUT_MAJOR, <span class="number">0</span>),</span><br><span class="line"> INPUT_MAX_CHAR_DEVICES);</span><br><span class="line">class_unregister(&amp;input_class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subsys_initcall(input_init);<span class="comment">// 在内核启动时被调用</span></span><br><span class="line">module_exit(input_exit);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="input-proc-init"><a href="#input-proc-init" class="headerlink" title="input_proc_init()"></a>input_proc_init()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">input_proc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">proc_bus_input_dir = proc_mkdir(<span class="string">&quot;bus/input&quot;</span>, <span class="literal">NULL</span>);<span class="comment">// 创建一个名为”bus/input”的目录，表示输入设备的总线类型</span></span><br><span class="line"><span class="keyword">if</span> (!proc_bus_input_dir)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">entry = proc_create(<span class="string">&quot;devices&quot;</span>, <span class="number">0</span>, proc_bus_input_dir,</span><br><span class="line">    &amp;input_devices_proc_ops);<span class="comment">//创建一个名 为 “ device”的文件，并将其与之前创建的“bus/input”目录相关联 </span></span><br><span class="line"><span class="keyword">if</span> (!entry)</span><br><span class="line"><span class="keyword">goto</span> fail1;</span><br><span class="line"></span><br><span class="line">entry = proc_create(<span class="string">&quot;handlers&quot;</span>, <span class="number">0</span>, proc_bus_input_dir,</span><br><span class="line">    &amp;input_handlers_proc_ops);<span class="comment">//创建一个名为&quot;handlers&quot;的文件，并将其与&quot;bus/input&quot;目录相关联。</span></span><br><span class="line"><span class="keyword">if</span> (!entry)</span><br><span class="line"><span class="keyword">goto</span> fail2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> fail2:remove_proc_entry(<span class="string">&quot;devices&quot;</span>, proc_bus_input_dir);</span><br><span class="line"> fail1: remove_proc_entry(<span class="string">&quot;bus/input&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="固定输入设备的设备节点"><a href="#固定输入设备的设备节点" class="headerlink" title="固定输入设备的设备节点"></a>固定输入设备的设备节点</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在进行嵌入式 Linux 开发时，不同厂家和型号的外设在内核启动时加载的顺序可能会不同。例如，触摸板和 USB 转串口等设备，这会导致在<code>/dev/input</code> 目录下创建的 evdevx 节点（其中 x=0,1,2,3…）不同。然而应用程序通常打开的是固定的设备节点，如果设备节点发生变化，就会导致应用程序打开错误的设备节点，因此，需要对输入设备创建的设备节点进行固定。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>通过分析 evdev.c 驱动程序，我们确定<strong>设备节点是在 <code>evdev_connect</code> 函数中创建的</strong>。因此，只需要<strong>在 <code>evdev_connect</code> 函数中针对需要固定设备节点的设备单独创建一个设备节点即可</strong>。</p><p>首先确定想要固定设备节点的设备名称，使用 <code>cat /proc/bus/input/devices</code> 命令找到设备名称。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195254121.png" alt="goodix-ts"></p><p>修改 <code>evdev_connect 函数</code>，根据设备名称来判断是否为想要固定的那个节点的名称，然后使用 <code>dev_set_name</code> 函数来固定设备节点</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195257393.png" alt="connect函数"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195300720.png" alt="/dev/input/"></p><h2 id="固定USB设备的设备节点"><a href="#固定USB设备的设备节点" class="headerlink" title="固定USB设备的设备节点"></a>固定USB设备的设备节点</h2><h3 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h3><p>在 Linux 系统中，当使用多个 USB 转串口设备时，经常会遇到插拔 USB 转串口的顺序变化导致设备节点不稳定的情况。为了解决这个问题，我们可以通过使用 udev 来固定设备节点，以确保设备节点不受 USB 转串口插拔顺序的影响</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>插入USB设备：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udevadm info -a -n /dev/ttyUSB0</span><br></pre></td></tr></table></figure><p><code>udevadm info -a -n /dev/ttyUSB0</code> 是一个用于获取有关特定设备节点的详细信息的命令，包括设备的属性、驱动程序、设备路径等。这些命令的参数含义如下所示：</p><ul><li><code>-a</code>：显示与指定设备节点相关联的所有属性。</li><li><code>-n</code>：指定设备节点的路径或名称。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195304678.png" alt="udevadm info -a -n /dev/ttyUSB0"></p><p>这个命令的输出可能会包含以下信息:</p><ol><li>设备路径（DEVPATH）：设备在系统中的路径，例如<code>/devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.2/2-1.2:1.0/ttyUSB0/tty/ttyUSB0</code>。</li><li>设备节点（DEVNAME）：设备在文件系统中的节点，即<code>/dev/ttyUSB0</code>。</li><li>设备的属性（Device Attributes）：包括设备的供应商 ID、产品 ID、序列号等信息。</li><li>设备的驱动程序（Device Driver）：设备所使用的驱动程序的名称和路径。</li><li>设备类型（SUBSYSTEM）：usb</li></ol><p>接下来在开发板的 <code>etc/udev/rules.d/</code>目录下，创建一个名为 001.rules 的规则文件:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">KERNELS</span>==”<span class="number">5</span>-<span class="number">1</span>:<span class="number">1</span>.<span class="number">0</span>”,SUBSYSTEMS==”usb”,MODE:=”<span class="number">0777</span>”,SYMLINK+=”myusb”</span><br></pre></td></tr></table></figure><ol><li><code>KERNELS==&quot;5-1:1.0&quot;</code></li></ol><ul><li>匹配设备的 <strong>内核设备名（Kernel Device Name）</strong></li><li><code>5-1:1.0</code> 是 USB 设备在内核中的路径标识：<ul><li><code>5</code>: USB 总线号（Bus）</li><li><code>1</code>: USB 设备号（Device）</li><li><code>1.0</code>: 接口编号（Interface），表示第 1 个接口的第 0 个端点</li></ul></li><li>这个值来自 <code>udevadm info</code> 输出中的 <code>KERNELS</code> 字段</li></ul><hr><ol><li><code>SUBSYSTEMS==&quot;usb&quot;</code></li></ol><ul><li>匹配设备所属的 <strong>子系统（Subsystem）</strong></li><li>表示这是一个 USB 类型的设备</li><li>可以用来过滤所有 USB 设备</li></ul><hr><ol><li><code>MODE:=&quot;0777&quot;</code></li></ol><ul><li>设置该设备文件的 <strong>权限（mode）</strong></li><li><code>0777</code> 表示：<ul><li>所有用户（root、普通用户、其他用户）都拥有读、写、执行权限</li><li>即：<code>rwxrwxrwx</code></li></ul></li><li>这样任何程序都可以直接访问该设备（如 <code>/dev/ttyUSB0</code>）</li></ul><blockquote><p>⚠️ 注意：<code>MODE</code> 前面是 <code>:=</code>，不是 <code>==</code>。<code>:=</code> 表示“赋值”，而 <code>==</code> 是“匹配”。</p></blockquote><hr><ol><li><code>SYMLINK+=&quot;myusb&quot;</code></li></ol><ul><li>为设备创建一个 <strong>符号链接（symbolic link）</strong></li><li>比如原本设备是 <code>/dev/ttyUSB0</code>，现在会多一个软链接：<code>/dev/myusb -&gt; /dev/ttyUSB0</code></li><li>可以用 <code>myusb</code> 来代替 <code>ttyUSB0</code>，更方便命名和脚本调用</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195322984.png" alt="效果"></p>]]></content>
    
    
    <summary type="html">Linux 输入子系统</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
    <category term="driver" scheme="https://even629.com/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>面试经典150题 P224 基本计算器</title>
    <link href="https://even629.com/posts/224/"/>
    <id>https://even629.com/posts/224/</id>
    <published>2025-12-18T05:17:13.000Z</published>
    <updated>2025-12-18T05:17:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-18</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P224 基本计算器" href="https://leetcode.cn/problems/basic-calculator/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P224 基本计算器</p><p class="url">https://leetcode.cn/problems/basic-calculator/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><h2 id="先转为前缀表达式，然后对前缀表达式求值"><a href="#先转为前缀表达式，然后对前缀表达式求值" class="headerlink" title="先转为前缀表达式，然后对前缀表达式求值"></a>先转为前缀表达式，然后对前缀表达式求值</h2><ul><li>需要先对字符去除空格，且对于负号(非减号，即单目运算符)在其前面插入0使得变为双目运算符。<ul><li>‘-‘为第一个字符的是单目运算符即负号，前面插入0</li><li>‘-‘前面是’(‘的是单目运算符即负号，前面插入0</li><li>其他情况下’-‘是双目运算符即减号</li></ul></li><li>然后转为前缀表达式，按空格分割各个操作数和操作符。首先创建一个存储符号的栈opStack，记返回值为<code>string ret</code>，遍历中缀表达式的每个字符。<ul><li>对于数字，不断加入ret直到下一个是非数字，然后ret后加一个空格进行分割，表示这是一个操作数</li><li>对于’(‘，直接加入opStack</li><li>对于’)’，弹出opStack中的所有双目运算符(‘+’或’-‘或’*’或’/‘)加入ret，直到栈顶’(‘，弹出’(‘但不加入ret</li><li>对于双目运算符(‘+’或’-‘或’*’或’/‘)<ul><li>如果栈顶元素也是双目运算符，且当前的双目运算符的优先级小于栈顶优先级，那么一直弹出栈顶直到不满足这个条件，最后把当前双目运算符加入栈中</li><li>其他情况下，把当前双目运算符加入栈中。</li></ul></li><li>最后如果opStack不为空，则把剩下的元素依次弹出加入ret</li></ul></li><li>最后对后缀表达式求值，注意求值最好用long，最后转为int<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::stack;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getPrecedence</span><span class="params">(<span class="type">char</span> op)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span> || op == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span> || op == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 辅助：将字符串按空格分割</span></span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                vector&lt;string&gt; tokens;</span><br><span class="line">                <span class="function">std::istringstream <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">                string token;</span><br><span class="line">                <span class="keyword">while</span> (iss &gt;&gt; token) &#123;</span><br><span class="line">                        tokens.<span class="built_in">push_back</span>(token);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> tokens;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">string <span class="title">conv_suffix_expr</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                string ret;</span><br><span class="line">                stack&lt;<span class="type">char</span>&gt; opStack;</span><br><span class="line">                <span class="type">char</span> ch;</span><br><span class="line">                <span class="type">int</span> i = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">                        ch = s[i];</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 处理多位数字</span></span><br><span class="line">                        <span class="keyword">if</span> (std::<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">                                <span class="keyword">while</span> (i &lt; n &amp;&amp; std::<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">                                        ret += s[i];</span><br><span class="line">                                        i++;</span><br><span class="line">                                &#125;</span><br><span class="line">                                ret += <span class="string">&quot; &quot;</span>; <span class="comment">// 加空格分隔</span></span><br><span class="line">                                i--; <span class="comment">// 后面会i++</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123; <span class="comment">// 左括号</span></span><br><span class="line">                                opStack.<span class="built_in">push</span>(ch);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>) &#123; <span class="comment">// 右括号</span></span><br><span class="line">                                <span class="keyword">while</span> (!opStack.<span class="built_in">empty</span>() &amp;&amp; opStack.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                                        ret += opStack.<span class="built_in">top</span>();</span><br><span class="line">                                        ret += <span class="string">&quot; &quot;</span>;</span><br><span class="line">                                        opStack.<span class="built_in">pop</span>();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (!opStack.<span class="built_in">empty</span>())</span><br><span class="line">                                        opStack.<span class="built_in">pop</span>(); <span class="comment">// 弹出 &#x27;(&#x27;</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span> || ch == <span class="string">&#x27;*&#x27;</span> || ch == <span class="string">&#x27;/&#x27;</span>) &#123; <span class="comment">// 运算符</span></span><br><span class="line">                                <span class="keyword">while</span> (!opStack.<span class="built_in">empty</span>() &amp;&amp; </span><br><span class="line">                                       <span class="built_in">getPrecedence</span>(opStack.<span class="built_in">top</span>()) &gt; <span class="number">0</span> &amp;&amp; <span class="comment">//栈顶也为双目运算符</span></span><br><span class="line">                                       <span class="built_in">getPrecedence</span>(opStack.<span class="built_in">top</span>()) &gt;= <span class="built_in">getPrecedence</span>(ch)) &#123;</span><br><span class="line">                                        ret += opStack.<span class="built_in">top</span>();</span><br><span class="line">                                        ret += <span class="string">&quot; &quot;</span>;</span><br><span class="line">                                        opStack.<span class="built_in">pop</span>();</span><br><span class="line">                                &#125;</span><br><span class="line">                                opStack.<span class="built_in">push</span>(ch);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        i++; <span class="comment">// 普通字符（运算符/括号）前进一位</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 弹出剩余运算符</span></span><br><span class="line">                <span class="keyword">while</span> (!opStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        ret += opStack.<span class="built_in">top</span>();</span><br><span class="line">                        ret += <span class="string">&quot; &quot;</span>;</span><br><span class="line">                        opStack.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">suffix_expr_cal</span><span class="params">(string &amp;postfix)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                vector&lt;string&gt; tokens = <span class="built_in">split</span>(postfix);</span><br><span class="line">                stack&lt;<span class="type">long</span>&gt; st;</span><br><span class="line">                <span class="type">long</span> a, b;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> string &amp;token : tokens) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (token == <span class="string">&quot;+&quot;</span> || token == <span class="string">&quot;-&quot;</span> || token == <span class="string">&quot;*&quot;</span> || token == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                                b = st.<span class="built_in">top</span>();</span><br><span class="line">                                st.<span class="built_in">pop</span>();</span><br><span class="line">                                a = st.<span class="built_in">top</span>();</span><br><span class="line">                                st.<span class="built_in">pop</span>();</span><br><span class="line">                                <span class="keyword">if</span> (token == <span class="string">&quot;+&quot;</span>)</span><br><span class="line">                                        st.<span class="built_in">push</span>(a + b);</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">                                        st.<span class="built_in">push</span>(a - b);</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;*&quot;</span>)</span><br><span class="line">                                        st.<span class="built_in">push</span>(a * b);</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;/&quot;</span>)</span><br><span class="line">                                        st.<span class="built_in">push</span>(a / b);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                st.<span class="built_in">push</span>(std::<span class="built_in">stol</span>(token));</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> (<span class="type">int</span>)st.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">handleUnaryMinus</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                string clean;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                                clean += c;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                string result;</span><br><span class="line">                <span class="type">int</span> n = clean.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                        <span class="type">char</span> c = clean[i];</span><br><span class="line">                        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                                <span class="comment">// 判断是否为一元负号：</span></span><br><span class="line">                                <span class="comment">// 情况1：开头</span></span><br><span class="line">                                <span class="comment">// 情况2：前一个字符是 &#x27;(&#x27; 或其他运算符 (+, -, *, /)</span></span><br><span class="line">                                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                                        result += <span class="string">&quot;0-&quot;</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        <span class="type">char</span> prev = clean[i - <span class="number">1</span>];</span><br><span class="line">                                        <span class="keyword">if</span> (prev == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                                                result += <span class="string">&quot;0-&quot;</span>;</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                result += <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                result += c;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                s = <span class="built_in">handleUnaryMinus</span>(s); <span class="comment">// 在&quot;-&quot;前插入 0</span></span><br><span class="line">                string postfix = <span class="built_in">conv_suffix_expr</span>(s);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">suffix_expr_cal</span>(postfix);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="只有加减"><a href="#只有加减" class="headerlink" title="只有加减"></a>只有加减</h3><p>由于字符串除了数字与括号外，只有加号和减号两种运算符。因此，如果展开表达式中所有的括号，则得到的新表达式中，数字本身不会发生变化，只是每个数字前面的符号会发生变化。括号不能忽略，因为虽然”+”和”-“运算优先级相同，但是括号会改变优先级。<br>变化主要在于没有了双目运算符的优先级判断，即对于原来的”如果栈顶元素也是双目运算符，且当前的双目运算符的优先级小于栈顶优先级，那么一直弹出栈顶直到不满足这个条件，最后把当前双目运算符加入栈中”,变为”如果栈顶元素是双目运算符，那么一直弹出栈顶直到不满足这个条件，最后把当前双目运算符加入栈中”。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">conv_suffix_expr</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string ret;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; opStack;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="type">char</span> ch = s[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; std::<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">                ret += s[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;<span class="function">eles <span class="title">if</span> <span class="params">(ch == <span class="string">&#x27;(&#x27;</span>)</span> </span>&#123;</span><br><span class="line">            opStack.<span class="built_in">push</span>(ch);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!opStack.<span class="built_in">empty</span>() &amp;&amp; opStack.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ret += opStack.<span class="built_in">top</span>();</span><br><span class="line">                ret += <span class="string">&quot; &quot;</span>;</span><br><span class="line">                opStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!opStack.<span class="built_in">empty</span>()) opStack.<span class="built_in">pop</span>(); <span class="comment">// pop &#x27;(&#x27;</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 弹出所有栈顶不是 &#x27;(&#x27; 的双目运算符</span></span><br><span class="line">            <span class="keyword">while</span> (!opStack.<span class="built_in">empty</span>() &amp;&amp; </span><br><span class="line">                   opStack.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span> ) &#123;</span><br><span class="line">                ret += opStack.<span class="built_in">top</span>();</span><br><span class="line">                ret += <span class="string">&quot; &quot;</span>;</span><br><span class="line">                opStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            opStack.<span class="built_in">push</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!opStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ret += opStack.<span class="built_in">top</span>();</span><br><span class="line">        ret += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        opStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="DFS递归"><a href="#DFS递归" class="headerlink" title="DFS递归"></a>DFS递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(s, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">dfs</span><span class="params">(String s, <span class="type">int</span> positive)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c = s.<span class="built_in">charAt</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(Character.<span class="built_in">isDigit</span>(c))&#123;</span><br><span class="line">                <span class="type">int</span> num = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">while</span>(i + <span class="number">1</span> &lt; s.<span class="built_in">length</span>() &amp;&amp; Character.<span class="built_in">isDigit</span>(s.<span class="built_in">charAt</span>(i + <span class="number">1</span>)))&#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + s.<span class="built_in">charAt</span>(++i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res += positive * num;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                positive = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                res += positive * <span class="built_in">dfs</span>(s, <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
    
    
    <summary type="html">栈</summary>
    
    
    
    <category term="algorithm" scheme="https://even629.com/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://even629.com/tags/algorithm/"/>
    
    <category term="栈" scheme="https://even629.com/tags/%E6%A0%88/"/>
    
    <category term="leetcode面试经典150题" scheme="https://even629.com/tags/leetcode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Linux gpio子系统</title>
    <link href="https://even629.com/posts/2512173/"/>
    <id>https://even629.com/posts/2512173/</id>
    <published>2025-12-17T12:31:13.000Z</published>
    <updated>2025-12-17T12:31:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-17</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h2 id="GPIO介绍"><a href="#GPIO介绍" class="headerlink" title="GPIO介绍"></a>GPIO介绍</h2><p>GPIO=General-Purpose Input/Output（通用输入输出），是一种软件运行期间能够动态配置和控制的通用引脚。</p><p><strong>所有的 GPIO 在上电后的初始状态都是输入模式，可以通过软件设为上拉或下拉，也可以输入中断信号，驱动强度都是可编程的</strong>。</p><h3 id="GPIO引脚分布"><a href="#GPIO引脚分布" class="headerlink" title="GPIO引脚分布"></a>GPIO引脚分布</h3><p>RK3568 有 5 组 GPIO：GPIO0 到 GPIO4。每组 GPIO 又以 A0 到 A7，B0 到 B7，C0 到C7，D0 到 D7，作为区分的编号。所以 RK3568 上的 GPIO 是不是应该有 5<em>4</em>8=160 个呢？但实际在数据手册中只有 152 个 GPIO。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223194912131.png" alt="rk3568 block diagram"></p><p>实 际 上 RK3568 一 共 有 152 个 GPIO ， 其 中 GPIO0_D2 ， GPIO0_D7 ， GPIO2_C7 ，GPIO4_D3~GPIO4_D7 是没有的，所以是 152 个 GPIO。</p><h3 id="GPIO电气属性"><a href="#GPIO电气属性" class="headerlink" title="GPIO电气属性"></a>GPIO电气属性</h3><p>我们以 RK3568 为例，以具体 CPU 的数据手册为准。RK3568 上的 GPIO 可以设置为 3.3V，也可以设置为 1.8V。在实际编程时，高电平（3.3V 或 1.8V）用 1 表示，低电平用 0 表示。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223194918719.png" alt="DC Characteristics"></p><p>如何确定 RK3568 的 GPIO 电平是 3.3V 还是 1.8V 呢？</p><p>看核心板原理图查找到引脚对应的 GPIO 和引脚所连接的电源域，如MIPI_CAM0_PDN_L_GPIO3_D5</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223194922087.png" alt="TOPEET_RK3568_LPDDR4_V1_1 底板原理图"></p><p>可以看到接到该GPIO的是VCCIO6</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223194925512.png" alt="VCCIO6 可配置"></p><h3 id="GPIO电气特性"><a href="#GPIO电气特性" class="headerlink" title="GPIO电气特性"></a>GPIO电气特性</h3><p>RK3568的TRM手册中提到</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223194930988.png" alt="Rockchip RK3568 TRM Part1 V1.1-20210301"></p><p>GPIO 是可编程的 GPIO，GPIO 除了 IO 电平，还有驱动强度，上拉和下拉，这些概念解释如下：</p><ul><li><p><strong>驱动强度（Drive Strength）</strong>：GPIO 的驱动强度决定了<strong>它可以提供的输出电流</strong>。通过软件配置，您可以选择合适的驱动强度，以确保 GPIO 能够驱动所连接的外部设备或电路。</p></li><li><p><strong>上拉（Pull-up）和下拉（Pull-down）</strong>：GPIO 引脚可以通过上拉或下拉电阻来确定其默认电平状态。通过软件配置，您可以选择启用上拉或下拉电阻，以确保 <strong>GPIO 在未连接外部设备时保持稳定的默认状态</strong>。</p></li><li><p><strong>中断（Interrupt）</strong>：通过软件配置，您可以启用 GPIO 中断功能，以便<strong>在 GPIO 状态发生变化时及时获得通知</strong>。这对于实现事件驱动的应用程序非常有用，可以通过中断来处理 GPIO触发的事件。</p></li><li><p><strong>多功能引脚（Multipurpose Pins）</strong>：一些 GPIO 引脚可能具有多种功能，可以通过软件配置来选择不同的功能。例如，一个 GPIO 引脚可以配置为数字输入、数字输出、PWM 输出等。</p><p>比如：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sdmmc0 &#123;</span><br><span class="line">/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">sdmmc0_bus4: sdmmc0-bus4 &#123;</span><br><span class="line">rockchip,pins =</span><br><span class="line"><span class="comment">/* sdmmc0_d0 */</span></span><br><span class="line">&lt;<span class="number">1</span> RK_PD5 <span class="number">1</span> &amp;pcfg_pull_up_drv_level_2&gt;,</span><br><span class="line"><span class="comment">/* sdmmc0_d1 */</span></span><br><span class="line">&lt;<span class="number">1</span> RK_PD6 <span class="number">1</span> &amp;pcfg_pull_up_drv_level_2&gt;,</span><br><span class="line"><span class="comment">/* sdmmc0_d2 */</span></span><br><span class="line">&lt;<span class="number">1</span> RK_PD7 <span class="number">1</span> &amp;pcfg_pull_up_drv_level_2&gt;,</span><br><span class="line"><span class="comment">/* sdmmc0_d3 */</span></span><br><span class="line">&lt;<span class="number">2</span> RK_PA0 <span class="number">1</span> &amp;pcfg_pull_up_drv_level_2&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">sdmmc0_clk: sdmmc0-clk &#123;</span><br><span class="line">rockchip,pins =</span><br><span class="line"><span class="comment">/* sdmmc0_clk */</span></span><br><span class="line">&lt;<span class="number">2</span> RK_PA2 <span class="number">1</span> &amp;pcfg_pull_up_drv_level_2&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>节点中描述了引脚的配置，比如说<code>&lt;1 RK_PD5 1 &amp;pcfg_pull_up_drv_level_2&gt;</code>描述的是GPIO1_D5 引脚，复用模式为模式 1（复用模式可以查看 RK3568 的参考手册），GPIO 引脚的上拉驱动强度为 2。</p><h2 id="GPIO控制和操作"><a href="#GPIO控制和操作" class="headerlink" title="GPIO控制和操作"></a>GPIO控制和操作</h2><h3 id="使用命令通过sysfs控制GPIO"><a href="#使用命令通过sysfs控制GPIO" class="headerlink" title="使用命令通过sysfs控制GPIO"></a>使用命令通过sysfs控制GPIO</h3><p>首先需要底层驱动的支持，make menuconfig</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers</span><br><span class="line">-&gt;GPIO Support</span><br><span class="line">-&gt;/sys/<span class="keyword">class</span>/<span class="symbol">gpio</span>/<span class="symbol">xxxx</span></span><br></pre></td></tr></table></figure><h4 id="gpio编号计算"><a href="#gpio编号计算" class="headerlink" title="gpio编号计算"></a>gpio编号计算</h4><p>iTOP-RK3568 有 5 组 GPIO bank：GPIO0~GPIO4，每组又以 A0~A7, B0~B7, C0~C7, D0~D7 作为编号区分,常用以下公式计算引脚：</p><p>GPIO pin 脚计算公式：</p><script type="math/tex; mode=display">\text{pin} = \text{bank} \times 32 + \text{group} \times 8 + X</script><p>以 GPIO0_PB7 为例，bank 为0，group 为B（A=0, B=1, C=2, D=3）， X为7，其中把 $\text{group} \times 8 + X$ 称为number</p><p><strong>举例</strong>： GPIO0_PB7 pin 脚计算方法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bank</span> = <span class="number">0</span>;  //GPIO0_B7=&gt; <span class="number">0</span>, bank ∈<span class="meta"> [0,4]</span></span><br><span class="line"><span class="attribute">group</span> = <span class="number">1</span>; //GPIO0_B7 =&gt; <span class="number">1</span>, group ∈ &#123;(A=<span class="number">0</span>), (B=<span class="number">1</span>), (C=<span class="number">2</span>), (D=<span class="number">3</span>)&#125;</span><br><span class="line"><span class="attribute">X</span> = <span class="number">7</span>;     //GPIO4_D7 =&gt; <span class="number">5</span>, X ∈<span class="meta"> [0,7]</span></span><br><span class="line"><span class="attribute">number</span> = group * <span class="number">8</span> + X = <span class="number">1</span> * <span class="number">8</span> + <span class="number">7</span> =<span class="number">15</span></span><br><span class="line"><span class="attribute">pin</span> = bank*<span class="number">32</span> + number= <span class="number">0</span> * <span class="number">32</span> + <span class="number">15</span> = <span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>sysfs导出的内核对象</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223194937227.png" alt="/sys/class/gpio"></p><p><code>/sys/class/gpio/export</code>用 于 将 GPIO 控 制 从 内 核 空 间 导 出 到 用 户 空 间 。</p><p><code>/sys/class/gpio/unexport</code> 用于取消 GPIO 控制从内核空间到用户空间的导出。</p><p><code>gpiochipX</code> 代表 GPIO 控制器。</p><blockquote><p><code>export</code> 和<code>unexport</code>，他们都是<strong>只写的</strong>。</p></blockquote><h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>用于将指定编号的 GPIO 引脚导出。在使用 GPIO 引脚之前，需要将其导出，导出成功之后才能使用它。</p><p>注意 export 文件是只写文件，不能读取，将一个指定的gpio编号写入到 export 文件中即可将对应的 GPIO 引脚导出，以 GPIO0_PB7 为例（pin 计算值为 15）使用 export 文件进行导出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 15 &gt; <span class="built_in">export</span></span><br></pre></td></tr></table></figure><p>会发现在<code>/sys/class/gpio</code> 目录下生成了一个名为 gpio15 的文件夹（gpioX，X 表示对应的编 号），该文件夹就是导出来的 GPIO 引脚对应的文件夹，用于管理、控制该 GPIO 引脚。</p><blockquote><p>需要注意的是，并不是所有 GPIO 引脚都可以成功导出，如果对应的 GPIO 已经被导出或者在内核中被使用了，那便无法成功导出，导出失败提示：Device or resource busy</p><p>出现上图报错的原因是该 GPIO 已经被其他 GPIO 使用，需要在内核中找到使用 GPIO 的驱动，并取消该驱动才可以正常使用 GPIO。</p></blockquote><p>gpio15 文件夹下分别有 <code>active_low</code>、<code>device</code>、<code>direction</code>、<code>edge</code>、<code>power</code>、<code>subsystem</code>、<code>uevent</code>、<code>value</code> 八个文件，需要关心的文件是 <code>active_low</code>、<code>direction</code>、<code>edge</code> 以及 <code>value</code> 这四个属性文件。</p><h5 id="direction"><a href="#direction" class="headerlink" title="direction"></a>direction</h5><p><strong>配置 GPIO 引脚为输入或输出模式</strong>。该文件<strong>可读、可写</strong>，读表示查看 GPIO 当前是输入还是输出模式，写表示将 GPIO 配置为输入或输出模式；</p><p>读取或写入操作可取的值为”out”（输出模式）和”in”（输入模式）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> direction</span><br><span class="line"><span class="built_in">echo</span> out &gt; direction</span><br></pre></td></tr></table></figure><h5 id="active-low"><a href="#active-low" class="headerlink" title="active_low"></a>active_low</h5><p>用于控制极性的属性文件，可读可写，默认情况下为 0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> active_low</span><br></pre></td></tr></table></figure><p>当 active_low 等于 0 时， value 值若为 1 则引脚输出高电平，value 值若为 0 则引脚输出低电平。</p><p>当 active_low 等于 1 时 ，value 值若为 0 则引脚输出高电平，value 值若为 1 则引脚输出低电平。</p><h5 id="edge"><a href="#edge" class="headerlink" title="edge"></a>edge</h5><p>控制中断的触发模式，该文件可读可写。</p><p>在配置 GPIO 引脚的中断触发模式之前，需将其设置为输入模式，四种触发模式的设置如下所示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非中断引脚</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;none&quot;</span> &gt; edge</span><br><span class="line"><span class="comment"># 上升沿触发</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;rising&quot;</span> &gt; edge</span><br><span class="line"><span class="comment"># 下降沿触发</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;falling&quot;</span> &gt; edge</span><br><span class="line"><span class="comment"># 边沿触发</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;both&quot;</span> &gt; edge</span><br></pre></td></tr></table></figure><h5 id="value"><a href="#value" class="headerlink" title="value"></a>value</h5><p>设置高低电平，如果我们要把这个管脚设置成高电平，我们只需要给 value 设置成 1即可，反之，则设置成 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 设置高电平</span><br><span class="line">echo <span class="number">1</span> &gt; value</span><br><span class="line"># 设置低电平</span><br><span class="line">echo <span class="number">0</span> &gt; value</span><br></pre></td></tr></table></figure><h4 id="unexport"><a href="#unexport" class="headerlink" title="unexport"></a>unexport</h4><p>将导出的 GPIO 引脚删除。当使用完 GPIO 引脚之后，需要将导出的引脚删除，同样该文件也是只写文件、不可读，使用 unexport 文件进行删除 GPIO0_PB7：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 15 &gt; unexport</span><br></pre></td></tr></table></figure><h3 id="使用C程序通过sysfs控制GPIO"><a href="#使用C程序通过sysfs控制GPIO" class="headerlink" title="使用C程序通过sysfs控制GPIO"></a>使用C程序通过sysfs控制GPIO</h3><p>主要思路是通过文件IO API</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;              <span class="comment">// 文件描述符</span></span><br><span class="line"><span class="type">int</span> ret;             <span class="comment">// 返回值</span></span><br><span class="line"><span class="type">char</span> gpio_path[<span class="number">100</span>]; <span class="comment">// GPIO路径</span></span><br><span class="line"><span class="type">int</span> len;             <span class="comment">// 字符串长度</span></span><br><span class="line"><span class="type">char</span> file_path[<span class="number">100</span>]; <span class="comment">// 文件路径</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">2</span>];         <span class="comment">// 缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span> <span class="comment">// poll结构体数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出GPIO引脚</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpio_export</span><span class="params">(<span class="type">char</span> *argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    fd = open(<span class="string">&quot;/sys/class/gpio/export&quot;</span>, O_WRONLY); <span class="comment">// 打开export文件</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open /sys/class/gpio/export error \n&quot;</span>); <span class="comment">// 打开文件失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len = <span class="built_in">strlen</span>(argv);         <span class="comment">// 获取字符串长度</span></span><br><span class="line">    ret = write(fd, argv, len); <span class="comment">// 写入引脚号到export文件</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write /sys/class/gpio/export error \n&quot;</span>); <span class="comment">// 写入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd); <span class="comment">// 关闭文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消导出GPIO引脚</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpio_unexport</span><span class="params">(<span class="type">char</span> *argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    fd = open(<span class="string">&quot;/sys/class/gpio/unexport&quot;</span>, O_WRONLY); <span class="comment">// 打开unexport文件</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open /sys/class/gpio/unexport error \n&quot;</span>); <span class="comment">// 打开文件失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len = <span class="built_in">strlen</span>(argv);        <span class="comment">// 获取字符串长度</span></span><br><span class="line">    ret = write(fd, argv, len); <span class="comment">// 写入引脚号到unexport文件</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write /sys/class/gpio/unexport error \n&quot;</span>); <span class="comment">// 写入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd); <span class="comment">// 关闭文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制GPIO引脚的属性</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpio_ctrl</span><span class="params">(<span class="type">char</span> *arg, <span class="type">char</span> *val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(file_path, <span class="string">&quot;%s/%s&quot;</span>, gpio_path, arg); <span class="comment">// 构建属性文件的路径</span></span><br><span class="line">    fd = open(file_path, O_WRONLY);              <span class="comment">// 打开属性文件</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open file_path error \n&quot;</span>); <span class="comment">// 打开文件失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len = <span class="built_in">strlen</span>(val);         <span class="comment">// 获取字符串长度</span></span><br><span class="line">    ret = write(fd, val, len); <span class="comment">// 写入属性值到属性文件</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write file_path error\n&quot;</span>); <span class="comment">// 写入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd); <span class="comment">// 关闭文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听GPIO引脚的中断事件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpio_interrupt</span><span class="params">(<span class="type">char</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(file_path, <span class="string">&quot;%s/%s&quot;</span>, gpio_path, arg); <span class="comment">// 构建文件路径</span></span><br><span class="line">    fd = open(file_path, O_RDONLY);              <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open file_path error \n&quot;</span>); <span class="comment">// 打开文件失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">void</span> *)fds, <span class="number">0</span>, <span class="keyword">sizeof</span>(fds)); <span class="comment">// 清空poll结构体数组</span></span><br><span class="line">    fds[<span class="number">0</span>].fd = fd;                      <span class="comment">// 设置poll结构体的文件描述符</span></span><br><span class="line">    fds[<span class="number">0</span>].events = POLLPRI;             <span class="comment">// 设置poll结构体的事件类型为POLLPRI，表示有紧急数据可读</span></span><br><span class="line"></span><br><span class="line">    read(fd, buf, <span class="number">2</span>); <span class="comment">// 读取文件内容，清除中断事件</span></span><br><span class="line"></span><br><span class="line">    ret = poll(fds, <span class="number">1</span>, <span class="number">-1</span>); <span class="comment">// 调用poll函数等待中断事件发生，阻塞直到事件发生</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;poll error \n&quot;</span>); <span class="comment">// 调用poll失败或超时</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLPRI)</span><br><span class="line">    &#123;</span><br><span class="line">        lseek(fd, <span class="number">0</span>, SEEK_SET); <span class="comment">// 重新定位文件指针到文件开头</span></span><br><span class="line">        read(fd, buf, <span class="number">2</span>);       <span class="comment">// 读取文件内容，获取中断事件的值</span></span><br><span class="line">        buf[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;value is %s\n&quot;</span>, buf); <span class="comment">// 输出中断事件的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取GPIO引脚的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpio_read_value</span><span class="params">(<span class="type">char</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(file_path, <span class="string">&quot;%s/%s&quot;</span>, gpio_path, arg); <span class="comment">// 构建文件路径</span></span><br><span class="line">   fd = open(file_path, O_WRONLY); <span class="comment">// 打开文件，以只写模式打开是一个错误，应该使用只读模式</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open file_path error\n&quot;</span>); <span class="comment">// 打开文件失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = read(fd, buf, <span class="number">1</span>); <span class="comment">// 读取文件内容，获取引脚的值</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;1&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The value is high\n&quot;</span>); <span class="comment">// 引脚值为高电平</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;0&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The value is low\n&quot;</span>); <span class="comment">// 引脚值为低电平</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 这里应该返回读取到的引脚值（0或1），而不是返回固定的-1</span></span><br><span class="line">    close(fd); <span class="comment">// 关闭文件（这行代码无法执行到，应该放在read之前）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> <span class="comment">// 主函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">sprintf</span>(gpio_path, <span class="string">&quot;/sys/class/gpio/gpio%s&quot;</span>, argv[<span class="number">1</span>]); <span class="comment">// 构建GPIO路径</span></span><br><span class="line">    <span class="keyword">if</span> (access(gpio_path, F_OK))                            <span class="comment">// 检查GPIO路径是否存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        gpio_export(argv[<span class="number">1</span>]); <span class="comment">// 不存在则导出GPIO引脚</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        gpio_unexport(argv[<span class="number">1</span>]); <span class="comment">// 存在则取消导出GPIO引脚</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gpio_ctrl(<span class="string">&quot;direction&quot;</span>, <span class="string">&quot;in&quot;</span>); <span class="comment">// 设置GPIO引脚为输入模式</span></span><br><span class="line">    gpio_ctrl(<span class="string">&quot;edge&quot;</span>, <span class="string">&quot;both&quot;</span>);    <span class="comment">// 设置GPIO引脚的中断触发方式为上升沿和下降沿</span></span><br><span class="line">    gpio_interrupt(<span class="string">&quot;value&quot;</span>);      <span class="comment">// 监听GPIO引脚的中断事件</span></span><br><span class="line"></span><br><span class="line">    gpio_unexport(argv[<span class="number">1</span>]); <span class="comment">// 最后取消导出GPIO引脚</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0表示程序正常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过IO命令操作寄存器控制GPIO"><a href="#通过IO命令操作寄存器控制GPIO" class="headerlink" title="通过IO命令操作寄存器控制GPIO"></a>通过IO命令操作寄存器控制GPIO</h3><h4 id="IO命令"><a href="#IO命令" class="headerlink" title="IO命令"></a>IO命令</h4><p>io 命令是一个用于 Linux 系统的命令行工具，用于读取和写入指定 I/O 端口的值。它主要用于与硬件设备进行低级别的交互和调试，在内核阶段读写寄存器。</p><p>该命令的语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io <span class="selector-attr">[选项]</span> <span class="selector-attr">[地址]</span> <span class="selector-attr">[操作]</span> <span class="selector-attr">[数据]</span></span><br></pre></td></tr></table></figure><ul><li>选项<ul><li><code>-b</code>：以字节为单位进行 I/O 操作（默认为字）。</li><li><code>-w</code>：以字为单位进行 I/O 操作。</li><li><code>-l</code>：以双字为单位进行 I/O 操作。</li></ul></li><li>地址：<strong>要读取或写入的 I/O 端口的十六进制值</strong></li><li>操作：<ul><li><code>-r</code>：读取 I/O 端口的值。</li><li><code>-w</code>：写入数据到 I/O 端口</li></ul></li><li>数据：<strong>要写入 I/O 端口的十六进制值</strong>。</li></ul><p>例子：</p><ol><li>读取 I/O 端口的值：<br><code>io -b -r 0x80</code><br>这将以字节为单位读取 I/O 端口 0x80 的值，并将其显示在终端上。</li><li>向 I/O 端口写入数据：<br><code>io -b -w 0x80 0xAB</code><br>这将向 I/O 端口 0x80 写入十六进制值 0xAB。</li><li>以字为单位进行读取：<br><code>io -w -r 0x1000</code><br>这将以字为单位读取 I/O 端口 0x1000 的值</li><li>以双字为单位进行写入：<br><code>io -l -w 0x2000 0xDEADBEEF</code><br>这将以双字为单位向 I/O 端口 0x2000 写入十六进制值 0xDEADBEEF</li></ol><h4 id="LED引脚寄存器查找"><a href="#LED引脚寄存器查找" class="headerlink" title="LED引脚寄存器查找"></a>LED引脚寄存器查找</h4><p>控制 LED 灯的 GPIO 为 GPIO0_B7，我们需要对 GPIO 进行配置，一般情况下需要对 GPIO 的<strong>复用寄存器</strong>，<strong>方向寄存器</strong>，<strong>数据寄存器</strong>进行配置。</p><h5 id="复用寄存器"><a href="#复用寄存器" class="headerlink" title="复用寄存器"></a>复用寄存器</h5><p>RK3568 TRM-Part1 GPIO Interface Description中可以看出</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223194944566.png" alt="RK3568 TRM-Part1 GPIO Interface Description"></p><p>PMU_GRF Register Description如下</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223194948096.png" alt="GRF Address Mapping Table"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223194956751.png" alt="RK3568 TRM-Part1 PMU_GRF Register Description"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195004557.png" alt="PMU_GRF_GPIO0B_IOMUX_H"></p><p>所以复用寄存器地址=基地址+偏移地址=0xFDC2000C 。</p><p>使用 io 命令查看此寄存器的地址：<code>io -r -4 0xFDC2000C</code></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195008340.png" alt="io -r -4 0xFDC2000C"></p><p>寄存器值为 00000001，[14:12]位为 000，所以默认设置的为 gpio 功能。</p><h5 id="方向寄存器"><a href="#方向寄存器" class="headerlink" title="方向寄存器"></a>方向寄存器</h5><p>RK3568 TRM-Part1 GPIO Interface Description中可以看出，方向寄存器应为GPIO_SWPORT_DDR_L或GPIO_SWPORT_DDR_H</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195012437.png" alt="RK3568 TRM-Part1 GPIO Interface Description"></p><p>GPIO 有四组 GPIO，分别是 GPIOA，GPIOB，GPIOC，GPIOD。每组又以 A0~A7, B0~B7, C0~C7, D0~D7 作为编号区分。GPIO0B7 在 GPIO_SWPORT_DDR_L 上所以，方向寄存器的偏移地址为 0x0008。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195018919.png" alt="GPIO_SWPORT_DDR_L"></p><p>[31:16]位属性是 WO，也就是只可写入。这[31:16]位是写标志位，是低 16 位的写使能。如果低 16 位中某一位要设置输入输入输出，则对应高位写标志也应该设置为 1。</p><p> [15：0] 是数据方向控制寄存器低位，如果要设置某个 GPIO 为输出，则对应位置 1，如果要设置某个 GPIO 为输入，则对应位置 0。那么 GPIO0 B7 ，我们要设置第 15 位为输入还是输出，那么对应的[31:16]位写使能也要置 1。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195022072.png" alt="Address Mapping"></p><p>GPIO0 的基地址为 0xFDD60000。因此方向寄存器的地址=基地址+偏移地址=0xFDD60000+0x0008=0xFDD60008</p><h5 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h5><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195025447.png" alt="RK3568 TRM-Part1 GPIO Interface Description"></p><p>所以数据寄存器的地址为基地址+偏移地址=0xFDD60000。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195029822.png" alt="Detailed Register Description"></p><p>上图的方法和在分析方向寄存器的方法同理，由上图可知，如果要控制第 15 位为高电平（置 1），还需要设置 31 位为 1，那么点亮灯，需要向数据寄存器写入 0x8000c040</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>复用关系寄存器的基地址为 0xFDC20000 ，偏移地址为 000C ，所以要操作的地址为基地址+偏移地址=0xFDC2000C</li><li>GPIO 的基地址为 0xFDD60000，偏移地址为 0x0008，所以方向寄存器要操作的地址为基地址+偏移地址=0xFDD60008，我们要给方向寄存器写入 0x80000044 设置为输出。</li><li>GPIO 的基地址为 0xFDD60000，偏移地址为 0x0000，所以数据寄存器要操作的地址为基地址+偏移地址=0xFDD60000</li><li>默认的数据寄存器的值：0x8000c040 亮灯，0x80004040 灭灯</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认 GPIO0_B7 是 GPIO 模式，然后输入以下命令将方向寄存器设置为输出。</span></span><br><span class="line">io -w -4 0xFDD60008 0x80008044</span><br><span class="line"><span class="comment"># 接下来设置 GPIO 是输出高电平还是低电平，首先查看数据寄存器的值，输入以下命令：</span></span><br><span class="line">io -r -4 0xFDD60000</span><br><span class="line"><span class="comment"># 给数据寄存器写入 0x80008040 输出高电平，灯亮。</span></span><br><span class="line">io -w -4 0xFDD60000 0x8000c040</span><br><span class="line"><span class="comment"># 给数据寄存器写入 0x80008040 输出高电平，灯灭。</span></span><br><span class="line">io -w -4 0xFDD60000 0x80004040</span><br></pre></td></tr></table></figure><h3 id="通过mem设备和mmap控制GPIO"><a href="#通过mem设备和mmap控制GPIO" class="headerlink" title="通过mem设备和mmap控制GPIO"></a>通过mem设备和mmap控制GPIO</h3><p>通过打开<code>/dev/mem</code> 设备文件，并将其映射到用户空间的内存中，我们可以直接读写物理内存地址，从而实现对 GPIO 寄存器的控制。这种方法相对于 IO 命令更加灵活，可以使用更高级的编程语言（如 C/C++）来编写控制逻辑。</p><h4 id="Linux系统用户态访问内核态的方式"><a href="#Linux系统用户态访问内核态的方式" class="headerlink" title="Linux系统用户态访问内核态的方式"></a>Linux系统用户态访问内核态的方式</h4><ol><li><p><strong>通过 read/write/ioctl</strong>：使用这种方式，用户态程序可以通过读写文件描述符或使用 ioctl 系统调用与内核进行通信。例如，可以通过读写特定文件描述符来控制设备或获取设备状态。</p></li><li><p><strong>通过 sysfs 虚拟文件系统</strong>：sysfs 是一种以文件的形式表示设备和内核信息的虚拟文件系统。通过在 sysfs 中的特定路径下读写文件，用户态程序可以与内核进行交互，例如控制 GPIO 引脚或获取系统信息。</p></li><li><strong>通过内存映射</strong>：内存映射是将用户空间的一段内存区域映射到内核空间的一种机制。通过内存映射，用户态程序可以直接修改内存区域的内容，从而与内核进行通信。这种方式可以实现高效的数据传输和共享。</li><li><strong>通过 Netlink</strong>：Netlink 是 Linux 内核提供的一种通信机制，用于用户态程序与内核之间的双向通信。通过创建 Netlink 套接字，用户态程序可以与内核进行交互，发送请求、接收事件通知等。这种方式适用于需要与内核进行复杂交互的场景，例如配置系统参数或发送命令。</li></ol><h4 id="dev-mem-设备"><a href="#dev-mem-设备" class="headerlink" title="/dev/mem 设备"></a><code>/dev/mem</code> 设备</h4><p><code>/dev/mem</code> 是 Linux 系统中的一个虚拟设备，通常与 mmap 结合使用，可以<strong>将设备的物理内存映射到用户态</strong>，以实现用户空间对内核态的直接访问。无论是标准 Linux 系统还是嵌入式Linux 系统，都支持使用<code>/dev/mem</code> 设备。</p><p>直接访问内核空间是一项潜在危险的操作，因此只有 root 用户才能访问<code>/dev/mem</code>设备。此外有些系统可能需要单独启动/dev/mem 设备的功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers ---&gt;</span><br><span class="line">Character devices---&gt;</span><br><span class="line">[*] /dev/mem virtual device support</span><br></pre></td></tr></table></figure><p>IO 命令实际上就是基于<code>/dev/mem</code>设备实现的。如果 Linux 内核源码没有配置支持<code>/dev/mem</code>，IO 命令是不能使用的。</p><p>使用 <code>/dev/mem</code> 设备需要 <strong>root 权限</strong>，并且必须<strong>谨慎操作</strong>，因为直接访问物理内存（内核空间）是一项潜在的危险操作，可能导致系统崩溃或数据损坏。</p><p>以下是使用 <code>/dev/mem</code> 的基本步骤：</p><p><strong>步骤一：打开 <code>/dev/mem</code> 文件</strong></p><p>使用 <code>open()</code> 函数以适当的权限和模式打开 <code>/dev/mem</code>，获取文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = <span class="number">0</span>;</span><br><span class="line">fd = open(<span class="string">&quot;/dev/mem&quot;</span>, O_RDWR | O_NDELAY);  <span class="comment">/* 读写权限，非阻塞模式 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>访问权限选项</strong>：<ul><li><code>O_RDONLY</code>：只读</li><li><code>O_WRONLY</code>：只写</li><li><code>O_RDWR</code>：读写</li></ul></li><li><strong>阻塞模式选项</strong>：<ul><li>默认为阻塞</li><li><code>O_NDELAY</code> 或 <code>O_NONBLOCK</code>：非阻塞</li></ul></li></ul><blockquote><p>可以根据实际需求选择适当的访问权限和阻塞方式</p></blockquote><p><strong>步骤二：映射物理内存到用户空间</strong></p><p>使用 <code>mmap()</code> 将目标物理地址映射到进程的虚拟地址空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *mmap_addr = <span class="literal">NULL</span>;</span><br><span class="line">mmap_addr = (<span class="type">char</span> *)mmap(</span><br><span class="line">    <span class="literal">NULL</span>,                <span class="comment">// 让内核选择映射地址</span></span><br><span class="line">    MMAP_SIZE,           <span class="comment">// 映射区域大小（字节）</span></span><br><span class="line">    PROT_READ | PROT_WRITE,  <span class="comment">// 读写权限</span></span><br><span class="line">    MAP_SHARED,          <span class="comment">// 共享映射（对其他进程可见）</span></span><br><span class="line">    fd,                  <span class="comment">// /dev/mem 的文件描述符</span></span><br><span class="line">    MMAP_ADDR            <span class="comment">// 要映射的物理地址（需页对齐）</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>MMAP_ADDR</code>：目标物理地址（通常需按页对齐，如 4KB 对齐）</li><li><code>MMAP_SIZE</code>：映射长度（建议至少一个内存页，如 4096 字节）</li><li>若 <code>mmap()</code> 返回 <code>MAP_FAILED</code>，表示映射失败，应检查错误码（<code>errno</code>）</li></ul><p><strong>步骤三：读写映射的内存（寄存器操作）</strong></p><p>通过返回的指针直接访问硬件寄存器或物理内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">*(<span class="type">int</span> *)mmap_addr = <span class="number">0xff</span>;   <span class="comment">// 写操作：向映射地址写入 0xff</span></span><br><span class="line">a = *(<span class="type">int</span> *)mmap_addr;      <span class="comment">// 读操作：从映射地址读取值到变量 a</span></span><br></pre></td></tr></table></figure><ul><li><p>指针类型可根据寄存器宽度调整（如 <code>uint32_t*</code>、<code>volatile uint8_t*</code> 等）</p></li><li><p>建议使用 <code>volatile</code> 修饰符防止编译器优化导致访问异常：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">uint32_t</span> *reg = (<span class="keyword">volatile</span> <span class="type">uint32_t</span> *)mmap_addr;</span><br><span class="line">*reg = <span class="number">0x12345678</span>;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ol><li><strong>权限要求</strong>：必须以 root 用户运行，或具备 <code>CAP_SYS_RAWIO</code> 能力。</li><li><strong>地址对齐</strong>：<code>mmap()</code> 要求偏移量（即物理地址）是页大小（通常 4096）的整数倍。</li><li><strong>安全风险</strong>：错误的读写可能引发系统崩溃、硬件异常或安全漏洞。</li><li><strong>资源释放</strong>：使用完毕后应调用 <code>munmap()</code> 解除映射，并 <code>close()</code> 文件描述符。</li></ol><h4 id="mmap-函数"><a href="#mmap-函数" class="headerlink" title="mmap()函数"></a>mmap()函数</h4><h4 id="mmap-函数总结"><a href="#mmap-函数总结" class="headerlink" title="mmap() 函数总结"></a><code>mmap()</code> 函数总结</h4><p><strong>功能</strong>：将文件或设备（如 <code>/dev/mem</code>）映射到进程的虚拟地址空间，实现直接内存访问。</p><p><strong>函数原型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>start</code></td><td>建议映射的起始地址。通常设为 <code>NULL</code>，由内核自动选择。</td></tr><tr><td><code>length</code></td><td>要映射的字节数。</td></tr><tr><td><code>prot</code></td><td>内存保护标志（可组合）： • <code>PROT_READ</code>：可读 • <code>PROT_WRITE</code>：可写 • <code>PROT_EXEC</code>：可执行 • <code>PROT_NONE</code>：不可访问</td></tr><tr><td><code>flags</code></td><td>映射类型（必须指定其一）： • <code>MAP_SHARED</code>：修改对其他进程可见，会写回文件/设备 • <code>MAP_PRIVATE</code>：写时复制，修改不共享 • <code>MAP_FIXED</code>：强制使用 <code>start</code> 地址（<strong>不推荐</strong>）</td></tr><tr><td><code>fd</code></td><td>文件描述符（由 <code>open()</code> 返回），若映射匿名内存可设为 <code>-1</code>（需配合 <code>MAP_ANONYMOUS</code>）。</td></tr><tr><td><code>offset</code></td><td>文件/设备中的偏移量，<strong>必须是系统页大小（如 4096）的整数倍</strong>。</td></tr></tbody></table></div><p><strong>返回值</strong>：</p><ul><li>成功：返回指向映射区域的指针（<code>void*</code>）</li><li>失败：返回 <code>MAP_FAILED</code>（即 <code>(void*) -1</code>），并设置 <code>errno</code></li></ul><p><strong>典型用途</strong>：</p><ul><li>访问硬件寄存器（通过 <code>/dev/mem</code>）</li><li>高效文件 I/O（避免 <code>read</code>/<code>write</code> 系统调用开销）</li><li>进程间共享内存（配合 <code>MAP_SHARED</code>）</li></ul><p><strong>注意事项</strong>：</p><ul><li>使用完毕应调用 <code>munmap()</code> 释放映射。</li><li><code>offset</code> 和映射长度需注意对齐和边界。</li><li>操作物理内存需 root 权限，存在安全风险。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_REG_BASE 0xFDD60000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORT_DDR_L_OFFSET 0x0008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_SWPORT_DR_L_OFFSET 0x0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_MAP 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开LED灯</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_ON</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *base)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置LED灯的方向为输出</span></span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)(base + GPIO_SWPORT_DDR_L_OFFSET) = <span class="number">0x80008044</span>;</span><br><span class="line">    <span class="comment">// 将LED灯打开</span></span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)(base + GPIO_SWPORT_DR_L_OFFSET) = <span class="number">0x80008040</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭LED灯</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_OFF</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *base)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置LED灯的方向为输出</span></span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)(base + GPIO_SWPORT_DDR_L_OFFSET) = <span class="number">0x80008044</span>;</span><br><span class="line">    <span class="comment">// 将LED灯关闭</span></span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)(base + GPIO_SWPORT_DR_L_OFFSET) = <span class="number">0x80000040</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *map_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开/dev/mem设备</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/mem&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open /dev/mem error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将物理地址映射到用户空间</span></span><br><span class="line">    map_base = (<span class="type">unsigned</span> <span class="type">char</span> *)mmap(<span class="literal">NULL</span>, SIZE_MAP, PROT_READ | PROT_WRITE, MAP_SHARED, fd, GPIO_REG_BASE);</span><br><span class="line">    <span class="keyword">if</span> (map_base == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;map_base error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打开LED灯</span></span><br><span class="line">        LED_ON(map_base);</span><br><span class="line">        <span class="comment">// 等待1秒</span></span><br><span class="line">        usleep(<span class="number">1000000</span>);</span><br><span class="line">        <span class="comment">// 关闭LED灯</span></span><br><span class="line">        LED_OFF(map_base);</span><br><span class="line">        <span class="comment">// 等待1秒</span></span><br><span class="line">        usleep(<span class="number">1000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除映射</span></span><br><span class="line">    munmap(map_base, SIZE_MAP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0表示程序正常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GPIO调试"><a href="#GPIO调试" class="headerlink" title="GPIO调试"></a>GPIO调试</h2><h3 id="debugfs"><a href="#debugfs" class="headerlink" title="debugfs"></a>debugfs</h3><p>debugfs 是 Linux 内核提供的一个调试文件系统，可以用于查看和调试内核中的各种信息，包括 GPIO 的使用情况。通过挂载 debugfs 文件系统，并查看<code>/sys/kernel/debug/</code>目录下的相关文件，可以获取 GPIO 的状态，配置和其他调试信息，如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195038616.png" alt="/sys/kernel/debug/"></p><p>如果上图目录<code>/sys/kernel/debug</code> 目录下没有文件，需要在 Linux 内核源码配置 debugfs，勾选<code>Debug Filesystem</code>配置好之后，重新编译内核源码，烧写内核镜像。</p><p>如果没有 debugfs，可以使用以下命令进行挂载:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t debugfs none /sys/kernel/debug/</span><br></pre></td></tr></table></figure><p>如果有 debugfs，可以使用以下命令查看 GPIO 的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/kernel/debug/gpio</span><br></pre></td></tr></table></figure><p>进入<code>/sys/kernel/debug/pinctrl</code> 目录时，你可以获取有关 GPIO 控制器的调试信息。在该目录下，通常会有以下文件和目录：</p><ol><li><code>/sys/kernel/debug/pinctrl/*/pinmux-pins</code>：这些文件列出了每个 GPIO 引脚的引脚复用配置。可以查看每个引脚的功能模式、引脚复用选择以及其他相关的配置信息。我们进入到<code>/sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/</code>下面，输入“cat pinmux-pins”，如下图所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195041761.png" alt="cat pinmux-pins"></p><ol><li><code>/sys/kernel/debug/pinctrl/*/pins</code>：这些文件列出了 GPIO 的引脚编号，可以查看 GPIO 编号。我们进入到<code>/sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/</code>下面，输入“cat pins”，如下图所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195045896.png" alt="cat pins"></p><ol><li><code>/sys/kernel/debug/pinctrl/*/gpio-ranges</code>：这些文件列出了每个 GPIO 控制器支持的 GPIO 范围。<br>你可以查看GPIO 编号的范围和对应的控制器名称 。我们进入到<code>/sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/</code>下面，输入“cat gpio-ranges”，如下图所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195049529.png" alt="cat gpio-ranges"></p><ol><li><code>/sys/kernel/debug/pinctrl/*/pinmux-functions</code>：这些文件列出了每个功能模式的名称以及与之关联的 GPIO 引脚。你可以查看各个功能模式的名称和对应的引脚列表。我们进入到<code>/sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/</code>下面，输入“cat pinmux-functions”，如下图所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195052740.png" alt="image-20251217183545784"></p><ol><li><code>/sys/kernel/debug/pinctrl/*/pingroups</code>：该路径提供有关用于配置和控制系统上的 GPIO 引脚的引脚组的信息。我们进入到<code>/sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/</code>下面，输入“cat pingroups”，如下图所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195055693.png" alt="cat pingroups"></p><ol><li><code>/sys/kernel/debug/pinctrl/*/pinconf-pins</code>：这些文件包含了 GPIO 引脚的配置信息，如输入/输出模式、上拉/下拉设置等。你可以查看和修改 GPIO 的电气属性，以便进行 GPIO 的调试和配置。我们进入到<code>/sys/kernel/debug/pinctrl/pinctrl-rockchip-pinctrl/</code>下面，输入“cat pinconf-pins”，如下图所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195058797.png" alt="cat pinconf-pins"></p><h2 id="GPIO子系统API"><a href="#GPIO子系统API" class="headerlink" title="GPIO子系统API"></a>GPIO子系统API</h2><p>在目前的 Linux 内核主线中，GPIO（通用输入/输出）子系统存在两个版本，这里将两个版本区分为新版本和旧版本。新版本 GPIO 子系统接口是基于描述符（descriptor-based）来实现的，而旧版本的 GPIO 子系统接口是基于整数（integer-based）来实现的，在 Linux 内核中为了保持向下的兼容性，旧版本的接口在最新的内核版本中仍然得到支持，而随着时间的推移，新版本的 GPIO 子系统接口会越来越完善，最终完全取代旧版本。</p><p>新的 GPIO 子系统接口需要与与设备树（Device Tree）结合使用。使用设备树和新的 GPIO接口可以更加灵活地配置和管理系统中的 GPIO 资源，提供了更好的可扩展性和可移植性。所以<strong>如果没有设备树，就无法使用新的 GPIO 接口</strong>。</p><p>一个明显的区别是新的 GPIO 子系统接口使用了以<code>gpiod_</code>作为前缀的函数命名约定，而旧的 GPIO 子系统接口使用了以<code>gpio_</code>作为前缀的函数命名约定。</p><h3 id="gpio-desc-结构体"><a href="#gpio-desc-结构体" class="headerlink" title="gpio_desc 结构体"></a>gpio_desc 结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_device</span>*<span class="title">gdev</span>;</span> <span class="comment">// GPIO 设备结构体</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>flags; <span class="comment">// 标志位，用于表示不同的属性</span></span><br><span class="line"><span class="comment">/* flag symbols are bit numbers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_REQUESTED0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_IS_OUT1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_EXPORT2<span class="comment">/* protected by sysfs_lock */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_SYSFS3<span class="comment">/* exported via /sys/class/gpio/control */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_ACTIVE_LOW6<span class="comment">/* value has active low */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_OPEN_DRAIN7<span class="comment">/* Gpio is open drain type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_OPEN_SOURCE 8<span class="comment">/* Gpio is open source type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_USED_AS_IRQ 9<span class="comment">/* GPIO is connected to an IRQ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_IRQ_IS_ENABLED 10<span class="comment">/* GPIO is connected to an enabled IRQ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_IS_HOGGED11<span class="comment">/* GPIO is hogged */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_TRANSITORY 12<span class="comment">/* GPIO may lose value in sleep or reset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_PULL_UP    13<span class="comment">/* GPIO has pull up enabled */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_PULL_DOWN  14<span class="comment">/* GPIO has pull down enabled */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_BIAS_DISABLE    15<span class="comment">/* GPIO has pull disabled */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_EDGE_RISING     16<span class="comment">/* GPIO CDEV detects rising edge events */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAG_EDGE_FALLING    17<span class="comment">/* GPIO CDEV detects falling edge events */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Connection label */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*label; <span class="comment">// 表示 GPIO 的标签或名称</span></span><br><span class="line"><span class="comment">/* Name of the GPIO */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*name; <span class="comment">// GPIO 的名称</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_OF_DYNAMIC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>*<span class="title">hog</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GPIO_CDEV</span></span><br><span class="line"><span class="comment">/* debounce period in microseconds */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>debounce_period_us;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="gpio-device-结构体"><a href="#gpio-device-结构体" class="headerlink" title="gpio_device 结构体"></a>gpio_device 结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct gpio_device - internal state container for GPIO devices</span></span><br><span class="line"><span class="comment"> * @id: numerical ID number for the GPIO chip</span></span><br><span class="line"><span class="comment"> * @dev: the GPIO device struct</span></span><br><span class="line"><span class="comment"> * @chrdev: character device for the GPIO device</span></span><br><span class="line"><span class="comment"> * @mockdev: class device used by the deprecated sysfs interface (may be</span></span><br><span class="line"><span class="comment"> * NULL)</span></span><br><span class="line"><span class="comment"> * @owner: helps prevent removal of modules exporting active GPIOs</span></span><br><span class="line"><span class="comment"> * @chip: pointer to the corresponding gpiochip, holding static</span></span><br><span class="line"><span class="comment"> * data for this device</span></span><br><span class="line"><span class="comment"> * @descs: array of ngpio descriptors.</span></span><br><span class="line"><span class="comment"> * @ngpio: the number of GPIO lines on this GPIO device, equal to the size</span></span><br><span class="line"><span class="comment"> * of the @descs array.</span></span><br><span class="line"><span class="comment"> * @base: GPIO base in the DEPRECATED global Linux GPIO numberspace, assigned</span></span><br><span class="line"><span class="comment"> * at device creation time.</span></span><br><span class="line"><span class="comment"> * @label: a descriptive name for the GPIO device, such as the part number</span></span><br><span class="line"><span class="comment"> * or name of the IP component in a System on Chip.</span></span><br><span class="line"><span class="comment"> * @data: per-instance data assigned by the driver</span></span><br><span class="line"><span class="comment"> * @list: links gpio_device:s together for traversal</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This state container holds most of the runtime variable data</span></span><br><span class="line"><span class="comment"> * for a GPIO device and can hold references and live on after the</span></span><br><span class="line"><span class="comment"> * GPIO chip has been removed, if it is still being used from</span></span><br><span class="line"><span class="comment"> * userspace.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_device</span> &#123;</span></span><br><span class="line"><span class="type">int</span>id; <span class="comment">// GPIO 设备 ID。每个 GPIO 设备可以有一个唯一的 ID</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span><span class="title">dev</span>;</span><span class="comment">// 对应的设备结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span><span class="title">chrdev</span>;</span><span class="comment">// 字符设备结构体，用于实现 GPIO 设备的字符设备接口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span>*<span class="title">mockdev</span>;</span><span class="comment">// 模拟设备结构体指针，用于表示 GPIO 设备的模拟设备结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span>*<span class="title">owner</span>;</span><span class="comment">// 拥有该 GPIO 设备的内核模块指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span>*<span class="title">chip</span>;</span><span class="comment">// 对应的 GPIO 芯片结构体指针，示与 GPIO 设备关联的 GPIO 芯片（GPIO 控制器）结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>*<span class="title">descs</span>;</span><span class="comment">// GPIO 描述符数组指针。每个 GPIO 描述符用于描述 GPIO 的属性和状态</span></span><br><span class="line"><span class="type">int</span>base;<span class="comment">// GPIO 编号的起始值</span></span><br><span class="line">u16ngpio;<span class="comment">// GPIO 的数量</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*label;<span class="comment">// GPIO 设备的标签</span></span><br><span class="line"><span class="type">void</span>*data;<span class="comment">// 与 GPIO 设备相关的数据指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">list</span>;</span><span class="comment">// 用于将 GPIO 设备结构体连接到链表中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blocking_notifier_head</span> <span class="title">notifier</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PINCTRL</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If CONFIG_PINCTRL is enabled, then gpio controllers can optionally</span></span><br><span class="line"><span class="comment"> * describe the actual pin range which they serve in an SoC. This</span></span><br><span class="line"><span class="comment"> * information would be used by pinctrl subsystem to configure</span></span><br><span class="line"><span class="comment"> * corresponding pins for gpio usage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 如果启用了 CONFIG_PINCTRL 选项，GPIO 控制器可以选择描述它们在 SoC 中服务的实际引脚范围。</span></span><br><span class="line"><span class="comment">* 此信息将由 pinctrl 子系统用于配置相应的 GPIO 引脚。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pin_ranges</span>;</span><span class="comment">// 描述 GPIO 控制器引脚范围的链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面一系列的参数中，要重点关注的是 <code>struct gpio_chip *chip</code> 这一结构体，表示与 GPIO 设备关联的 GPIO 芯片（GPIO 控制器）结构体。</p><h3 id="gpio-chip结构体"><a href="#gpio-chip结构体" class="headerlink" title="gpio_chip结构体"></a>gpio_chip结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*label;<span class="comment">// GPIO 芯片标签</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_device</span>*<span class="title">gpiodev</span>;</span><span class="comment">// GPIO 设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span>*<span class="title">parent</span>;</span><span class="comment">// 父设备指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span>*<span class="title">owner</span>;</span><span class="comment">// 拥有者模块指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>(*request)(<span class="keyword">struct</span> gpio_chip *gc,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset);<span class="comment">// 请求 GPIO</span></span><br><span class="line"><span class="type">void</span>(*<span class="built_in">free</span>)(<span class="keyword">struct</span> gpio_chip *gc,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset);<span class="comment">// 释放 GPIO</span></span><br><span class="line"><span class="type">int</span>(*get_direction)(<span class="keyword">struct</span> gpio_chip *gc,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset);<span class="comment">// 获取 GPIO 方向</span></span><br><span class="line"><span class="type">int</span>(*direction_input)(<span class="keyword">struct</span> gpio_chip *gc,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset);<span class="comment">// 设置 GPIO 为输入</span></span><br><span class="line"><span class="type">int</span>(*direction_output)(<span class="keyword">struct</span> gpio_chip *gc,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">int</span> value);<span class="comment">// 设置 GPIO 为输出</span></span><br><span class="line"><span class="type">int</span>(*get)(<span class="keyword">struct</span> gpio_chip *gc,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset);<span class="comment">// 获取 GPIO 值</span></span><br><span class="line"><span class="type">int</span>(*get_multiple)(<span class="keyword">struct</span> gpio_chip *gc,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *mask,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *bits);<span class="comment">// 获取多个 GPIO 的值</span></span><br><span class="line"><span class="type">void</span>(*<span class="built_in">set</span>)(<span class="keyword">struct</span> gpio_chip *gc,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">int</span> value);<span class="comment">// 设置 GPIO 值</span></span><br><span class="line"><span class="type">void</span>(*set_multiple)(<span class="keyword">struct</span> gpio_chip *gc,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *mask,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *bits);<span class="comment">// 设置多个 GPIO</span></span><br><span class="line"><span class="type">int</span>(*set_config)(<span class="keyword">struct</span> gpio_chip *gc,</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> offset,</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">long</span> config);<span class="comment">// 设置 GPIO 配置</span></span><br><span class="line"><span class="type">int</span>(*to_irq)(<span class="keyword">struct</span> gpio_chip *gc,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset);<span class="comment">// 将 GPIO 转换为中断</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>(*dbg_show)(<span class="keyword">struct</span> seq_file *s,</span><br><span class="line"><span class="keyword">struct</span> gpio_chip *gc);<span class="comment">// 在调试信息中显示 GPIO</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>(*init_valid_mask)(<span class="keyword">struct</span> gpio_chip *gc,</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> *valid_mask,</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> ngpios);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>(*add_pin_ranges)(<span class="keyword">struct</span> gpio_chip *gc);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>base;<span class="comment">// GPIO 编号的基准值</span></span><br><span class="line">u16ngpio;<span class="comment">// GPIO 的数量</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*<span class="type">const</span> *names;<span class="comment">// GPIO 的名称数组</span></span><br><span class="line"><span class="type">bool</span>can_sleep;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_GPIO_GENERIC)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*read_reg)</span><span class="params">(<span class="type">void</span> __iomem *reg)</span>;</span><br><span class="line"><span class="type">void</span> (*write_reg)(<span class="type">void</span> __iomem *reg, <span class="type">unsigned</span> <span class="type">long</span> data);</span><br><span class="line"><span class="type">bool</span> be_bits;</span><br><span class="line"><span class="type">void</span> __iomem *reg_dat;</span><br><span class="line"><span class="type">void</span> __iomem *reg_set;</span><br><span class="line"><span class="type">void</span> __iomem *reg_clr;</span><br><span class="line"><span class="type">void</span> __iomem *reg_dir_out;</span><br><span class="line"><span class="type">void</span> __iomem *reg_dir_in;</span><br><span class="line"><span class="type">bool</span> bgpio_dir_unreadable;</span><br><span class="line"><span class="type">int</span> bgpio_bits;</span><br><span class="line"><span class="type">spinlock_t</span> bgpio_lock;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> bgpio_data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> bgpio_dir;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_GPIO_GENERIC */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GPIOLIB_IRQCHIP</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * With CONFIG_GPIOLIB_IRQCHIP we get an irqchip inside the gpiolib</span></span><br><span class="line"><span class="comment"> * to handle IRQs for most practical cases.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @irq:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Integrates interrupt chip functionality with the GPIO chip. Can be</span></span><br><span class="line"><span class="comment"> * used to handle IRQs for most practical cases.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_irq_chip</span> <span class="title">irq</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_GPIOLIB_IRQCHIP */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @valid_mask:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If not %NULL holds bitmask of GPIOs which are valid to be used</span></span><br><span class="line"><span class="comment"> * from the chip.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *valid_mask;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_GPIO)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If CONFIG_OF is enabled, then all GPIO controllers described in the</span></span><br><span class="line"><span class="comment"> * device tree automatically may have an OF translation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @of_node:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pointer to a device tree node representing this GPIO controller.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @of_gpio_n_cells:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Number of cells used to form the GPIO specifier.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> of_gpio_n_cells;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @of_xlate:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Callback to translate a device tree GPIO specifier into a chip-</span></span><br><span class="line"><span class="comment"> * relative GPIO number and flags.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*of_xlate)(<span class="keyword">struct</span> gpio_chip *gc,</span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> of_phandle_args *gpiospec, u32 *flags);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_OF_GPIO */</span></span></span><br><span class="line"></span><br><span class="line">ANDROID_KABI_RESERVE(<span class="number">1</span>);</span><br><span class="line">ANDROID_KABI_RESERVE(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>struct gpio_chip *chip</code> 这一结构体用于描述 GPIO 芯片的属性和操作函数，可以通过函数指针调用相应的函数来请求、释放、设置、获取 GPIO 的状态和数值等操作，从而实现对 GPIO 的控制和管理，需要注意的是这个结构体中的一系列函数都不需要我们来填充，这些工作都是由芯片原厂工程师来完成的，我们只需要学会新 gpio 子系统相应 API 函数的使用即可。</p><h3 id="获取单个GPIO描述"><a href="#获取单个GPIO描述" class="headerlink" title="获取单个GPIO描述"></a>获取单个GPIO描述</h3><h4 id="gpiod-get"><a href="#gpiod-get" class="headerlink" title="gpiod_get()"></a>gpiod_get()</h4><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> gpio_desc *__must_check <span class="title function_">gpiod_get</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">    <span class="keyword">enum</span> gpiod_flags flags</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><strong>头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><p>根据设备和连接标识符（con_id）获取一个必需的 GPIO 描述符，并按指定标志配置其模式。</p><p><strong>参数</strong></p><ul><li><strong><code>dev</code></strong>：指向关联设备的 <code>struct device</code> 指针。</li><li><strong><code>con_id</code></strong>：连接标识符（connection ID），通常在设备树（Device Tree）中定义，用于匹配具体的 GPIO。</li><li><strong><code>flags</code></strong>：GPIO 配置标志，类型为 <code>enum gpiod_flags</code>，常用值包括：<ul><li><code>GPIOD_IN</code> 或 <code>GPIOD_INPUT</code>：配置为输入。</li><li><code>GPIOD_OUT_LOW</code> / <code>GPIOD_OUT_HIGH</code>（旧版用 <code>GPIOD_OUTPUT</code>）：配置为输出，默认初始电平为低/高。</li><li><code>GPIOD_ACTIVE_LOW</code>：逻辑高对应物理低电平（反相）。</li><li><code>GPIOD_OPEN_DRAIN</code>：开漏输出。</li><li><code>GPIOD_OPEN_SOURCE</code>：开源输出。</li></ul></li></ul><blockquote><p>⚠️ 注意：现代内核推荐使用 <code>GPIOD_OUT_LOW</code> / <code>GPIOD_OUT_HIGH</code> 替代 <code>GPIOD_OUTPUT</code>，因为后者不指定初始电平。</p></blockquote><p><strong>示例设备树片段</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">    my_device: my-device@<span class="number">0</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;myvendor,my-device&quot;</span>;</span><br><span class="line">        <span class="comment">/* 定义3个GPIO，分别对应 index 0, 1, 2 */</span></span><br><span class="line">        my-gpios = &lt;&amp;gpio1 <span class="number">5</span> GPIO_ACTIVE_HIGH&gt;,   <span class="comment">// index 0</span></span><br><span class="line">                   &lt;&amp;gpio1 <span class="number">6</span> GPIO_ACTIVE_LOW&gt;,    <span class="comment">// index 1</span></span><br><span class="line">                   &lt;&amp;gpio2 <span class="number">12</span> GPIO_ACTIVE_HIGH&gt;;  <span class="comment">// index 2</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><ul><li>成功：返回指向 <code>struct gpio_desc</code> 的指针。</li><li>失败：返回 <code>ERR_PTR()</code> 编码的错误指针（如 <code>-ENOENT</code>, <code>-EPROBE_DEFER</code> 等），<strong>不是 NULL</strong>。</li></ul><blockquote><p>✅ 使用建议：应使用 <code>IS_ERR()</code> 判断返回值是否出错，而非检查 <code>NULL</code>。</p></blockquote><h4 id="gpiod-get-index"><a href="#gpiod-get-index" class="headerlink" title="gpiod_get_index()"></a>gpiod_get_index()</h4><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> gpio_desc *__must_check <span class="title function_">gpiod_get_index</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">int</span> idx,</span></span><br><span class="line"><span class="params">    <span class="keyword">enum</span> gpiod_flags flags</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><p>获取与设备、连接标识符及索引 <code>idx</code> 对应的 GPIO 描述符。适用于一个 <code>con_id</code> 对应多个 GPIO（如 “leds”, “buttons” 等数组型 GPIO 组）。</p><p><strong>参数</strong></p><ul><li><strong><code>idx</code></strong>：GPIO 在该连接中的索引（从 0 开始）。</li></ul><p><strong>返回值</strong></p><ul><li>同 <code>gpiod_get</code>：成功返回 <code>gpio_desc*</code>，失败返回错误指针。</li></ul><h4 id="gpiod-get-optional"><a href="#gpiod-get-optional" class="headerlink" title="gpiod_get_optional()"></a>gpiod_get_optional()</h4><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> gpio_desc *__must_check <span class="title function_">gpiod_get_optional</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">    <span class="keyword">enum</span> gpiod_flags flags</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><p>尝试获取指定的 GPIO，但如果设备树中未定义该 GPIO，则<strong>不视为错误</strong>，而是返回 <code>NULL</code>。</p><p><strong>适用场景</strong></p><p>用于可选 GPIO（例如某些硬件版本有，某些没有）。</p><p><strong>返回值</strong></p><ul><li>成功获取：返回 <code>struct gpio_desc*</code>。</li><li>未定义或不存在：返回 <code>NULL</code>。</li><li>其他错误（如 defer）：返回错误指针（需用 <code>IS_ERR()</code> 检查）。</li></ul><blockquote><p>✅ 安全使用方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">desc = gpiod_get_optional(dev, <span class="string">&quot;reset&quot;</span>, GPIOD_OUT_HIGH);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(desc))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(desc);</span><br><span class="line"><span class="keyword">if</span> (!desc)</span><br><span class="line">dev_info(dev, <span class="string">&quot;No optional reset GPIO\n&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote><h4 id="gpiod-get-index-optional"><a href="#gpiod-get-index-optional" class="headerlink" title="gpiod_get_index_optional()"></a>gpiod_get_index_optional()</h4><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> gpio_desc *__must_check <span class="title function_">gpiod_get_index_optional</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">int</span> idx,</span></span><br><span class="line"><span class="params">    <span class="keyword">enum</span> gpiod_flags flags</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><p><code>gpiod_get_index</code> 的可选版本：若指定索引的 GPIO 不存在，不报错，返回 <code>NULL</code>。</p><p><strong>返回值</strong></p><ul><li>存在且成功：<code>gpio_desc*</code></li><li>不存在：<code>NULL</code></li><li>其他错误：错误指针（需 <code>IS_ERR()</code> 判断）</li></ul><h4 id="gpiod-put"><a href="#gpiod-put" class="headerlink" title="gpiod_put()"></a>gpiod_put()</h4><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpiod_put</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br></pre></td></tr></table></figure><p><strong>头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><p>释放一个通过 <code>gpiod_get()</code>、<code>gpiod_get_index()</code>、<code>gpiod_get_optional()</code> 或 <code>gpiod_get_index_optional()</code> 获取的 GPIO 描述符。</p><p>该函数会：</p><ul><li>释放对该 GPIO 的引用；</li><li>如果这是最后一个引用，则将 GPIO 恢复到未使用状态（如释放中断、取消映射等）；</li><li>不会自动改变 GPIO 的电平或方向（除非底层驱动实现特殊行为）。</li></ul><blockquote><p>⚠️ 注意：即使 GPIO 是“可选”的（通过 <code>_optional</code> 函数获取），只要返回值非 <code>NULL</code> 且非错误指针，就应调用 <code>gpiod_put()</code>。</p></blockquote><p><strong>参数</strong></p><ul><li><strong><code>desc</code></strong>：指向要释放的 <code>struct gpio_desc</code> 的指针。<ul><li>若为 <code>NULL</code>，函数安全地不做任何操作（<strong>允许传入 NULL</strong>）。</li><li>若为错误指针（如 <code>ERR_PTR(-ENOENT)</code>），<strong>不应调用 <code>gpiod_put()</code></strong>。</li></ul></li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>新版本的 gpio 子系统 api 接口要与设备树结合才能使用，所以需要在设备树中将用于获取 GPIO 描述符的引脚复用为 GPIO 模式。这里选择 RK3568 开发板背面 20Pin GPIO 座子的 1 号引脚，右边对应的丝印为 I2C3_SDA_M0。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195106091.png" alt="J39 GPIO"></p><p>可以看到 1 号管脚的网络标号为 I2C3_SDA_M0，然后打开核心板原理图，根据这个网络标号进行搜索，查找到的核心板内容如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195109079.png" alt="核心板原理图"></p><p>首先根据上图中的复用功能查看设备树中是否已经对该引脚进行了复用，在确保该引脚无任何复用之后，对 topeet-rk3568-linux.dtsi 设备树进行内容的添加，在根节点的结尾添加以下内容：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">my_gpio:</span><span class="title class_">gpiol_a0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;mygpio&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">my-gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio1</span> RK_PA0 GPIO_ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;mygpio_ctrl</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>compatible</code>: 用于指定设备的兼容性字符串，与驱动程序中的值相匹配。</li><li><code>my-gpios</code>: 指定了与该设备相关联的 GPIO。&amp;gpiol 表示 GPIO 控制器的句柄（handle），RK_PA0 是与该 GPIO 相关的资源描述符（resource specifier），GPIO_ACTIVE_HIGH 表示 GPIO 的默认电平为高电平。</li></ul><blockquote><p>注意这里必须为my-gpios而不是gpios，必须有中间的”-“</p></blockquote><ul><li><code>pinctrl-names</code> 和 pinctrl-0: 用于指定引脚控制器（pinctrl）的配置。pinctrl-names 表示引脚控制器配置的名称，这里为 “default”。pinctrl-0 指定了与该配置相关联的引脚控制器句柄，这里为 &amp;mygpio_ctrl。</li></ul><p>然后找到pinctrl子节点</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">mygpio</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">mygpio_ctrl:</span> <span class="title class_">my-gpio-ctrl</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">rockchip,pins</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span> RK_PA0 RK_FUNC_GPIO <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>1</code> 表示引脚索引</li><li>RK_PA0 表示资源描述符，用于标识与该引脚相关联的物理资源，表示引脚所属的功能组</li><li><code>RK _FUNC_GPIO</code> 表示将引脚的功能设置为 GPIO</li><li><code>&amp;pcfg_pull_none</code> 表示引脚配置为无上下拉。</li></ul><p>驱动程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">mygpio1</span>;</span>  <span class="comment">// GPIO 描述符指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">mygpio2</span>;</span>  <span class="comment">// GPIO 描述符指针</span></span><br><span class="line"><span class="type">int</span> num;  <span class="comment">// GPIO 编号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备初始化函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">mygpio1</span>, *<span class="title">mygpio2</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is my_platform_probe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取可选 GPIO */</span></span><br><span class="line">    mygpio1 = gpiod_get_optional(&amp;pdev-&gt;dev, <span class="string">&quot;my&quot;</span>, GPIOD_IN);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(mygpio1)) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get optional &#x27;my&#x27; GPIO: %ld\n&quot;</span>, PTR_ERR(mygpio1));</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(mygpio1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mygpio1) &#123;</span><br><span class="line">        num = desc_to_gpio(mygpio1);</span><br><span class="line">        printk(<span class="string">&quot;Optional GPIO num is %d\n&quot;</span>, num);</span><br><span class="line">        gpiod_put(mygpio1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        printk(<span class="string">&quot;Optional &#x27;my&#x27; GPIO not specified in DT\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 0 的必需 GPIO */</span></span><br><span class="line">    mygpio2 = gpiod_get_index(&amp;pdev-&gt;dev, <span class="string">&quot;my&quot;</span>, <span class="number">0</span>, GPIOD_IN);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(mygpio2)) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get indexed &#x27;my&#x27; GPIO[0]: %ld\n&quot;</span>, PTR_ERR(mygpio2));</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(mygpio2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    num = desc_to_gpio(mygpio2);</span><br><span class="line">    printk(<span class="string">&quot;Indexed GPIO num is %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注意：这里没有释放 mygpio2！通常应在 remove() 中释放 */</span></span><br><span class="line">    <span class="comment">/* 如果只是测试，至少在出错路径释放，或在此处释放（但无后续使用） */</span></span><br><span class="line">    gpiod_put(mygpio2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 实际驱动中，应在 remove 中释放所有获取的 GPIO */</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">&#123;.compatible=<span class="string">&quot;mygpio&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">gpiod_put(mygpio2);</span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="GPIO操作函数"><a href="#GPIO操作函数" class="headerlink" title="GPIO操作函数"></a>GPIO操作函数</h3><p><strong>头文件统一为：</strong> <code>#include &lt;linux/gpio/consumer.h&gt;</code></p><h4 id="获取-GPIO-方向"><a href="#获取-GPIO-方向" class="headerlink" title="获取 GPIO 方向"></a>获取 GPIO 方向</h4><p><strong>函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpiod_get_direction</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><p>查询 GPIO 当前配置为输入还是输出。</p><p><strong>返回值</strong></p><ul><li><code>GPIO_LINE_DIRECTION_IN</code>（0）：输入模式</li><li><code>GPIO_LINE_DIRECTION_OUT</code>（1）：输出模式</li><li>负数：错误码（如 <code>-EINVAL</code>）</li></ul><h4 id="配置-GPIO-方向"><a href="#配置-GPIO-方向" class="headerlink" title="配置 GPIO 方向"></a>配置 GPIO 方向</h4><h5 id="配置为输入"><a href="#配置为输入" class="headerlink" title="配置为输入"></a>配置为输入</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpiod_direction_input</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br></pre></td></tr></table></figure><h5 id="配置为输出（带初始电平）"><a href="#配置为输出（带初始电平）" class="headerlink" title="配置为输出（带初始电平）"></a>配置为输出（带初始电平）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpiod_direction_output</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>value</code>：0（低电平）或 1（高电平）</li></ul><p><strong>返回值（两者相同）</strong></p><ul><li><code>0</code>：成功</li><li>负数：失败（如 <code>-EINVAL</code>, <code>-ENODEV</code>）</li></ul><p><strong>注意事项</strong></p><ul><li>必须在读写 GPIO 前正确设置方向。</li><li>输出模式需指定初始电平，避免毛刺。</li></ul><hr><h4 id="读取-GPIO-电平（输入）"><a href="#读取-GPIO-电平（输入）" class="headerlink" title="读取 GPIO 电平（输入）"></a>读取 GPIO 电平（输入）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpiod_get_value</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><p>读取 GPIO 引脚当前物理电平（考虑 <code>ACTIVE_LOW</code> 映射后逻辑值）。</p><p><strong>返回值</strong></p><ul><li><code>0</code>：逻辑低电平</li><li><code>1</code>：逻辑高电平</li><li>负数：错误（罕见，通常仅在硬件异常时发生）</li></ul><p><strong>说明</strong></p><ul><li>即使 GPIO 配置为输出，也可读回其输出状态（部分控制器支持）。</li><li>返回的是<strong>逻辑值</strong>，已自动处理设备树中 <code>GPIO_ACTIVE_LOW</code> 的反转。</li></ul><h4 id="设置-GPIO-电平（输出）"><a href="#设置-GPIO-电平（输出）" class="headerlink" title="设置 GPIO 电平（输出）"></a>设置 GPIO 电平（输出）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpiod_set_value</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><code>value</code>：0（逻辑低）或 1（逻辑高）</li></ul><p><strong>返回值</strong></p><ul><li>无（<code>void</code>）</li></ul><p><strong>关键前提</strong></p><ul><li><strong>必须先将 GPIO 配置为输出模式</strong>（通过 <code>gpiod_direction_output()</code>）。</li><li>同样使用<strong>逻辑值</strong>，内核自动处理 <code>ACTIVE_LOW</code> 反转。</li></ul><h4 id="将-GPIO-转换为中断号"><a href="#将-GPIO-转换为中断号" class="headerlink" title="将 GPIO 转换为中断号"></a>将 GPIO 转换为中断号</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpiod_to_irq</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><p>获取与该 GPIO 关联的 Linux 中断号（IRQ number），用于注册中断处理程序。</p><p><strong>返回值</strong></p><ul><li>≥ 0：有效的中断号</li><li>负数：不支持中断或转换失败（如 <code>-ENXIO</code></li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uapi/linux/gpio.h&gt;</span>  <span class="comment">// for GPIO_LINE_DIRECTION_*</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">mygpio1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dir, value, irq;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is my_platform_probe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取可选 GPIO（配置为输出，初始低电平）</span></span><br><span class="line">    mygpio1 = gpiod_get_optional(&amp;pdev-&gt;dev, <span class="string">&quot;my&quot;</span>, GPIOD_OUT_LOW);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(mygpio1)) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get GPIO: %ld\n&quot;</span>, PTR_ERR(mygpio1));</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(mygpio1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mygpio1) &#123;</span><br><span class="line">        dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;Optional &#x27;my&#x27; GPIO not present\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为高电平（可选，因为 GPIOD_OUT_LOW 初始为低）</span></span><br><span class="line">    gpiod_set_value(mygpio1, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取方向</span></span><br><span class="line">    dir = gpiod_get_direction(mygpio1);</span><br><span class="line">    <span class="keyword">if</span> (dir == GPIO_LINE_DIRECTION_IN) &#123;</span><br><span class="line">        printk(<span class="string">&quot;dir is INPUT\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dir == GPIO_LINE_DIRECTION_OUT) &#123;</span><br><span class="line">        printk(<span class="string">&quot;dir is OUTPUT\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get direction: %d\n&quot;</span>, dir);</span><br><span class="line">        gpiod_put(mygpio1);</span><br><span class="line">        <span class="keyword">return</span> dir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取当前值</span></span><br><span class="line">    value = gpiod_get_value(mygpio1);</span><br><span class="line">    printk(<span class="string">&quot;value is %d\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中断号</span></span><br><span class="line">    irq = gpiod_to_irq(mygpio1);</span><br><span class="line">    <span class="keyword">if</span> (irq &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;GPIO does not support IRQ (err=%d)\n&quot;</span>, irq);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        printk(<span class="string">&quot;irq is %d\n&quot;</span>, irq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mygpio1 &amp;&amp; !IS_ERR(mygpio1)) &#123;</span><br><span class="line">        gpiod_put(mygpio1);</span><br><span class="line">        mygpio1 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Platform device removed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备树匹配表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">my_of_match</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;mygpio&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(of, my_of_match);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .of_match_table = my_of_match,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化与退出</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;My GPIO Platform Driver Example&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="三级节点操作函数"><a href="#三级节点操作函数" class="headerlink" title="三级节点操作函数"></a>三级节点操作函数</h3><p>在前面的示例中获取的都是二级节点的 GPIO 描述，那如果我们要如何获取下面 led1 和 led2 两个三级节点的 gpio 描述呢？</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">my_gpio:</span><span class="title class_">gpio1_a0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;mygpio&quot;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line">led1<span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">my-gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio1</span> RK_PA0 GPIO_ACTIVE_HIGH&gt;</span>, <span class="params">&lt;<span class="variable">&amp;gpio1</span> RK_PB1 GPIO_ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;mygpio_ctrl</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line">led2<span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">my-gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio1</span> RK_PB0 GPIO_ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><h4 id="device-get-child-node-count"><a href="#device-get-child-node-count" class="headerlink" title="device_get_child_node_count()"></a>device_get_child_node_count()</h4><p><strong>功能：获取设备的子节点数量</strong></p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">device_get_child_node_count</span><span class="params">(<span class="keyword">struct</span> device *dev)</span>;</span><br></pre></td></tr></table></figure><p><strong>头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><code>dev</code>：指向父设备的 <code>struct device</code> 指针。</li></ul><p><strong>返回值</strong></p><ul><li><strong>成功</strong>：返回子节点数量（≥ 0 的无符号整数）。</li><li><strong>无子节点或失败</strong>：返回 <code>0</code>。</li></ul><p><strong>说明</strong></p><ul><li>用于判断设备在设备树中是否包含子节点（如 LED、按键等子设备）。</li><li><p>常用于动态分配资源或决定是否进入子节点遍历逻辑。</p><p><strong>示例</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (device_get_child_node_count(&amp;pdev-&gt;dev) == <span class="number">0</span>) &#123;</span><br><span class="line">    dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;No child nodes\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fwnode-get-named-gpiod"><a href="#fwnode-get-named-gpiod" class="headerlink" title="fwnode_get_named_gpiod()"></a>fwnode_get_named_gpiod()</h4><p><strong>功能：从指定 firmware 节点（如设备树子节点）中获取命名 GPIO</strong></p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> gpio_desc *<span class="title function_">fwnode_get_named_gpiod</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> fwnode_handle *fwnode,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *propname,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> index,</span></span><br><span class="line"><span class="params">    <span class="keyword">enum</span> gpiod_flags dflags,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *label</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><strong>头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>fwnode</code></td><td>指向子节点的 <code>fwnode_handle</code>（通常来自 <code>device_get_next_child_node()</code>）</td></tr><tr><td><code>propname</code></td><td>GPIO 属性名（如 <code>&quot;led-gpios&quot;</code>、<code>&quot;enable-gpios&quot;</code>、<code>&quot;my-gpios&quot;</code>）</td></tr><tr><td><code>index</code></td><td>在属性中的索引（0 表示第一个 GPIO）</td></tr><tr><td><code>dflags</code></td><td>初始化标志： • <code>GPIOD_IN</code> • <code>GPIOD_OUT_LOW</code> • <code>GPIOD_OUT_HIGH</code> • <code>GPIOD_ASIS</code>（不配置方向）</td></tr><tr><td><code>label</code></td><td>GPIO 标签（用于调试，如 <code>&quot;my-led&quot;</code>）</td></tr></tbody></table></div><p>返回值</p><ul><li>成功：返回 <code>struct gpio_desc *</code></li><li>失败：返回 <code>ERR_PTR(...)</code>（注意：<strong>不是 NULL</strong>）</li></ul><blockquote><p>⚠️ <strong>重要</strong>：该函数返回的是 <strong>错误指针（ERR_PTR）</strong>，应使用 <code>IS_ERR()</code> 判断，而非检查 <code>NULL</code>。</p></blockquote><p><strong>使用场景</strong></p><ul><li>当设备树结构为“父设备 + 多个子节点”，每个子节点定义自己的 GPIO 时（如多个 LED）：</li></ul>  <figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">my_device &#123;</span><br><span class="line">    compatible = <span class="string">&quot;myvendor,my-device&quot;</span>;</span><br><span class="line">    <span class="comment">#address-cells = &lt;1&gt;;</span></span><br><span class="line">    <span class="comment">#size-cells = &lt;0&gt;;</span></span><br><span class="line"></span><br><span class="line">    led<span class="meta">@0</span> &#123;</span><br><span class="line">        reg = <span class="variable">&lt;0&gt;</span>;</span><br><span class="line">        led-gpios = <span class="variable">&lt;&amp;gpio1 10 GPIO_ACTIVE_HIGH&gt;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    led<span class="meta">@1</span> &#123;</span><br><span class="line">        reg = <span class="variable">&lt;1&gt;</span>;</span><br><span class="line">        led-gpios = <span class="variable">&lt;&amp;gpio1 11 GPIO_ACTIVE_LOW&gt;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>驱动:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">desc = fwnode_get_named_gpiod(child, <span class="string">&quot;led-gpios&quot;</span>, <span class="number">0</span>, GPIOD_OUT_LOW, <span class="string">&quot;my-led&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(desc)) &#123;</span><br><span class="line">    dev_err(dev, <span class="string">&quot;Failed to get GPIO: %ld\n&quot;</span>, PTR_ERR(desc));</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="device-get-next-child-node"><a href="#device-get-next-child-node" class="headerlink" title="device_get_next_child_node()"></a>device_get_next_child_node()</h4><p><strong>功能：遍历设备的所有子节点</strong></p><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> fwnode_handle *<span class="title function_">device_get_next_child_node</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> fwnode_handle *child</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><strong>头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li><code>dev</code>：父设备指针。</li><li><code>child</code>：当前子节点指针；<strong>首次调用时传 <code>NULL</code></strong>。</li></ul><p><strong>返回值</strong></p><ul><li>成功：返回下一个子节点的 <code>fwnode_handle *</code></li><li>遍历结束：返回 <code>NULL</code></li></ul><p><strong>遍历模式（标准用法）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">child</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((child = device_get_next_child_node(&amp;pdev-&gt;dev, child))) &#123;</span><br><span class="line">    <span class="comment">// 处理子节点，例如获取其 GPIO</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">desc</span> =</span> fwnode_get_named_gpiod(child, <span class="string">&quot;gpios&quot;</span>, <span class="number">0</span>, GPIOD_OUT_LOW, <span class="string">&quot;sub-gpio&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(desc)) &#123;</span><br><span class="line">        <span class="comment">/* 使用 desc */</span></span><br><span class="line">        gpiod_put(desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：不需要手动释放 child，内核自动管理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>🔔 <strong>注意</strong>：</p><ul><li><code>fwnode_handle</code> 由内核管理，<strong>不要手动释放</strong>。</li><li>遍历结束后自动停止，无需额外清理。</li></ul></blockquote><h4 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">child</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    count = device_get_child_node_count(&amp;pdev-&gt;dev);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;No child nodes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;Found %u child nodes\n&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((child = device_get_next_child_node(&amp;pdev-&gt;dev, child))) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line"></span><br><span class="line">        desc = fwnode_get_named_gpiod(child, <span class="string">&quot;my-gpios&quot;</span>, <span class="number">0</span>,</span><br><span class="line">                                      GPIOD_OUT_LOW, <span class="string">&quot;child-enable&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(desc)) &#123;</span><br><span class="line">            dev_warn(&amp;pdev-&gt;dev, <span class="string">&quot;Skip child: failed to get GPIO (%ld)\n&quot;</span>, PTR_ERR(desc));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gpiod_set_value(desc, <span class="number">1</span>); <span class="comment">// 启用子设备</span></span><br><span class="line">        msleep(<span class="number">10</span>);</span><br><span class="line">        gpiod_set_value(desc, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        gpiod_put(desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GPIO子系统与pinctrl"><a href="#GPIO子系统与pinctrl" class="headerlink" title="GPIO子系统与pinctrl"></a>GPIO子系统与pinctrl</h3><p><strong>头文件统一为：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pinctrl/pinctrl.h&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="获取-pinctrl-实例"><a href="#获取-pinctrl-实例" class="headerlink" title="获取 pinctrl 实例"></a>获取 pinctrl 实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pinctrl *<span class="title function_">pinctrl_get</span><span class="params">(<span class="keyword">struct</span> device *dev)</span>;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><p>获取与设备 <code>dev</code> 关联的 pinctrl 控制器实例。</p><p><strong>参数</strong></p><ul><li><code>dev</code>：指向设备的 <code>struct device</code> 指针（通常为 <code>&amp;pdev-&gt;dev</code>）。</li></ul><p><strong>返回值</strong></p><ul><li>成功：返回 <code>struct pinctrl *</code></li><li>失败或设备无 pinctrl 支持：返回 <code>ERR_PTR(...)</code>（<strong>注意：不是 NULL</strong>）</li></ul><blockquote><p>⚠️ <strong>重要</strong>：该函数返回的是 <strong>错误指针（ERR_PTR）</strong>，应使用 <code>IS_ERR()</code> 判断！</p></blockquote><p><strong>用法示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = pinctrl_get(&amp;pdev-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(p)) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get pinctrl\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="释放-pinctrl-实例"><a href="#释放-pinctrl-实例" class="headerlink" title="释放 pinctrl 实例"></a>释放 pinctrl 实例</h4><p><strong>函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pinctrl_put</span><span class="params">(<span class="keyword">struct</span> pinctrl *p)</span>;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><p>释放由 <code>pinctrl_get()</code> 获取的 pinctrl 实例，减少引用计数，必要时释放资源。</p><p><strong>参数</strong></p><ul><li><code>p</code>：要释放的 <code>struct pinctrl *</code> 指针。</li></ul><p><strong>注意事项</strong></p><ul><li>允许传入 <code>NULL</code> 或 <code>ERR_PTR</code>（内部会安全处理）。</li><li>通常在驱动 <code>remove()</code> 或出错路径中调用。</li></ul><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!IS_ERR(p))</span><br><span class="line">    pinctrl_put(p);</span><br></pre></td></tr></table></figure><h4 id="查找-pinctrl-状态"><a href="#查找-pinctrl-状态" class="headerlink" title="查找 pinctrl 状态"></a>查找 pinctrl 状态</h4><p><strong>函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pinctrl_state *<span class="title function_">pinctrl_lookup_state</span><span class="params">(<span class="keyword">struct</span> pinctrl *p, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><p>在 pinctrl 实例 <code>p</code> 中查找名为 <code>name</code> 的状态（如 <code>&quot;default&quot;</code>、<code>&quot;sleep&quot;</code>）。</p><p><strong>参数</strong></p><ul><li><code>p</code>：有效的 pinctrl 实例指针。</li><li><code>name</code>：状态名称（字符串），必须与设备树中定义的 state 名称一致。</li></ul><p><strong>返回值</strong></p><ul><li>成功：返回 <code>struct pinctrl_state *</code></li><li>失败（未找到或错误）：返回 <code>ERR_PTR(...)</code></li></ul><blockquote><p>⚠️ 同样需用 <code>IS_ERR()</code> 判断！</p></blockquote><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">state = pinctrl_lookup_state(p, <span class="string">&quot;default&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(state)) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to lookup &#x27;default&#x27; state\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用-pinctrl-状态到硬件"><a href="#应用-pinctrl-状态到硬件" class="headerlink" title="应用 pinctrl 状态到硬件"></a>应用 pinctrl 状态到硬件</h4><p><strong>函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pinctrl_select_state</span><span class="params">(<span class="keyword">struct</span> pinctrl *p, <span class="keyword">struct</span> pinctrl_state *s)</span>;</span><br></pre></td></tr></table></figure><p><strong>功能</strong></p><p>将指定的状态 <code>s</code> 配置到硬件引脚控制器上，实际生效引脚复用和电气设置。</p><p><strong>参数</strong></p><ul><li><code>p</code>：pinctrl 实例</li><li><code>s</code>：目标状态</li></ul><p><strong>返回值</strong></p><ul><li><code>0</code>：成功</li><li>负数：错误码（如 <code>-EINVAL</code>, <code>-ENODEV</code>）</li></ul><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = pinctrl_select_state(p, state);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to select pinctrl state: %d\n&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整使用流程示例"><a href="#完整使用流程示例" class="headerlink" title="完整使用流程示例"></a>完整使用流程示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pinctrl/pinctrl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">pinctrl</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">pins_default</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">pins_sleep</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_driver_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 获取 pinctrl */</span></span><br><span class="line">    pinctrl = pinctrl_get(&amp;pdev-&gt;dev);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(pinctrl)) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get pinctrl\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(pinctrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 查找状态 */</span></span><br><span class="line">    pins_default = pinctrl_lookup_state(pinctrl, <span class="string">&quot;default&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(pins_default)) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to lookup &#x27;default&#x27; state\n&quot;</span>);</span><br><span class="line">        ret = PTR_ERR(pins_default);</span><br><span class="line">        <span class="keyword">goto</span> err_put_pinctrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pins_sleep = pinctrl_lookup_state(pinctrl, <span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(pins_sleep)) &#123;</span><br><span class="line">        dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;No &#x27;sleep&#x27; state defined\n&quot;</span>);</span><br><span class="line">        pins_sleep = <span class="literal">NULL</span>; <span class="comment">// 可选状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 应用默认状态 */</span></span><br><span class="line">    ret = pinctrl_select_state(pinctrl, pins_default);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to select default state\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_put_pinctrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_put_pinctrl:</span><br><span class="line">    pinctrl_put(pinctrl);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_driver_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(pinctrl))</span><br><span class="line">        pinctrl_put(pinctrl);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对应的设备树示例"><a href="#对应的设备树示例" class="headerlink" title="对应的设备树示例"></a>对应的设备树示例</h4><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">my_device:</span> <span class="title class_">my-device@0</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;myvendor,my-device&quot;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span>, <span class="string">&quot;sleep&quot;</span><span class="punctuation">;</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;my_pins_default</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    pinctrl<span class="number">-1</span> = <span class="params">&lt;<span class="variable">&amp;my_pins_sleep</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他属性 */</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">&amp;pinctrl</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">    my_pins_default:</span> <span class="title class_">my-pins-default</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">pinmux</span> <span class="operator">=</span> <span class="params">&lt;PIN_FUNC_3(PIN_X)&gt;</span>, <span class="comment">/* 复用为功能3 */</span></span><br><span class="line">                 <span class="params">&lt;PIN_FUNC_1(PIN_Y)&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">bias-pull-up</span><span class="punctuation">;</span>      <span class="comment">/* 上拉 */</span></span><br><span class="line">        <span class="attr">drive-strength</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">8</span>&gt;</span><span class="punctuation">;</span> <span class="comment">/* 8mA 驱动能力 */</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">    my_pins_sleep:</span> <span class="title class_">my-pins-sleep</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">pinmux</span> <span class="operator">=</span> <span class="params">&lt;PIN_FUNC_0(PIN_X)&gt;</span>, <span class="comment">/* 进入 GPIO 模式 */</span></span><br><span class="line">                 <span class="params">&lt;PIN_FUNC_0(PIN_Y)&gt;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">bias-disable</span><span class="punctuation">;</span>      <span class="comment">/* 禁用上下拉 */</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><blockquote><p>🔑 关键点：</p><ul><li><code>pinctrl-names</code> 定义状态名称列表</li><li><code>pinctrl-0</code>, <code>pinctrl-1</code> 对应索引 0、1 的状态</li><li>驱动中通过名称（如 <code>&quot;default&quot;</code>）查找状态</li></ul></blockquote><hr><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><div class="table-container"><table><thead><tr><th>场景</th><th>建议</th></tr></thead><tbody><tr><td><strong>仅需默认配置</strong></td><td>可不显式调用 pinctrl API，内核会在 probe 时自动应用 <code>pinctrl-0</code>（若 <code>pinctrl-names</code> 包含 <code>&quot;default&quot;</code>）</td></tr><tr><td><strong>动态切换状态</strong></td><td>如 suspend/resume 时切换到 <code>&quot;sleep&quot;</code> 状态</td></tr><tr><td><strong>错误处理</strong></td><td>所有返回指针的函数都可能返回 <code>ERR_PTR</code>，务必用 <code>IS_ERR()</code> 检查</td></tr><tr><td><strong>资源释放</strong></td><td>在 <code>remove()</code> 中调用 <code>pinctrl_put()</code></td></tr></tbody></table></div><h3 id="实现动态切换引脚复用功能"><a href="#实现动态切换引脚复用功能" class="headerlink" title="实现动态切换引脚复用功能"></a>实现动态切换引脚复用功能</h3><p>这里仍使用 RK3568 底板背面的 20 pin GPIO 底座的 1 号管脚来完成本章节要进行的动态切换引脚复用的功能</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">my_gpio:</span><span class="title class_">gpio1_a0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;mygpio&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">my-gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio1</span> RK_PA0 GPIO_ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;mygpio_func1&quot;</span>, <span class="string">&quot;mygpio_func2&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;mygpio_ctrl</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-1</span> = <span class="params">&lt;<span class="variable">&amp;i2c3_sda</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><code>pinctrl-names</code> 表示引脚控制器配置的名称，这里有两个值，分别对应复用 1 和复用 2。</li><li><code>pinctrl-0</code> 指定了与该配置相关联的引脚控制器句柄，这里为 <code>&amp;mygpio_ctrl</code>，表示复用为 gpio 功能。</li><li><code>pinctrl-1</code> 指定了与该配置相关联的引脚控制器句柄，这里为 <code>&amp;i2c3_sda</code>，表示复用为<code>i2c3_sda</code> 功能。</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">mygpio_func1</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">mygpio_ctrl:</span> <span class="title class_">my-gpio-ctrl</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">rockchip,pins</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span> RK_PA0 RK_FUNC_GPIO <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">mygpio_func2</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">i2c3_sda:</span> <span class="title class_">i2c3_sda</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">rockchip,pins</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span> RK_PA0 <span class="number">1</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>驱动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mod_devicetable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">gpio_pinctrl</span>;</span>          <span class="comment">// GPIO pinctrl 实例指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">func1_state</span>;</span>     <span class="comment">// 功能1状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">func2_state</span>;</span>     <span class="comment">// 功能2状态</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">selectmux_store</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> select;</span><br><span class="line">    select = simple_strtoul(buf, <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (select == <span class="number">1</span>) &#123;</span><br><span class="line">        pinctrl_select_state(gpio_pinctrl, func1_state);     <span class="comment">// 选择功能1状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">0</span>) &#123;</span><br><span class="line">        pinctrl_select_state(gpio_pinctrl, func2_state);     <span class="comment">// 选择功能2状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义可写的设备属性 selectmux</span></span><br><span class="line">DEVICE_ATTR_WO(selectmux);       </span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// static struct device_attribute dev_attr_selectmux = &#123;</span></span><br><span class="line"><span class="comment">//    .attr = &#123; .name = &quot;selectmux&quot;, .mode = S_IWUSR &#125;,  // 只写，权限 0200</span></span><br><span class="line"><span class="comment">//    .show = NULL,</span></span><br><span class="line"><span class="comment">//    .store = selectmux_store,   </span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinctrl_get_and_lookstate</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    gpio_pinctrl = pinctrl_get(dev);    <span class="comment">// 获取GPIO pinctrl实例</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(gpio_pinctrl)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;pinctrl_get is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func1_state = pinctrl_lookup_state(gpio_pinctrl, <span class="string">&quot;mygpio_func1&quot;</span>);    <span class="comment">// 查找功能1状态</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(func1_state)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;pinctrl_lookup_state is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func2_state = pinctrl_lookup_state(gpio_pinctrl, <span class="string">&quot;mygpio_func2&quot;</span>);    <span class="comment">// 查找功能2状态</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(func2_state)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;pinctrl_lookup_state is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;This is mydriver_probe\n&quot;</span>);</span><br><span class="line">    pinctrl_get_and_lookstate(&amp;dev-&gt;dev);     <span class="comment">// 获取并查找GPIO pinctrl实例和状态</span></span><br><span class="line">    device_create_file(&amp;dev-&gt;dev, &amp;dev_attr_selectmux);    <span class="comment">// 在设备上创建属性文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_platform_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_remove: Removing platform device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理设备特定的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_table_id</span>[]  =</span> &#123;</span><br><span class="line">&#123;.compatible=<span class="string">&quot;mygpio&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">my_platform_driver</span> =</span> &#123;</span><br><span class="line">    .probe = my_platform_probe,</span><br><span class="line">    .remove = my_platform_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my_platform_device&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">.of_match_table =  of_match_table_id,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_platform_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;my_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver initialized\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_platform_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;my_platform_driver);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_platform_driver: Platform driver exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_platform_driver_init);</span><br><span class="line">module_exit(my_platform_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux gpio子系统</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
    <category term="driver" scheme="https://even629.com/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>面试经典150题 P188 买卖股票的最佳时机 IV</title>
    <link href="https://even629.com/posts/188/"/>
    <id>https://even629.com/posts/188/</id>
    <published>2025-12-17T04:22:13.000Z</published>
    <updated>2025-12-17T04:22:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-17</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P188 买卖股票的最佳时机 IV" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P188 买卖股票的最佳时机 IV</p><p class="url">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>和下面这题类似：<br><div class="tag link"><a class="link-card" title="P123 买卖股票的最佳时机 III" href="https://even629.com/posts/123/"><div class="left"><img src="https://even629.com/img/favicon.ico"/></div><div class="right"><p class="text">P123 买卖股票的最佳时机 III</p><p class="url">https://even629.com/posts/123/</p></div></a></div></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt; &amp;prices)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="type">int</span> i, j, n = prices.<span class="built_in">size</span>();</span><br><span class="line">                <span class="type">int</span> nr_state = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// dp[i][j]表示第i天的第j个状态的最大利润</span></span><br><span class="line">                vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nr_state, <span class="number">0</span>));</span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; nr_state; j++) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">-1e9</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; nr_state; j += <span class="number">2</span>) &#123;</span><br><span class="line">                                dp[i][j] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; nr_state; j += <span class="number">2</span>) &#123;</span><br><span class="line">                                dp[i][j] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + prices[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> *std::<span class="built_in">max_element</span>(dp[n - <span class="number">1</span>].<span class="built_in">begin</span>(), dp[n - <span class="number">1</span>].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
    
    
    <summary type="html">动态规划</summary>
    
    
    
    <category term="algorithm" scheme="https://even629.com/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://even629.com/tags/algorithm/"/>
    
    <category term="动态规划" scheme="https://even629.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="leetcode面试经典150题" scheme="https://even629.com/tags/leetcode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试经典150题 P123 买卖股票的最佳时机 III</title>
    <link href="https://even629.com/posts/123/"/>
    <id>https://even629.com/posts/123/</id>
    <published>2025-12-17T04:17:13.000Z</published>
    <updated>2025-12-17T04:17:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-17</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P123 买卖股票的最佳时机 III" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P123 买卖股票的最佳时机 III</p><p class="url">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>状态转移，注意初始化不要用INT_MIN，会导致后面计算溢出<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;prices)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="type">int</span> i, n = prices.<span class="built_in">size</span>();</span><br><span class="line">                <span class="type">int</span> max_profit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// dp[i][j]表示到第i天第j个状态的最大利润</span></span><br><span class="line">                <span class="comment">// dp[i][0]表示没有买入，dp[i][1]表示已经第一次买入，dp[i][2]表示第一次卖出</span></span><br><span class="line">                <span class="comment">// dp[i][3]表示第二次买入，dp[i][4]表示第二次卖出</span></span><br><span class="line">                vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">-1e9</span>;</span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">-1e9</span>;</span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">-1e9</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 每一天可以选择不买入，买入，或卖出（当且仅当已经买入过）</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                        <span class="comment">// 没有买入的前一个状态是没有买入</span></span><br><span class="line">                        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 第一次买入的前一个状态是没有买入，沿用昨天状态或买入今天股票</span></span><br><span class="line">                        dp[i][<span class="number">1</span>] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 第一次卖出的前一个状态是第一次买入，沿用昨天状态或卖出今天股票</span></span><br><span class="line">                        dp[i][<span class="number">2</span>] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 第二次买入的前一个状态是第一次卖出，沿用昨天状态或买入今天股票</span></span><br><span class="line">                        dp[i][<span class="number">3</span>] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 第二次卖出的前一个状态是第二次买入，沿用昨天状态或卖出今天股票</span></span><br><span class="line">                        dp[i][<span class="number">4</span>] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line"></span><br><span class="line">                        max_profit = std::<span class="built_in">max</span>(&#123; dp[i][<span class="number">0</span>], dp[i][<span class="number">2</span>], dp[i][<span class="number">4</span>], max_profit &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> max_profit;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><!-- flag of hidden posts -->]]></content>
    
    
    <summary type="html">动态规划</summary>
    
    
    
    <category term="algorithm" scheme="https://even629.com/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://even629.com/tags/algorithm/"/>
    
    <category term="动态规划" scheme="https://even629.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="leetcode面试经典150题" scheme="https://even629.com/tags/leetcode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Linux pinctrl 子系统</title>
    <link href="https://even629.com/posts/2512160/"/>
    <id>https://even629.com/posts/2512160/</id>
    <published>2025-12-16T07:47:13.000Z</published>
    <updated>2025-12-16T07:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-16</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="pinctrl设备树"><a href="#pinctrl设备树" class="headerlink" title="pinctrl设备树"></a>pinctrl设备树</h1><p><strong>arch/arm64/boot/dts/rk3568.dtsi</strong></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">pinctrl:</span> <span class="title class_">pinctrl</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,rk3568-pinctrl&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">rockchip,grf</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;grf</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">rockchip,pmu</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;pmugrf</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;2&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;2&gt;;</span></span><br><span class="line"><span class="attr">ranges</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">gpio0:</span> <span class="title class_">gpio0@fdd60000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,gpio-bank&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfdd60000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;pmucru</span> PCLK_GPIO0&gt;</span>, <span class="params">&lt;<span class="variable">&amp;pmucru</span> DBCLK_GPIO0&gt;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">gpio-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#gpio-cells = &lt;2&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;2&gt;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">gpio1:</span> <span class="title class_">gpio1@fe740000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,gpio-bank&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe740000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">34</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_GPIO1&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> DBCLK_GPIO1&gt;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">gpio-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#gpio-cells = &lt;2&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;2&gt;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">gpio2:</span> <span class="title class_">gpio2@fe750000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,gpio-bank&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe750000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">35</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_GPIO2&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> DBCLK_GPIO2&gt;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">gpio-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#gpio-cells = &lt;2&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;2&gt;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">gpio3:</span> <span class="title class_">gpio3@fe760000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,gpio-bank&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe760000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_GPIO3&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> DBCLK_GPIO3&gt;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">gpio-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#gpio-cells = &lt;2&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;2&gt;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">gpio4:</span> <span class="title class_">gpio4@fe770000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,gpio-bank&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe770000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">37</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_GPIO4&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> DBCLK_GPIO4&gt;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">gpio-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#gpio-cells = &lt;2&gt;;</span></span><br><span class="line"><span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#interrupt-cells = &lt;2&gt;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>GPIO 引脚 ⊂ SoC 引脚，而SoC 引脚 由 pinctrl 统一管理，Linux 官方 pinctrl binding 推荐：<strong>GPIO controller 作为 pin controller 的子节点</strong></p><div class="table-container"><table><thead><tr><th>GPIO bank</th><th>名称</th><th>管脚数</th><th>基地址</th></tr></thead><tbody><tr><td>GPIO0</td><td>gpio0</td><td>32</td><td>0xfdd60000</td></tr><tr><td>GPIO1</td><td>gpio1</td><td>32</td><td>0xfe740000</td></tr><tr><td>GPIO2</td><td>gpio2</td><td>32</td><td>0xfe750000</td></tr><tr><td>GPIO3</td><td>gpio3</td><td>32</td><td>0xfe760000</td></tr><tr><td>GPIO4</td><td>gpio4</td><td>32</td><td>0xfe770000</td></tr></tbody></table></div><p><strong>每个 bank：</strong></p><ul><li>一套寄存器</li><li>一个中断号</li><li>两个时钟（PCLK / DBCLK）</li><li>控制一组物理引脚的：方向、电平、GPIO 中断</li></ul><p><strong>arch/arm64/boot/dts/rockchip/rk3568-pinctrl.dtsi</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&amp;pinctrl &#123;</span><br><span class="line">acodec &#123;</span><br><span class="line">/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">acodec_pins: acodec-pins &#123;</span><br><span class="line">rockchip,pins =</span><br><span class="line"><span class="comment">/* acodec_adc_sync */</span></span><br><span class="line">&lt;<span class="number">1</span> RK_PB1 <span class="number">5</span> &amp;pcfg_pull_none&gt;,</span><br><span class="line"><span class="comment">/* acodec_adcclk */</span></span><br><span class="line">&lt;<span class="number">1</span> RK_PA1 <span class="number">5</span> &amp;pcfg_pull_none&gt;,</span><br><span class="line"><span class="comment">/* acodec_adcdata */</span></span><br><span class="line">&lt;<span class="number">1</span> RK_PA0 <span class="number">5</span> &amp;pcfg_pull_none&gt;,</span><br><span class="line"><span class="comment">/* acodec_dac_datal */</span></span><br><span class="line">&lt;<span class="number">1</span> RK_PA7 <span class="number">5</span> &amp;pcfg_pull_none&gt;,</span><br><span class="line"><span class="comment">/* acodec_dac_datar */</span></span><br><span class="line">&lt;<span class="number">1</span> RK_PB0 <span class="number">5</span> &amp;pcfg_pull_none&gt;,</span><br><span class="line"><span class="comment">/* acodec_dacclk */</span></span><br><span class="line">&lt;<span class="number">1</span> RK_PA3 <span class="number">5</span> &amp;pcfg_pull_none&gt;,</span><br><span class="line"><span class="comment">/* acodec_dacsync */</span></span><br><span class="line">&lt;<span class="number">1</span> RK_PA5 <span class="number">5</span> &amp;pcfg_pull_none&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">audiopwm &#123;</span><br><span class="line">/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">audiopwm_lout: audiopwm-lout &#123;</span><br><span class="line">rockchip,pins =</span><br><span class="line"><span class="comment">/* audiopwm_lout */</span></span><br><span class="line">&lt;<span class="number">1</span> RK_PA0 <span class="number">4</span> &amp;pcfg_pull_none&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">audiopwm_loutn: audiopwm-loutn &#123;</span><br><span class="line">rockchip,pins =</span><br><span class="line"><span class="comment">/* audiopwm_loutn */</span></span><br><span class="line">&lt;<span class="number">1</span> RK_PA1 <span class="number">6</span> &amp;pcfg_pull_none&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">audiopwm_loutp: audiopwm-loutp &#123;</span><br><span class="line">rockchip,pins =</span><br><span class="line"><span class="comment">/* audiopwm_loutp */</span></span><br><span class="line">&lt;<span class="number">1</span> RK_PA0 <span class="number">6</span> &amp;pcfg_pull_none&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">audiopwm_rout: audiopwm-rout &#123;</span><br><span class="line">rockchip,pins =</span><br><span class="line"><span class="comment">/* audiopwm_rout */</span></span><br><span class="line">&lt;<span class="number">1</span> RK_PA1 <span class="number">4</span> &amp;pcfg_pull_none&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">audiopwm_routn: audiopwm-routn &#123;</span><br><span class="line">rockchip,pins =</span><br><span class="line"><span class="comment">/* audiopwm_routn */</span></span><br><span class="line">&lt;<span class="number">1</span> RK_PA7 <span class="number">4</span> &amp;pcfg_pull_none&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">audiopwm_routp: audiopwm-routp &#123;</span><br><span class="line">rockchip,pins =</span><br><span class="line"><span class="comment">/* audiopwm_routp */</span></span><br><span class="line">&lt;<span class="number">1</span> RK_PA6 <span class="number">4</span> &amp;pcfg_pull_none&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">    ...</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>无论是 rk3568.dtsi 设备树中的 pinctrl 节点，还是上面 rk3568-pinctrl.dtsi 设备树中的一系列复用关系都是由瑞芯微原厂 BSP 工程师编写的，我们只需知道如何使用即可，而 pinctrl 客户端设备树是由我们自己根据特定需求来编写的</p><p>pinctrl驱动</p><p>设备树中存放的只是设备的描述信息，而具体的功能实现取决于相应的 pinctrl 驱动。</p><p>根据rk3568.dtsi <strong>设备树中 pinctrl 节点的 compatible 属性</strong>进行查找驱动，可以查找到 pinctrl 的驱动文件是内核源码的<code>driver/pinctrl/pinctrl-rockchip.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">rockchip_pinctrl_dt_match</span>[] =</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CPU_RK3568</span></span><br><span class="line">&#123; .compatible = <span class="string">&quot;rockchip,rk3568-pinctrl&quot;</span>,</span><br><span class="line">.data = &amp;rk3568_pin_ctrl &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">rockchip_pinctrl_driver</span> =</span> &#123;</span><br><span class="line">.probe= rockchip_pinctrl_probe,</span><br><span class="line">.remove= rockchip_pinctrl_remove,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name= <span class="string">&quot;rockchip-pinctrl&quot;</span>,</span><br><span class="line">.pm = &amp;rockchip_pinctrl_dev_pm_ops,</span><br><span class="line">.of_match_table = rockchip_pinctrl_dt_match,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">rockchip_pinctrl_drv_register</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> platform_driver_register(&amp;rockchip_pinctrl_driver);</span><br><span class="line">&#125;</span><br><span class="line">postcore_initcall(rockchip_pinctrl_drv_register);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">rockchip_pinctrl_drv_unregister</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">platform_driver_unregister(&amp;rockchip_pinctrl_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_exit(rockchip_pinctrl_drv_unregister);</span><br></pre></td></tr></table></figure><p>可以看到pinctrl 驱动使用的是 platform 总线，使用<code>postcore_initcall</code>而非<code>module_init</code></p><h2 id="groups和function"><a href="#groups和function" class="headerlink" title="groups和function"></a>groups和function</h2><p>Pinctrl 子系统中，有两个关键概念：引脚组（groups）和功能（function），在介绍 pinctrl子系统函数操作集之前，首先对 groups 和 function 进行讲解。</p><ul><li>引脚组（Groups）引脚组是一组具有相似功能、约束条件或共同工作的引脚的集合。每个引脚组通常与特定的硬件功能或外设相关联。例如，一个引脚组可以用于控制串行通信接口（如 UART 或 SPI），另一个引脚组可以用于驱动 GPIO。</li><li>功能（Function）：定义了芯片上具有外设功能的功能。每个功能节点对应于一个或多个 IO 组（group）的配置信息。这些功能可以是串口、SPI、I2C 等外设功能。</li></ul><p>接下来以 rk3568-pinctrl.dtsi 设备树文件中的 can0 和 can1 两个功能为例对上面的内容进行举例，具体内容如下所示：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">can0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="keyword">/omit-if-no-ref/</span></span><br><span class="line"><span class="symbol">can0m0_pins:</span> <span class="title class_">can0m0-pins</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">rockchip,pins</span> <span class="operator">=</span></span><br><span class="line"><span class="comment">/* can0_rxm0 */</span></span><br><span class="line"><span class="params">&lt;<span class="number">0</span> RK_PB4 <span class="number">2</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line"><span class="comment">/* can0_txm0 */</span></span><br><span class="line"><span class="params">&lt;<span class="number">0</span> RK_PB3 <span class="number">2</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">/omit-if-no-ref/</span></span><br><span class="line"><span class="symbol">can0m1_pins:</span> <span class="title class_">can0m1-pins</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">rockchip,pins</span> <span class="operator">=</span></span><br><span class="line"><span class="comment">/* can0_rxm1 */</span></span><br><span class="line"><span class="params">&lt;<span class="number">2</span> RK_PA2 <span class="number">4</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line"><span class="comment">/* can0_txm1 */</span></span><br><span class="line"><span class="params">&lt;<span class="number">2</span> RK_PA1 <span class="number">4</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">can1</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="keyword">/omit-if-no-ref/</span></span><br><span class="line"><span class="symbol">can1m0_pins:</span> <span class="title class_">can1m0-pins</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">rockchip,pins</span> <span class="operator">=</span></span><br><span class="line"><span class="comment">/* can1_rxm0 */</span></span><br><span class="line"><span class="params">&lt;<span class="number">1</span> RK_PA0 <span class="number">3</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line"><span class="comment">/* can1_txm0 */</span></span><br><span class="line"><span class="params">&lt;<span class="number">1</span> RK_PA1 <span class="number">3</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">/omit-if-no-ref/</span></span><br><span class="line"><span class="symbol">can1m1_pins:</span> <span class="title class_">can1m1-pins</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">rockchip,pins</span> <span class="operator">=</span></span><br><span class="line"><span class="comment">/* can1_rxm1 */</span></span><br><span class="line"><span class="params">&lt;<span class="number">4</span> RK_PC2 <span class="number">3</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line"><span class="comment">/* can1_txm1 */</span></span><br><span class="line"><span class="params">&lt;<span class="number">4</span> RK_PC3 <span class="number">3</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>在上面的设备树中，<strong>can0 和 can1 对应两个不同的 function</strong>，<strong>分别为 CAN0 控制器和 CAN1 控制器</strong>。<strong>每个控制器中又都有两个不同的 groups 引脚组</strong>。</p><ul><li>CAN0 控制器：<ul><li>引脚组 can0m0-pins：这是 CAN0 控制器的第一个引脚组，用于配置 CAN0 的引脚。它定义了两个引脚：RK_PB4 和 RK_PB3<ul><li>RK_PB4 用于 CAN0 的接收引脚（can0_rxm0）</li><li>RK_PB3 用于 CAN0 的发送引脚（can0_txm0）。</li></ul></li><li>引脚组 can0m1-pins：这是 CAN0 控制器的第二个引脚组，也用于配置 CAN0 的引脚。它定义了两个引脚：RK_PA2 和 RK_PA1。<ul><li>RK_PA2 用于 CAN0 的接收引脚（can0_rxm1）</li><li>RK_PA1 用于 CAN0 的发送引脚（can0_txm1）。</li></ul></li></ul></li><li>CAN1 控制器：<ul><li>引脚组 can1m0-pins：这是 CAN1 控制器的第一个引脚组，用于配置 CAN1 的引脚。它定义了两个引脚：RK_PA0 和 RK_PA1。<ul><li>RK_PA0 用于 CAN1 的接收引脚（can1_rxm0）</li><li>RK_PA1 用于 CAN1 的发送引脚（can1_txm0）。</li></ul></li><li>引脚组 can1m1-pins：这是 CAN1 控制器的第二个引脚组，也用于配置 CAN1 的引脚。它定义了两个引脚：RK_PC2 和 RK_PC3。<ul><li>RK_PC2 用于 CAN1 的接收引脚（can1_rxm1）</li><li>RK_PC3 用于 CAN1 的发送引脚（can1_txm1）。</li></ul></li></ul></li></ul><p>在<code>struct rockchip_pinctrl</code>结构体中:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regmap</span>*<span class="title">regmap_base</span>;</span><span class="comment">// 基本寄存器映射指针</span></span><br><span class="line"><span class="type">int</span>reg_size;<span class="comment">// 寄存器大小</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regmap</span>*<span class="title">regmap_pull</span>;</span><span class="comment">// 拉取寄存器映射指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regmap</span>*<span class="title">regmap_pmu</span>;</span><span class="comment">// 电源管理单元寄存器映射指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span>*<span class="title">dev</span>;</span><span class="comment">// 设备指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_ctrl</span>*<span class="title">ctrl</span>;</span><span class="comment">// 瑞芯微芯片引脚控制器指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span><span class="title">pctl</span>;</span><span class="comment">// 引脚控制器描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span>*<span class="title">pctl_dev</span>;</span><span class="comment">// 引脚控制器设备指针</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_group</span>*<span class="title">groups</span>;</span><span class="comment">// 瑞芯微芯片引脚组指针</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>ngroups;<span class="comment">// 引脚组数量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pmx_func</span>*<span class="title">functions</span>;</span><span class="comment">// 瑞芯微芯片引脚功能指针</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>nfunctions;<span class="comment">// 引脚功能数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="rockchip-pinctrl-probe"><a href="#rockchip-pinctrl-probe" class="headerlink" title="rockchip_pinctrl_probe()"></a>rockchip_pinctrl_probe()</h1><p>瑞芯微的pinctrl驱动函数中的probe函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pinctrl_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span>;</span> <span class="comment">// Rockchip GPIO 控制器的信息结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;pdev-&gt;dev; <span class="comment">// 设备结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> dev-&gt;of_node, *node; <span class="comment">// 设备节点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_ctrl</span> *<span class="title">ctrl</span>;</span> <span class="comment">// Rockchip GPIO 控制器的配置结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span><span class="comment">// 设备资源指针</span></span><br><span class="line"><span class="type">void</span> __iomem *base;<span class="comment">// 寄存器基地址指针</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查设备结构体中的设备树节点是否存在，如果不存在则报错并返回错误码</span></span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;of_node)</span><br><span class="line"><span class="keyword">return</span> dev_err_probe(dev, -ENODEV, <span class="string">&quot;device tree node not found\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 使用 devm_kzalloc 函数分配一个 rockchip_pinctrl 结构体的内存，并将其初始化为 0</span></span><br><span class="line">info = devm_kzalloc(dev, <span class="keyword">sizeof</span>(*info), GFP_KERNEL);<span class="comment">// 分配并初始化一个 rockchip_pinctrl 结构体</span></span><br><span class="line"><span class="keyword">if</span> (!info)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将设备结构体指针赋值给 info-&gt;dev，以便在后续代码中可以使用设备结构体的信息。  </span></span><br><span class="line">info-&gt;dev = dev;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 调用 rockchip_pinctrl_get_soc_data 函数，根据设备信息获取与该设备相关的 rockchip_pin_ctrl 结构体。如果获取失败，则报错并返回错误码。</span></span><br><span class="line">ctrl = rockchip_pinctrl_get_soc_data(info, pdev); <span class="comment">// 获取并设置与 pdev 相关的 rockchip_pin_ctrl 结构体</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (!ctrl)</span><br><span class="line"><span class="keyword">return</span> dev_err_probe(dev, -EINVAL, <span class="string">&quot;driver data not available\n&quot;</span>);</span><br><span class="line">info-&gt;ctrl = ctrl;<span class="comment">/* 将获取到的结构体指针赋值给 info-&gt;ctrl */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用 of_parse_phandle 函数解析设备树中名为&quot;rockchip,grf&quot;的节点。 */</span></span><br><span class="line">node = of_parse_phandle(np, <span class="string">&quot;rockchip,grf&quot;</span>, <span class="number">0</span>);<span class="comment">// 解析设备树中的&quot;rockchip,grf&quot;节点，获取寄存器映射基地址</span></span><br><span class="line"><span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 如果解析成功，则调用 syscon_node_to_regmap 函数将节点转换为寄存器映射的基地址，并将结果存储在 info-&gt;regmap_base中</span></span><br><span class="line">info-&gt;regmap_base = syscon_node_to_regmap(node);</span><br><span class="line">of_node_put(node);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(info-&gt;regmap_base))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(info-&gt;regmap_base);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果找不到&quot;rockchip,grf&quot;节点，则获取 IORESOURCE_MEM 类型的资源，得到寄存器基地址</span></span><br><span class="line">        <span class="comment">/*通过 platform_get_resource 函数获取 IORESOURCE_MEM 类型的资源，以获取寄存器的基地址。然后使用 devm_ioremap_resource 函数将资源映射到内存中，并将结果存储在 base中。 */</span></span><br><span class="line">base = devm_platform_get_and_ioremap_resource(pdev, <span class="number">0</span>, &amp;res);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(base))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(base);</span><br><span class="line"><span class="comment">// 配置寄存器映射的最大寄存器地址和名称</span></span><br><span class="line">rockchip_regmap_config.max_register = resource_size(res) - <span class="number">4</span>;</span><br><span class="line">rockchip_regmap_config.name = <span class="string">&quot;rockchip,pinctrl&quot;</span>;</span><br><span class="line">        <span class="comment">/* 使用devm_regmap_init_mmio 函数初始化寄存器映射，将结果存储在 info-&gt;regmap_base 中*/</span></span><br><span class="line">info-&gt;regmap_base =</span><br><span class="line">devm_regmap_init_mmio(dev, base, &amp;rockchip_regmap_config);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* to check for the old dt-bindings */</span></span><br><span class="line">info-&gt;reg_size = resource_size(res);<span class="comment">// 检查旧的 dt-bindings</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Honor the old binding, with pull registers as 2nd resource */</span></span><br><span class="line">        <span class="comment">// 如果控制器类型为 RK3188 且 reg_size 小于 0x200，则获取第二个 IORESOURCE_MEM 类型的资源，作为 pull 寄存器的基地址</span></span><br><span class="line"><span class="keyword">if</span> (ctrl-&gt;type == RK3188 &amp;&amp; info-&gt;reg_size &lt; <span class="number">0x200</span>) &#123;</span><br><span class="line">base = devm_platform_get_and_ioremap_resource(pdev, <span class="number">1</span>, &amp;res);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(base))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(base);</span><br><span class="line"><span class="comment">// 配置 pull 寄存器映射的最大寄存器地址和名称</span></span><br><span class="line">rockchip_regmap_config.max_register = resource_size(res) - <span class="number">4</span>;</span><br><span class="line">rockchip_regmap_config.name = <span class="string">&quot;rockchip,pinctrl-pull&quot;</span>;</span><br><span class="line">info-&gt;regmap_pull =</span><br><span class="line">devm_regmap_init_mmio(dev, base, &amp;rockchip_regmap_config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* try to find the optional reference to the pmu syscon */</span></span><br><span class="line">    <span class="comment">// 尝试查找可选的 pmu syscon 引用</span></span><br><span class="line">node = of_parse_phandle(np, <span class="string">&quot;rockchip,pmu&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">/* 调用 syscon_node_to_regmap 函数将节点转换为寄存器映射的基地址，并将结果存储在 info-&gt;regmap_pmu 中 */</span></span><br><span class="line">info-&gt;regmap_pmu = syscon_node_to_regmap(node);</span><br><span class="line">of_node_put(node);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(info-&gt;regmap_pmu))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(info-&gt;regmap_pmu);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于某些 SoC 进行特殊处理</span></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_CPU_RK3308) &amp;&amp; ctrl-&gt;type == RK3308) &#123;</span><br><span class="line">ret = rk3308_soc_data_init(info);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册 rockchip_pinctrl 设备</span></span><br><span class="line">ret = rockchip_pinctrl_register(pdev, info);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"><span class="comment">// 设置 pdev 的私有数据为 info</span></span><br><span class="line">platform_set_drvdata(pdev, info);</span><br><span class="line">g_pctldev = info-&gt;pctl_dev;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 注册 GPIO 设备</span></span><br><span class="line">ret = of_platform_populate(np, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;pdev-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> dev_err_probe(dev, ret, <span class="string">&quot;failed to register gpio device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">dev_info(dev, <span class="string">&quot;probed %s\n&quot;</span>, dev_name(dev));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面 Probe 函数的作用是初始化和配置 Rockchip GPIO 控制器，并将相关信息存储在rockchip_pinctrl 结构体中，最后注册相关设备和 GPIO 接口。</p><p>需要注意的是<code>rockchip_pinctrl_register</code>函数，传入参数为platform_device和rockchip_pinctrl类型</p><h2 id="rockchip-pinctrl-register"><a href="#rockchip-pinctrl-register" class="headerlink" title="rockchip_pinctrl_register()"></a>rockchip_pinctrl_register()</h2><p><code>rockchip_pinctrl_probe()</code>函数最后调用<code>rockchip_pinctrl_register()</code>函数注册 <code>rockchip_pinctrl</code> 设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pinctrl_register</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> rockchip_pinctrl *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// info的pctl即pinctrl_desc</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> *<span class="title">ctrldesc</span> =</span> &amp;info-&gt;pctl;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> *<span class="title">pindesc</span>, *<span class="title">pdesc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_bank</span> *<span class="title">pin_bank</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;pdev-&gt;dev;</span><br><span class="line"><span class="type">int</span> pin, bank, ret;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 pinctrl 描述结构体pinctrl_desc</span></span><br><span class="line">ctrldesc-&gt;name = <span class="string">&quot;rockchip-pinctrl&quot;</span>;</span><br><span class="line">ctrldesc-&gt;owner = THIS_MODULE;</span><br><span class="line">ctrldesc-&gt;pctlops = &amp;rockchip_pctrl_ops;  <span class="comment">// pinctrl 控制操作函数</span></span><br><span class="line">ctrldesc-&gt;pmxops = &amp;rockchip_pmx_ops;  <span class="comment">// pinctrl 引脚复用操作函数</span></span><br><span class="line">ctrldesc-&gt;confops = &amp;rockchip_pinconf_ops;<span class="comment">// pinctrl 引脚配置操作函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 devm_kcalloc 函数在设备的内存上分配一块连续的内存区域，用于存储引脚描述结构体。</span></span><br><span class="line">pindesc = devm_kcalloc(dev, info-&gt;ctrl-&gt;nr_pins, <span class="keyword">sizeof</span>(*pindesc), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!pindesc)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">ctrldesc-&gt;pins = pindesc;<span class="comment">//通过将引脚描述结构体的指针 pindesc 赋值给 pinctrl 描述结构体的 pins成员</span></span><br><span class="line">ctrldesc-&gt;npins = info-&gt;ctrl-&gt;nr_pins;<span class="comment">//将引脚数量 info-&gt;ctrl-&gt;nr_pins 赋值给 pinctrl 描述结构体的 npins 成员</span></span><br><span class="line"></span><br><span class="line">pdesc = pindesc;<span class="comment">// 定义变量 pdesc 指向引脚描述结构体的起始地址</span></span><br><span class="line">    <span class="comment">// 遍历每个引脚所属的 bank，为每个引脚设置编号和名称</span></span><br><span class="line"><span class="keyword">for</span> (bank = <span class="number">0</span>, k = <span class="number">0</span>; bank &lt; info-&gt;ctrl-&gt;nr_banks; bank++) &#123;</span><br><span class="line">        <span class="comment">// 外层循环遍历每个引脚所属的 bank</span></span><br><span class="line">pin_bank = &amp;info-&gt;ctrl-&gt;pin_banks[bank];</span><br><span class="line"><span class="keyword">for</span> (pin = <span class="number">0</span>; pin &lt; pin_bank-&gt;nr_pins; pin++, k++) &#123;<span class="comment">//pin 是当前引脚在 bank 中的索引</span></span><br><span class="line">            <span class="comment">// 内层循环遍历每个 bank 中的引脚。</span></span><br><span class="line">pdesc-&gt;number = k;<span class="comment">//当前引脚的编号 k </span></span><br><span class="line">pdesc-&gt;name = kasprintf(GFP_KERNEL, <span class="string">&quot;%s-%d&quot;</span>,</span><br><span class="line">pin_bank-&gt;name, pin);</span><br><span class="line">pdesc++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INIT_LIST_HEAD(&amp;pin_bank-&gt;deferred_pins);</span><br><span class="line">mutex_init(&amp;pin_bank-&gt;deferred_lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析设备树中的 pinctrl 信息，该函数根据设备树中的描述，设置引脚的默认配置</span></span><br><span class="line">ret = rockchip_pinctrl_parse_dt(pdev, info);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"><span class="comment">// 注册 pinctrl 设备，将 pinctrl 描述结构体、pinctrl 相关操作函数和私有数据作为参数，将 pinctrl 设备注册到系统中</span></span><br><span class="line">info-&gt;pctl_dev = devm_pinctrl_register(dev, ctrldesc, info);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(info-&gt;pctl_dev))</span><br><span class="line"><span class="keyword">return</span> dev_err_probe(dev, PTR_ERR(info-&gt;pctl_dev), <span class="string">&quot;could not register pinctrl driver\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用<code>devm_pinctrl_register</code>，将<code>pdev-&gt;dev</code>，<code>info-&gt;pctl</code>和<code>info</code>传入</p><h4 id="rockchip-pinctrl-parse-dt"><a href="#rockchip-pinctrl-parse-dt" class="headerlink" title="rockchip_pinctrl_parse_dt()"></a>rockchip_pinctrl_parse_dt()</h4><p><code>rochip_pinctrl_register()</code> 函数中调用<code>rockchip_pinctrl_register()</code>解析设备树中的 pinctrl 信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pinctrl_parse_dt</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> rockchip_pinctrl *info)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;pdev-&gt;dev;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> dev-&gt;of_node;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">// 计算子节点数量并更新 info 结构体中的计数器</span></span><br><span class="line">rockchip_pinctrl_child_count(info, np);</span><br><span class="line"></span><br><span class="line">dev_dbg(dev, <span class="string">&quot;nfunctions = %d\n&quot;</span>, info-&gt;nfunctions);</span><br><span class="line">dev_dbg(dev, <span class="string">&quot;ngroups = %d\n&quot;</span>, info-&gt;ngroups);</span><br><span class="line"><span class="comment">// 为函数和组分配内存空间</span></span><br><span class="line">info-&gt;functions = devm_kcalloc(dev, info-&gt;nfunctions, <span class="keyword">sizeof</span>(*info-&gt;functions), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!info-&gt;functions)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">info-&gt;groups = devm_kcalloc(dev, info-&gt;ngroups, <span class="keyword">sizeof</span>(*info-&gt;groups), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!info-&gt;groups)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 遍历每个子节点，解析函数信息</span></span><br><span class="line">for_each_child_of_node(np, child) &#123;</span><br><span class="line">        <span class="comment">// 如果节点不是函数节点，则继续下一个节点</span></span><br><span class="line"><span class="keyword">if</span> (of_match_node(rockchip_bank_match, child))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 解析函数信息并存储到 info 结构体中</span></span><br><span class="line">ret = rockchip_pinctrl_parse_functions(child, info, i++);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_err(dev, <span class="string">&quot;failed to parse function\n&quot;</span>);</span><br><span class="line">of_node_put(child);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="rockchip-pinctrl-child-count"><a href="#rockchip-pinctrl-child-count" class="headerlink" title="rockchip_pinctrl_child_count()"></a>rockchip_pinctrl_child_count()</h5><p><code>rockchip_pinctrl_parse_dt()</code>函数中通过调用<code>rockchip_pinctrl_child_count(info, np);</code>  计算子节点数量并更新 info 结构体中的计数器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rockchip_pinctrl_child_count</span><span class="params">(<span class="keyword">struct</span> rockchip_pinctrl *info,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> device_node *np)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line"><span class="comment">// 遍历设备节点的子节点</span></span><br><span class="line">for_each_child_of_node(np, child) &#123;</span><br><span class="line">        <span class="comment">// 如果子节点不是 function 节点，则跳过当前节点，继续遍历下一个节点</span></span><br><span class="line"><span class="keyword">if</span> (of_match_node(rockchip_bank_match, child))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 子节点是 function 节点，增加 function 计数器</span></span><br><span class="line">info-&gt;nfunctions++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取子节点的子节点数量，并增加到组计数器中</span></span><br><span class="line">info-&gt;ngroups += of_get_child_count(child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="rockchip-pinctrl-parse-functions"><a href="#rockchip-pinctrl-parse-functions" class="headerlink" title="rockchip_pinctrl_parse_functions()"></a>rockchip_pinctrl_parse_functions()</h5><p><code>rockchip_pinctrl_parse_dt()</code>函数中通过调用<code>rockchip_pinctrl_parse_functions()</code>解析函数信息并存储到 info 结构体中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pinctrl_parse_functions</span><span class="params">(<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> rockchip_pinctrl *info,</span></span><br><span class="line"><span class="params">u32 index)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> info-&gt;dev;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pmx_func</span> *<span class="title">func</span>;</span><span class="comment">// 用来存放 function 信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_group</span> *<span class="title">grp</span>;</span><span class="comment">// 用来存放 groups 信息</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">static</span> u32 grp_index;</span><br><span class="line">u32 i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 打印调试信息，显示正在解析的函数节点和索引</span></span><br><span class="line">dev_dbg(dev, <span class="string">&quot;parse function(%d): %pOFn\n&quot;</span>, index, np);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前函数在 info-&gt;functions 数组中的指针</span></span><br><span class="line">func = &amp;info-&gt;functions[index];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialise function */</span></span><br><span class="line">    <span class="comment">/* 初始化函数 */</span></span><br><span class="line">func-&gt;name = np-&gt;name;</span><br><span class="line">    <span class="comment">// 获取函数节点的子节点数量，即关联的组数量</span></span><br><span class="line">func-&gt;ngroups = of_get_child_count(np);</span><br><span class="line"><span class="keyword">if</span> (func-&gt;ngroups &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为函数的组指针数组分配内存空间</span></span><br><span class="line">func-&gt;groups = devm_kcalloc(dev, func-&gt;ngroups, <span class="keyword">sizeof</span>(*func-&gt;groups), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!func-&gt;groups)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历函数节点的每个子节点</span></span><br><span class="line">for_each_child_of_node(np, child) &#123;</span><br><span class="line">        <span class="comment">// 将子节点的名称存储到函数的组指针数组中</span></span><br><span class="line">func-&gt;groups[i] = child-&gt;name;</span><br><span class="line">        <span class="comment">// 获取 info-&gt;groups 数组中的对应组指针</span></span><br><span class="line">grp = &amp;info-&gt;groups[grp_index++];</span><br><span class="line">        <span class="comment">// 解析组信息，并将结果存储到对应的组指针中</span></span><br><span class="line">ret = rockchip_pinctrl_parse_groups(child, grp, info, i++);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">of_node_put(child);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>rockchip_pinctrl_parse_functions</code>中:</p><ul><li>将 info 的 functions 地址赋值给了 func，所以 <code>rockchip_pinctrl</code> 的 functions 参数的作用就是用来存放 pinctrl 设备树中的 function 信息。</li><li>info 的 groups 地址赋值给了 grp，所以 <code>rockchip_pinctrl</code> 的 groups 参数的作用就是用来存放 pinctrl 设备树中的 groups 信息。</li></ul><p><strong>rockchip_pinctrl_parse_groups()</strong></p><p><code>rockchip_pinctrl_parse_functions</code>中通过<code>ret = rockchip_pinctrl_parse_groups(child, grp, info, i++);</code> 解析组信息，并将结果存储到对应的组指针中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pinctrl_parse_groups</span><span class="params">(<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> rockchip_pin_group *grp,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> rockchip_pinctrl *info,</span></span><br><span class="line"><span class="params">      u32 index)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> info-&gt;dev;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_bank</span> *<span class="title">bank</span>;</span></span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">const</span> __be32 *<span class="built_in">list</span>;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="comment">// 打印调试信息，显示正在解析的组节点和索引</span></span><br><span class="line">dev_dbg(dev, <span class="string">&quot;group(%d): %pOFn\n&quot;</span>, index, np);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialise group */</span></span><br><span class="line">    <span class="comment">// 初始化组信，将引脚组的名称设置为节点的名称</span></span><br><span class="line">grp-&gt;name = np-&gt;name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * the binding format is rockchip,pins = &lt;bank pin mux CONFIG&gt;,</span></span><br><span class="line"><span class="comment"> * do sanity check and calculate pins number</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 绑定格式为 rockchip,pins = &lt;bank pin mux CONFIG&gt;，</span></span><br><span class="line"><span class="comment">* 进行合法性检查并计算引脚数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">list</span> = of_get_property(np, <span class="string">&quot;rockchip,pins&quot;</span>, &amp;size);</span><br><span class="line"><span class="comment">/* we do not check return since it&#x27;s safe node passed down */</span></span><br><span class="line">size /= <span class="keyword">sizeof</span>(*<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">if</span> (!size || size % <span class="number">4</span>)<span class="comment">//如果属性值为空或者数量不是 4 的倍数</span></span><br><span class="line"><span class="keyword">return</span> dev_err_probe(dev, -EINVAL, <span class="string">&quot;wrong pins number or pins and configs should be by 4\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">grp-&gt;npins = size / <span class="number">4</span>;<span class="comment">// 计算组的引脚数量</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 根据计算得到的引脚数量为引脚数组和数据数组分配内存空间，这些数组将用于存储引脚的编号和相关的配置信息</span></span><br><span class="line">grp-&gt;pins = devm_kcalloc(dev, grp-&gt;npins, <span class="keyword">sizeof</span>(*grp-&gt;pins), GFP_KERNEL);</span><br><span class="line">grp-&gt;data = devm_kcalloc(dev, grp-&gt;npins, <span class="keyword">sizeof</span>(*grp-&gt;data), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!grp-&gt;pins || !grp-&gt;data)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="comment">// 遍历列表中的每个元素，每 4 个元素表示一个引脚的信息</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; size; i += <span class="number">4</span>, j++) &#123;</span><br><span class="line"><span class="type">const</span> __be32 *phandle;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np_config</span>;</span></span><br><span class="line"><span class="comment">// 获取管脚号</span></span><br><span class="line">num = be32_to_cpu(*<span class="built_in">list</span>++);</span><br><span class="line">        <span class="comment">// 引脚号转换为对应的引脚结构体指针</span></span><br><span class="line">bank = bank_num_to_bank(info, num);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(bank))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(bank);</span><br><span class="line"><span class="comment">// 根据引脚结构体中的引脚基地址（pin_base）和列表中的值计算引脚的编号，并将其存储在引脚数组（grp-&gt;pins）中</span></span><br><span class="line">grp-&gt;pins[j] = bank-&gt;pin_base + be32_to_cpu(*<span class="built_in">list</span>++);</span><br><span class="line">        <span class="comment">// 从列表中获取与当前引脚相关的功能选择值，并将其存储在数据数组（grp-&gt;data）中的相应位置</span></span><br><span class="line">grp-&gt;data[j].func = be32_to_cpu(*<span class="built_in">list</span>++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取与引脚相关的配置信息</span></span><br><span class="line">phandle = <span class="built_in">list</span>++;</span><br><span class="line"><span class="keyword">if</span> (!phandle)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">// 从列表中获取与当前引脚相关的配置信息的句柄，并通过该句柄查找对应的配置节点（np_config）</span></span><br><span class="line">np_config = of_find_node_by_phandle(be32_to_cpup(phandle));</span><br><span class="line">        <span class="comment">// 解析配置信息，并将结果存储到组的数据数组中</span></span><br><span class="line">ret = pinconf_generic_parse_dt_config(np_config, <span class="literal">NULL</span>,</span><br><span class="line">&amp;grp-&gt;data[j].configs, &amp;grp-&gt;data[j].nconfigs);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="devm-pinctrl-register"><a href="#devm-pinctrl-register" class="headerlink" title="devm_pinctrl_register()"></a>devm_pinctrl_register()</h4><p><code>rockchip_pinctrl_register()</code>函数通过<code>info-&gt;pctl_dev = devm_pinctrl_register(dev, ctrldesc, info);</code> 注册 pinctrl 设备，将 pinctrl 描述结构体、pinctrl 相关操作函数和私有数据作为参数，将 pinctrl 设备注册到系统中</p><p>一个参数类型为<code>struct device *</code>，第二个参数类型为<code>struct pinctrl_desc *</code>，第三个参数类型为<code>void *</code>是pin controller的私有数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/core.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * devm_pinctrl_register() - Resource managed version of pinctrl_register().</span></span><br><span class="line"><span class="comment"> * @dev: parent device for this pin controller</span></span><br><span class="line"><span class="comment"> * @pctldesc: descriptor for this pin controller</span></span><br><span class="line"><span class="comment"> * @driver_data: private pin controller data for this pin controller</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns an error pointer if pincontrol register failed. Otherwise</span></span><br><span class="line"><span class="comment"> * it returns valid pinctrl handle.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The pinctrl device will be automatically released when the device is unbound.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> pinctrl_dev *<span class="title function_">devm_pinctrl_register</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> pinctrl_desc *pctldesc,</span></span><br><span class="line"><span class="params">  <span class="type">void</span> *driver_data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> **<span class="title">ptr</span>, *<span class="title">pctldev</span>;</span></span><br><span class="line"><span class="comment">// 使用 devres_alloc 函数为存储 pinctrl_dev 指针的变量 ptr 分配内存</span></span><br><span class="line">ptr = devres_alloc(devm_pinctrl_dev_release, <span class="keyword">sizeof</span>(*ptr), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!ptr)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"><span class="comment">// 调用 pinctrl_register 函数注册 pinctrl 设备。该函数将 pinctrl_desc 结构体、设备指针 dev 和驱动程序数据 driver_data 作为参数，并返回注册后的 pinctrl_dev 指针</span></span><br><span class="line">pctldev = pinctrl_register(pctldesc, dev, driver_data);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(pctldev)) &#123;</span><br><span class="line">devres_free(ptr);</span><br><span class="line"><span class="keyword">return</span> pctldev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 pinctrl_dev 指针存储到 ptr 指向的内存位置。</span></span><br><span class="line">*ptr = pctldev;</span><br><span class="line">    <span class="comment">// 使用 devres_add 函数将 ptr 添加到设备的资源列表中。这样，在设备释放时，会自动释放之前分配的内存。</span></span><br><span class="line">devres_add(dev, ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pctldev;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(devm_pinctrl_register);</span><br></pre></td></tr></table></figure><p><code>devres_alloc</code> 函数是用于管理设备资源的函数，它在设备的资源列表中分配内存。这里分配的内存大小为 <code>sizeof(*ptr)</code>字节，即一个 <code>pinctrl_dev</code> 指针的大小。如果内存分配失败，则返回<code>-ENOMEM</code></p><h5 id="pinctrl-register"><a href="#pinctrl-register" class="headerlink" title="pinctrl_register()"></a>pinctrl_register()</h5><p><code>devm_pinctrl_register()</code>通过调用<code>pctldev = pinctrl_register(pctldesc, dev, driver_data);</code>注册 pinctrl 设备。该函数将 pinctrl_desc 结构体、设备指针 dev 和驱动程序数据 driver_data 作为参数，并返回注册后的 pinctrl_dev 指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/core.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pinctrl_register() - register a pin controller device</span></span><br><span class="line"><span class="comment"> * @pctldesc: descriptor for this pin controller</span></span><br><span class="line"><span class="comment"> * @dev: parent device for this pin controller</span></span><br><span class="line"><span class="comment"> * @driver_data: private pin controller data for this pin controller</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that pinctrl_register() is known to have problems as the pin</span></span><br><span class="line"><span class="comment"> * controller driver functions are called before the driver has a</span></span><br><span class="line"><span class="comment"> * struct pinctrl_dev handle. To avoid issues later on, please use the</span></span><br><span class="line"><span class="comment"> * new pinctrl_register_and_init() below instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> pinctrl_dev *<span class="title function_">pinctrl_register</span><span class="params">(<span class="keyword">struct</span> pinctrl_desc *pctldesc,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> device *dev, <span class="type">void</span> *driver_data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"><span class="comment">// 初始化 pinctrl 控制器</span></span><br><span class="line">pctldev = pinctrl_init_controller(pctldesc, dev, driver_data);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(pctldev))</span><br><span class="line"><span class="keyword">return</span> pctldev;</span><br><span class="line"><span class="comment">// 启用 pinctrl 控制器</span></span><br><span class="line">error = pinctrl_enable(pctldev);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pctldev;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pinctrl_register);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="pinctrl-init-controller"><a href="#pinctrl-init-controller" class="headerlink" title="pinctrl_init_controller()"></a>pinctrl_init_controller()</h5><p><code>pinctrl_register()</code>中通过<code>pctldev = pinctrl_init_controller(pctldesc, dev, driver_data);</code>初始化 pinctrl 控制器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pinctrl_init_controller() - init a pin controller device</span></span><br><span class="line"><span class="comment"> * @pctldesc: descriptor for this pin controller</span></span><br><span class="line"><span class="comment"> * @dev: parent device for this pin controller</span></span><br><span class="line"><span class="comment"> * @driver_data: private pin controller data for this pin controller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> pinctrl_dev *</span><br><span class="line"><span class="title function_">pinctrl_init_controller</span><span class="params">(<span class="keyword">struct</span> pinctrl_desc *pctldesc, <span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params"><span class="type">void</span> *driver_data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pctldesc)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"><span class="keyword">if</span> (!pctldesc-&gt;name)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">pctldev = kzalloc(<span class="keyword">sizeof</span>(*pctldev), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!pctldev)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize pin control device struct */</span></span><br><span class="line">    <span class="comment">/* 初始化引脚控制设备结构体 */</span></span><br><span class="line">pctldev-&gt;owner = pctldesc-&gt;owner;<span class="comment">// 设置所有者</span></span><br><span class="line">pctldev-&gt;desc = pctldesc;<span class="comment">// 设置描述符</span></span><br><span class="line">pctldev-&gt;driver_data = driver_data; <span class="comment">// 设置驱动程序数据</span></span><br><span class="line">INIT_RADIX_TREE(&amp;pctldev-&gt;pin_desc_tree, GFP_KERNEL);<span class="comment">// 初始化引脚描述符树</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCTRL_GROUPS</span></span><br><span class="line">INIT_RADIX_TREE(&amp;pctldev-&gt;pin_group_tree, GFP_KERNEL);<span class="comment">// 初始化引脚组树</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINMUX_FUNCTIONS</span></span><br><span class="line">INIT_RADIX_TREE(&amp;pctldev-&gt;pin_function_tree, GFP_KERNEL);<span class="comment">// 初始化引脚功能树</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">INIT_LIST_HEAD(&amp;pctldev-&gt;gpio_ranges);<span class="comment">// 初始化 GPIO 范围链表</span></span><br><span class="line">INIT_LIST_HEAD(&amp;pctldev-&gt;node);<span class="comment">// 初始化节点链表</span></span><br><span class="line">pctldev-&gt;dev = dev;<span class="comment">// 设置设备指针</span></span><br><span class="line">mutex_init(&amp;pctldev-&gt;mutex);<span class="comment">// 初始化互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check core ops for sanity */</span></span><br><span class="line">    <span class="comment">/* 检查核心操作函数的有效性 */</span></span><br><span class="line">ret = pinctrl_check_ops(pctldev);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_err(dev, <span class="string">&quot;pinctrl ops lacks necessary functions\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> out_err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If we&#x27;re implementing pinmuxing, check the ops for sanity */</span></span><br><span class="line">    <span class="comment">/* 如果实现了引脚复用功能，检查操作函数的有效性 */</span></span><br><span class="line"><span class="keyword">if</span> (pctldesc-&gt;pmxops) &#123;</span><br><span class="line">ret = pinmux_check_ops(pctldev);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out_err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If we&#x27;re implementing pinconfig, check the ops for sanity */</span></span><br><span class="line">    <span class="comment">/* 如果实现了引脚配置功能，检查操作函数的有效性 */</span></span><br><span class="line"><span class="keyword">if</span> (pctldesc-&gt;confops) &#123;</span><br><span class="line">ret = pinconf_check_ops(pctldev);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out_err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register all the pins */</span></span><br><span class="line">    <span class="comment">/* 注册所有引脚 */</span></span><br><span class="line">dev_dbg(dev, <span class="string">&quot;try to register %d pins ...\n&quot;</span>,  pctldesc-&gt;npins);</span><br><span class="line">ret = pinctrl_register_pins(pctldev, pctldesc-&gt;pins, pctldesc-&gt;npins);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_err(dev, <span class="string">&quot;error during pin registration\n&quot;</span>);</span><br><span class="line">pinctrl_free_pindescs(pctldev, pctldesc-&gt;pins,</span><br><span class="line">      pctldesc-&gt;npins);</span><br><span class="line"><span class="keyword">goto</span> out_err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pctldev;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">mutex_destroy(&amp;pctldev-&gt;mutex);</span><br><span class="line">kfree(pctldev);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在该函数中我们要关注的是第 27 行内容 <code>pctldev-&gt;driver_data = driver_data</code>，其中右值 driver_data 是从 pinctrl 函数的 probe 一步一步传递过来的，是一个 <code>struct rockchip_pinctrl *</code>类型的结构体指针变量，左值 pctldev 为要注册的引脚控制设备（pincontroller device），至此两个数据结构建立起了关联，可以<strong>通过 <code>pctldev</code> 来对 <code>rockchip_pinctrl</code> 中的数据进行访问</strong>。</p><h2 id="相关数据结构体"><a href="#相关数据结构体" class="headerlink" title="相关数据结构体"></a>相关数据结构体</h2><h3 id="pinctrl-desc-结构体"><a href="#pinctrl-desc-结构体" class="headerlink" title="pinctrl_desc 结构体"></a>pinctrl_desc 结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinctrl_desc - pin controller descriptor, register this to pin</span></span><br><span class="line"><span class="comment"> * control subsystem</span></span><br><span class="line"><span class="comment"> * @name: name for the pin controller</span></span><br><span class="line"><span class="comment"> * @pins: an array of pin descriptors describing all the pins handled by</span></span><br><span class="line"><span class="comment"> *this pin controller</span></span><br><span class="line"><span class="comment"> * @npins: number of descriptors in the array, usually just ARRAY_SIZE()</span></span><br><span class="line"><span class="comment"> *of the pins field above</span></span><br><span class="line"><span class="comment"> * @pctlops: pin control operation vtable, to support global concepts like</span></span><br><span class="line"><span class="comment"> *grouping of pins, this is optional.</span></span><br><span class="line"><span class="comment"> * @pmxops: pinmux operations vtable, if you support pinmuxing in your driver</span></span><br><span class="line"><span class="comment"> * @confops: pin config operations vtable, if you support pin configuration in</span></span><br><span class="line"><span class="comment"> *your driver</span></span><br><span class="line"><span class="comment"> * @owner: module providing the pin controller, used for refcounting</span></span><br><span class="line"><span class="comment"> * @num_custom_params: Number of driver-specific custom parameters to be parsed</span></span><br><span class="line"><span class="comment"> *from the hardware description</span></span><br><span class="line"><span class="comment"> * @custom_params: List of driver_specific custom parameters to be parsed from</span></span><br><span class="line"><span class="comment"> *the hardware description</span></span><br><span class="line"><span class="comment"> * @custom_conf_items: Information how to print @params in debugfs, must be</span></span><br><span class="line"><span class="comment"> *the same size as the @custom_params, i.e. @num_custom_params</span></span><br><span class="line"><span class="comment"> * @link_consumers: If true create a device link between pinctrl and its</span></span><br><span class="line"><span class="comment"> *consumers (i.e. the devices requesting pin control states). This is</span></span><br><span class="line"><span class="comment"> *sometimes necessary to ascertain the right suspend/resume order for</span></span><br><span class="line"><span class="comment"> *example.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;<span class="comment">// 引脚控制器的名称</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> *<span class="title">pins</span>;</span><span class="comment">// 引脚描述符数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> npins;<span class="comment">// 引脚描述符数组的大小</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">pctlops</span>;</span><span class="comment">// 引脚控制操作函数指针</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">pmxops</span>;</span><span class="comment">// 引脚复用操作函数指针</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> *<span class="title">confops</span>;</span><span class="comment">// 引脚配置操作函数指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span><span class="comment">// 拥有该结构体的模块</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num_custom_params;<span class="comment">// 自定义参数数量</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_generic_params</span> *<span class="title">custom_params</span>;</span><span class="comment">// 自定义参数数组</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pin_config_item</span> *<span class="title">custom_conf_items</span>;</span><span class="comment">// 自定义配置项数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">bool</span> link_consumers;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>const char *name</code>: <strong>引脚控制器的名称</strong>，用于标识引脚控制器的唯一性。</li><li><code>const struct pinctrl_pin_desc *pins</code>: <strong>引脚描述符数组</strong>，是一个指向引脚描述符的指针，用于描述引脚的属性和配置。每个引脚描述符包含了引脚的名称、编号、模式等信息。</li><li><code>unsigned int npins</code>: 表示<strong>引脚描述符数组中元素的数量</strong>，用于确定引脚描述符数组的长度。</li></ul><ul><li><p><code>const struct pinctrl_ops *pctlops</code>: <strong>指向引脚控制操作函数的指针，用于定义引脚控制器的操作接口</strong>。通过这些操作函数，可以<strong>对引脚进行配置、使能、禁用</strong>等操作。</p></li><li><p><code>const struct pinmux_ops *pmxops</code>: <strong>指向引脚复用操作函数的指针，用于定义引脚的复用功能</strong>。复用功能允许<strong>将引脚的功能切换为不同的模式</strong>，以适应不同的设备需求</p></li><li><p><code>const struct pinconf_ops *confops</code>: <strong>指向引脚配置操作函数的指针，用于定义引脚的其他配置选项</strong>。这些配置选项可以包括<strong>引脚的上拉、下拉配置、电气特性等</strong>。</p></li></ul><ul><li><code>struct module *owner</code>: 指向拥有该引脚控制器结构体的模块的指针。这个字段用于跟踪引脚控制器结构体的所有者。</li><li><code>unsigned int num_custom_params</code>: 表示自定义配置参数的数量，用于描述引脚控制器的自定义配置参数。</li><li><code>const struct pinconf_generic_params *custom_params</code>: 指向自定义配置参数的指针，用于描述引脚控制器的自定义配置参数的属性。自定义配置参数可以根据具体需求定义，用于扩展引脚控制器的配置选项。</li><li><code>const struct pin_config_item *custom_conf_items</code>: 指向自定义配置项的指针，用于描述引脚控制器的自定义配置项的属性。自定义配置项可以根据具体需求定义，用于扩展引脚控制器的配置选项。</li></ul><h3 id="rockchip-pinctrl-结构体"><a href="#rockchip-pinctrl-结构体" class="headerlink" title="rockchip_pinctrl 结构体"></a>rockchip_pinctrl 结构体</h3><p>瑞芯微为了适应瑞芯微芯片的特定需求和功能，对 <code>struct pinctrl_desc</code> 进行了再一次封装。封装后的 <code>struct rockchip_pinctrl</code> 结构体在 <code>struct pinctrl_desc</code> 的基础上增加了与瑞芯微芯片相关的字段和指针，这种封装可以提供更好的集成性、易用性和扩展性，同时保持与通用引脚控制器框架的兼容性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regmap</span>*<span class="title">regmap_base</span>;</span><span class="comment">// 基本寄存器映射指针</span></span><br><span class="line"><span class="type">int</span>reg_size;<span class="comment">// 寄存器大小</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regmap</span>*<span class="title">regmap_pull</span>;</span><span class="comment">// 拉取寄存器映射指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regmap</span>*<span class="title">regmap_pmu</span>;</span><span class="comment">// 电源管理单元寄存器映射指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span>*<span class="title">dev</span>;</span><span class="comment">// 设备指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_ctrl</span>*<span class="title">ctrl</span>;</span><span class="comment">// 瑞芯微芯片引脚控制器指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span><span class="title">pctl</span>;</span><span class="comment">// 引脚控制器描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span>*<span class="title">pctl_dev</span>;</span><span class="comment">// 引脚控制器设备指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_group</span>*<span class="title">groups</span>;</span><span class="comment">// 瑞芯微芯片引脚组指针</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>ngroups;<span class="comment">// 引脚组数量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pmx_func</span>*<span class="title">functions</span>;</span><span class="comment">// 瑞芯微芯片引脚功能指针</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>nfunctions;<span class="comment">// 引脚功能数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>struct regmap *regmap_base</code>：指向基本寄存器映射（regmap）的指针。基本寄存器映射是一个用于访问芯片寄存器的接口，它提供了对芯片寄存器的读写操作。</li><li><code>int reg_size</code>：表示寄存器的字节大小，用于确定寄存器的地址范围。</li><li><code>struct regmap *regmap_pull</code>：指向拉取寄存器映射的指针。拉取寄存器映射用于控制引脚上的上拉和下拉功能。</li><li><code>struct regmap *regmap_pmu</code>：指向电源管理单元（PMU）寄存器映射的指针。PMU寄存器映射用于控制引脚的电源管理功能</li><li><code>struct device *dev</code>：指向设备结构体的指针。设备结构体用于表示与硬件相关的设备，包括设备的物理地址、中断等信息</li></ul><ul><li><code>struct rockchip_pin_ctrl *ctrl</code>：指向瑞芯微芯片引脚控制器的指针。这个结构体存储了瑞芯微芯片特定的引脚控制器的相关信息和操作。</li><li><code>struct pinctrl_desc pctl</code>：包含了 struct pinctrl_desc 结构体的一个实例。用于描述引脚控制器的属性和操作，包括引脚控制器的名称、引脚描述符数组、函数指针等。</li><li><code>struct pinctrl_dev *pctl_dev</code>：指向引脚控制器设备结构体的指针。引脚控制器设备结构体用于表示引脚控制器在系统中的设备实例，包含了与引脚控制器相关的设备信息和操作接口。</li></ul><ul><li><code>struct rockchip_pin_group *groups</code>：指向瑞芯微芯片引脚组的指针。引脚组是一组相关的引脚，可以一起进行配置和管理。</li><li><code>unsigned int ngroups</code>：表示引脚组数组的大小，用于确定引脚组数组的长度。</li></ul><ul><li><code>struct rockchip_pmx_func *functions</code>：指向瑞芯微芯片引脚功能的指针。引脚功能定义了引脚可以承担的不同功能，例如 UART、SPI、I2C 等。</li><li><code>unsigned int nfunctions</code>：引脚功能的数量。它表示引脚功能数组的大小，用于确定<br>引脚功能数组的长度。</li></ul><h3 id="rockchip-pin-ctrl-结构体"><a href="#rockchip-pin-ctrl-结构体" class="headerlink" title="rockchip_pin_ctrl 结构体"></a>rockchip_pin_ctrl 结构体</h3><p>在<code>rockchip_pinctrl_probe</code>函数中通过<code>ctrl = rockchip_pinctrl_get_soc_data(info, pdev)</code>设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_ctrl</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_bank</span>*<span class="title">pin_banks</span>;</span><span class="comment">// 引脚bank的数组指针</span></span><br><span class="line">u32nr_banks;<span class="comment">// pin_bank的数量</span></span><br><span class="line">u32nr_pins;<span class="comment">// 引脚的数量</span></span><br><span class="line"><span class="type">char</span>*label;<span class="comment">// 引脚控制器标签</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">rockchip_pinctrl_type</span><span class="title">type</span>;</span><span class="comment">// 引脚控制器的类型</span></span><br><span class="line"><span class="type">int</span>grf_mux_offset;<span class="comment">// GRF(Global Register File)复用寄存器的偏移量</span></span><br><span class="line"><span class="type">int</span>pmu_mux_offset;<span class="comment">// PMU(电源管理单元)复用寄存器的偏移量</span></span><br><span class="line"><span class="type">int</span>grf_drv_offset;<span class="comment">// GRF驱动寄存器的偏移量</span></span><br><span class="line"><span class="type">int</span>pmu_drv_offset;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_mux_recalced_data</span> *<span class="title">iomux_recalced</span>;</span></span><br><span class="line">u32niomux_recalced;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_mux_route_data</span> *<span class="title">iomux_routes</span>;</span></span><br><span class="line">u32niomux_routes;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>(*pull_calc_reg)(<span class="keyword">struct</span> rockchip_pin_bank *bank,</span><br><span class="line"> <span class="type">int</span> pin_num, <span class="keyword">struct</span> regmap **regmap,</span><br><span class="line"> <span class="type">int</span> *reg, u8 *bit);</span><br><span class="line"><span class="type">int</span>(*drv_calc_reg)(<span class="keyword">struct</span> rockchip_pin_bank *bank,</span><br><span class="line"><span class="type">int</span> pin_num, <span class="keyword">struct</span> regmap **regmap,</span><br><span class="line"><span class="type">int</span> *reg, u8 *bit);</span><br><span class="line"><span class="type">int</span>(*schmitt_calc_reg)(<span class="keyword">struct</span> rockchip_pin_bank *bank,</span><br><span class="line">    <span class="type">int</span> pin_num, <span class="keyword">struct</span> regmap **regmap,</span><br><span class="line">    <span class="type">int</span> *reg, u8 *bit);</span><br><span class="line"><span class="type">int</span>(*slew_rate_calc_reg)(<span class="keyword">struct</span> rockchip_pin_bank *bank,</span><br><span class="line">      <span class="type">int</span> pin_num, <span class="keyword">struct</span> regmap **regmap,</span><br><span class="line">      <span class="type">int</span> *reg, u8 *bit);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="pinctrl-dev-结构体"><a href="#pinctrl-dev-结构体" class="headerlink" title="pinctrl_dev 结构体"></a>pinctrl_dev 结构体</h3><p>在<code>rockchip_pinctrl_probe</code>函数中通过<code>info-&gt;pctl_dev = devm_pinctrl_register(dev, ctrldesc, info)</code>设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinctrl_dev - pin control class device</span></span><br><span class="line"><span class="comment"> * @node: node to include this pin controller in the global pin controller list</span></span><br><span class="line"><span class="comment"> * @desc: the pin controller descriptor supplied when initializing this pin</span></span><br><span class="line"><span class="comment"> *controller</span></span><br><span class="line"><span class="comment"> * @pin_desc_tree: each pin descriptor for this pin controller is stored in</span></span><br><span class="line"><span class="comment"> *this radix tree</span></span><br><span class="line"><span class="comment"> * @pin_group_tree: optionally each pin group can be stored in this radix tree</span></span><br><span class="line"><span class="comment"> * @num_groups: optionally number of groups can be kept here</span></span><br><span class="line"><span class="comment"> * @pin_function_tree: optionally each function can be stored in this radix tree</span></span><br><span class="line"><span class="comment"> * @num_functions: optionally number of functions can be kept here</span></span><br><span class="line"><span class="comment"> * @gpio_ranges: a list of GPIO ranges that is handled by this pin controller,</span></span><br><span class="line"><span class="comment"> *ranges are added to this list at runtime</span></span><br><span class="line"><span class="comment"> * @dev: the device entry for this pin controller</span></span><br><span class="line"><span class="comment"> * @owner: module providing the pin controller, used for refcounting</span></span><br><span class="line"><span class="comment"> * @driver_data: driver data for drivers registering to the pin controller</span></span><br><span class="line"><span class="comment"> *subsystem</span></span><br><span class="line"><span class="comment"> * @p: result of pinctrl_get() for this device</span></span><br><span class="line"><span class="comment"> * @hog_default: default state for pins hogged by this device</span></span><br><span class="line"><span class="comment"> * @hog_sleep: sleep state for pins hogged by this device</span></span><br><span class="line"><span class="comment"> * @mutex: mutex taken on each pin controller specific action</span></span><br><span class="line"><span class="comment"> * @device_root: debugfs root for this device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span><span class="comment">// pinctrl_dev链表中的节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> *<span class="title">desc</span>;</span> <span class="comment">// 引脚控制器描述指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_desc_tree</span>;</span><span class="comment">// 引脚描述结构体的radix树</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCTRL_GROUPS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_group_tree</span>;</span><span class="comment">// 引脚组结构体的radix树根</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num_groups;<span class="comment">// 引脚组的数量</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINMUX_FUNCTIONS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_function_tree</span>;</span><span class="comment">// 引脚功能结构体的radix树根</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num_functions;<span class="comment">// 引脚功能的数量</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">gpio_ranges</span>;</span><span class="comment">// GPIO范围链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span><span class="comment">// 设备结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span><span class="comment">// 拥有pinctrl_dev结构体的模块的指针</span></span><br><span class="line"><span class="type">void</span> *driver_data;<span class="comment">// 驱动程序的私有数据指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span><span class="comment">// pinctrl结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">hog_default</span>;</span><span class="comment">// hog默认状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">hog_sleep</span>;</span><span class="comment">// hog睡眠状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span><span class="comment">// 互斥锁</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">device_root</span>;</span><span class="comment">// 调试文件系统的根节点</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="pinctrl子系统函数操作集"><a href="#pinctrl子系统函数操作集" class="headerlink" title="pinctrl子系统函数操作集"></a>pinctrl子系统函数操作集</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">pctlops</span>;</span> <span class="comment">// 引脚控制操作函数指针</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">pmxops</span>;</span>   <span class="comment">// 引脚复用操作函数指针</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> *<span class="title">confops</span>;</span> <span class="comment">// 引脚配置操作函数指针</span></span><br></pre></td></tr></table></figure><h3 id="pinctrl-ops"><a href="#pinctrl-ops" class="headerlink" title="pinctrl_ops"></a>pinctrl_ops</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinctrl_ops - global pin control operations, to be implemented by</span></span><br><span class="line"><span class="comment"> * pin controller drivers.</span></span><br><span class="line"><span class="comment"> * @get_groups_count: Returns the count of total number of groups registered.</span></span><br><span class="line"><span class="comment"> * @get_group_name: return the group name of the pin group</span></span><br><span class="line"><span class="comment"> * @get_group_pins: return an array of pins corresponding to a certain</span></span><br><span class="line"><span class="comment"> *group selector @pins, and the size of the array in @num_pins</span></span><br><span class="line"><span class="comment"> * @pin_dbg_show: optional debugfs display hook that will provide per-device</span></span><br><span class="line"><span class="comment"> *info for a certain pin in debugfs</span></span><br><span class="line"><span class="comment"> * @dt_node_to_map: parse a device tree &quot;pin configuration node&quot;, and create</span></span><br><span class="line"><span class="comment"> *mapping table entries for it. These are returned through the @map and</span></span><br><span class="line"><span class="comment"> *@num_maps output parameters. This function is optional, and may be</span></span><br><span class="line"><span class="comment"> *omitted for pinctrl drivers that do not support device tree.</span></span><br><span class="line"><span class="comment"> * @dt_free_map: free mapping table entries created via @dt_node_to_map. The</span></span><br><span class="line"><span class="comment"> *top-level @map pointer must be freed, along with any dynamically</span></span><br><span class="line"><span class="comment"> *allocated members of the mapping table entries themselves. This</span></span><br><span class="line"><span class="comment"> *function is optional, and may be omitted for pinctrl drivers that do</span></span><br><span class="line"><span class="comment"> *not support device tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> &#123;</span></span><br><span class="line"><span class="type">int</span> (*get_groups_count) (<span class="keyword">struct</span> pinctrl_dev *pctldev);<span class="comment">//获取指定的 Pin Control 设备支持的引脚组数量</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *(*get_group_name) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">       <span class="type">unsigned</span> selector);<span class="comment">// 获取指定引脚组选择器对应的引脚组名称</span></span><br><span class="line"><span class="type">int</span> (*get_group_pins) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">       <span class="type">unsigned</span> selector,</span><br><span class="line">       <span class="type">const</span> <span class="type">unsigned</span> **pins,</span><br><span class="line">       <span class="type">unsigned</span> *num_pins);<span class="comment">// 获取指定引脚组选择器对应的引脚组中的引脚列表</span></span><br><span class="line"><span class="type">void</span> (*pin_dbg_show) (<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="keyword">struct</span> seq_file *s,</span><br><span class="line">  <span class="type">unsigned</span> offset);<span class="comment">//在调试信息中输出指定引脚选择器对应的引脚信息</span></span><br><span class="line"><span class="type">int</span> (*dt_node_to_map) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">       <span class="keyword">struct</span> device_node *np_config,</span><br><span class="line">       <span class="keyword">struct</span> pinctrl_map **<span class="built_in">map</span>, <span class="type">unsigned</span> *num_maps);<span class="comment">// 根据给定的设备树节点，创建与之相关联的 Pin Control 映射</span></span><br><span class="line"><span class="type">void</span> (*dt_free_map) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">     <span class="keyword">struct</span> pinctrl_map *<span class="built_in">map</span>, <span class="type">unsigned</span> num_maps);<span class="comment">//释放之前通过 dt_node_to_map 创建的Pin Control 映射</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> <span class="title">rockchip_pctrl_ops</span> =</span> &#123;</span><br><span class="line">.get_groups_count= rockchip_get_groups_count,</span><br><span class="line">.get_group_name= rockchip_get_group_name,</span><br><span class="line">.get_group_pins= rockchip_get_group_pins,</span><br><span class="line">.dt_node_to_map= rockchip_dt_node_to_map,</span><br><span class="line">.dt_free_map= rockchip_dt_free_map,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="get-groups-count"><a href="#get-groups-count" class="headerlink" title="get_groups_count"></a><code>get_groups_count</code></h4><blockquote><p>获取引脚组的数量。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_get_groups_count</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从 pinctrl_dev 结构中获取私有数据指针，将其转换为 rockchip_pinctrl 结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line"><span class="comment">// 返回 rockchip_pinctrl 结构中存储的引脚组数量</span></span><br><span class="line"><span class="keyword">return</span> info-&gt;ngroups;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-group-name"><a href="#get-group-name" class="headerlink" title="get_group_name"></a><code>get_group_name</code></h4><blockquote><p>获取引脚组的名称。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">rockchip_get_group_name</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> selector)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从 pinctrl_dev 结构中获取私有数据指针，将其转换为 rockchip_pinctrl 结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回指定引脚组的名称</span></span><br><span class="line"><span class="keyword">return</span> info-&gt;groups[selector].name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-group-pins"><a href="#get-group-pins" class="headerlink" title="get_group_pins"></a><code>get_group_pins</code></h4><blockquote><p>获取引脚组的引脚列表。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_get_group_pins</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span></span><br><span class="line"><span class="params">      <span class="type">unsigned</span> selector, <span class="type">const</span> <span class="type">unsigned</span> **pins,</span></span><br><span class="line"><span class="params">      <span class="type">unsigned</span> *npins)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从 pinctrl_dev 结构中获取私有数据指针，将其转换为 rockchip_pinctrl 结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果选择器超出引脚组的范围，则返回错误码 -EINVAL</span></span><br><span class="line"><span class="keyword">if</span> (selector &gt;= info-&gt;ngroups)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指向引脚组的引脚数组的指针赋值给传入的 pins 指针</span></span><br><span class="line">*pins = info-&gt;groups[selector].pins;</span><br><span class="line">    <span class="comment">// 将引脚组中的引脚数量赋值给传入的 npins 变量</span></span><br><span class="line">*npins = info-&gt;groups[selector].npins;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dt-node-to-map"><a href="#dt-node-to-map" class="headerlink" title="dt_node_to_map"></a><code>dt_node_to_map</code></h4><blockquote><p>根据设备树节点创建与之相关联的 Pin Control 映射。</p></blockquote><p>该结构体用于在引脚控制器中定义引脚的映射关系。通过映射类型的不同，可以将引脚与具 体 的 复 用 功 能 或 配 置 信 息 关 联 起 来 ， 从 而 实 现 引 脚 的 配 置 和 控 制 </p><h5 id="pinctrl-map-结构体"><a href="#pinctrl-map-结构体" class="headerlink" title="pinctrl_map 结构体"></a>pinctrl_map 结构体</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/pinctrl/machine.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinctrl_map - boards/machines shall provide this map for devices</span></span><br><span class="line"><span class="comment"> * @dev_name: the name of the device using this specific mapping, the name</span></span><br><span class="line"><span class="comment"> *must be the same as in your struct device*. If this name is set to the</span></span><br><span class="line"><span class="comment"> *same name as the pin controllers own dev_name(), the map entry will be</span></span><br><span class="line"><span class="comment"> *hogged by the driver itself upon registration</span></span><br><span class="line"><span class="comment"> * @name: the name of this specific map entry for the particular machine.</span></span><br><span class="line"><span class="comment"> *This is the parameter passed to pinmux_lookup_state()</span></span><br><span class="line"><span class="comment"> * @type: the type of mapping table entry</span></span><br><span class="line"><span class="comment"> * @ctrl_dev_name: the name of the device controlling this specific mapping,</span></span><br><span class="line"><span class="comment"> *the name must be the same as in your struct device*. This field is not</span></span><br><span class="line"><span class="comment"> *used for PIN_MAP_TYPE_DUMMY_STATE</span></span><br><span class="line"><span class="comment"> * @data: Data specific to the mapping type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *dev_name;<span class="comment">// 设备名称</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;<span class="comment">// 映射名称</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pinctrl_map_type</span> <span class="title">type</span>;</span><span class="comment">// 映射类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *ctrl_dev_name;<span class="comment">// 控制设备名称</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_mux</span> <span class="title">mux</span>;</span><span class="comment">// 复用映射数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_configs</span> <span class="title">configs</span>;</span> <span class="comment">// 配置映射数据</span></span><br><span class="line">&#125; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_dt_node_to_map</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> pinctrl_map **<span class="built_in">map</span>, <span class="type">unsigned</span> *num_maps)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取引脚控制器的私有数据指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line">    <span class="comment">// 引脚组指针</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_group</span> *<span class="title">grp</span>;</span></span><br><span class="line">    <span class="comment">// 设备指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> info-&gt;dev;</span><br><span class="line">    <span class="comment">// 新的引脚映射数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> *<span class="title">new_map</span>;</span></span><br><span class="line">    <span class="comment">// 父节点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="comment">// 映射数量，默认为 1</span></span><br><span class="line"><span class="type">int</span> map_num = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * first find the group of this node and check if we need to create</span></span><br><span class="line"><span class="comment"> * config maps for pins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/* 查找引脚组 */</span></span><br><span class="line">grp = pinctrl_name_to_group(info, np-&gt;name);<span class="comment">// 根据节点名称查找对应的引脚组</span></span><br><span class="line"><span class="keyword">if</span> (!grp) &#123;<span class="comment">// 如果找不到引脚组，打印错误信息</span></span><br><span class="line">dev_err(dev, <span class="string">&quot;unable to find group for node %pOFn\n&quot;</span>, np);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map_num += grp-&gt;npins;<span class="comment">// 计算映射数量，包括复用映射和配置映射</span></span><br><span class="line"></span><br><span class="line">new_map = kcalloc(map_num, <span class="keyword">sizeof</span>(*new_map), GFP_KERNEL);<span class="comment">// 分配内存空间用于存储映射数组</span></span><br><span class="line"><span class="keyword">if</span> (!new_map)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">*<span class="built_in">map</span> = new_map;<span class="comment">// 将分配的映射数组赋值给输出参数</span></span><br><span class="line">*num_maps = map_num;<span class="comment">// 将映射数量赋值给输出参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* create mux map */</span></span><br><span class="line">    <span class="comment">/* 创建复用映射 */</span></span><br><span class="line">parent = of_get_parent(np); <span class="comment">// 获取节点的父节点</span></span><br><span class="line"><span class="keyword">if</span> (!parent) &#123;</span><br><span class="line">kfree(new_map);<span class="comment">// 如果父节点不存在，释放分配的映射数组内存空间</span></span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">new_map[<span class="number">0</span>].type = PIN_MAP_TYPE_MUX_GROUP;<span class="comment">// 设置映射类型为复用映射</span></span><br><span class="line">new_map[<span class="number">0</span>].data.mux.function = parent-&gt;name;<span class="comment">// 复用功能名称为父节点的名称</span></span><br><span class="line">new_map[<span class="number">0</span>].data.mux.group = np-&gt;name; <span class="comment">// 将设备节点的名称作为映射的组名</span></span><br><span class="line">of_node_put(parent);<span class="comment">// 释放父节点的引用计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* create config map */</span></span><br><span class="line">    <span class="comment">/* 创建配置映射 */</span></span><br><span class="line">new_map++;<span class="comment">// 映射数组指针向后移动一个位置</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; grp-&gt;npins; i++) &#123;</span><br><span class="line">new_map[i].type = PIN_MAP_TYPE_CONFIGS_PIN;<span class="comment">// 设置映射类型为配置映射</span></span><br><span class="line">new_map[i].data.configs.group_or_pin =</span><br><span class="line">pin_get_name(pctldev, grp-&gt;pins[i]);<span class="comment">// 引脚组或引脚名称为引脚组中的引脚名称</span></span><br><span class="line">new_map[i].data.configs.configs = grp-&gt;data[i].configs;<span class="comment">// 配置信息数组为引脚组中该引脚的配置信息</span></span><br><span class="line">new_map[i].data.configs.num_configs = grp-&gt;data[i].nconfigs;<span class="comment">// 配置信息数量为引脚组中该引脚的配置数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印调试信息，显示创建的引脚映射的功能名称、组名和数量</span></span><br><span class="line">dev_dbg(dev, <span class="string">&quot;maps: function %s group %s num %d\n&quot;</span>,</span><br><span class="line">(*<span class="built_in">map</span>)-&gt;data.mux.function, (*<span class="built_in">map</span>)-&gt;data.mux.group, map_num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rockchip_dt_node_to_map</code> 函数根据设备节点的信息创建引脚映射，包括复用映射和配置映射。</p><ul><li><strong>复用映射用于将引脚组的功能与父节点的功能关联起来</strong></li><li><strong>配置映射用于将引脚的配置信息与引脚的名称关联起来。</strong></li></ul><p>这些映射将用于配置引脚控制器，以确保引脚在系统中正确地配置和使用。这个函数在设备树解析过程中被调用，以便为每个设备节点创建相应的引脚映射。</p><h4 id="dt-free-map"><a href="#dt-free-map" class="headerlink" title="dt_free_map"></a><code>dt_free_map</code></h4><blockquote><p>释放通过 dt_node_to_map 创建的 Pin Control 映射。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rockchip_dt_free_map</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> pinctrl_map *<span class="built_in">map</span>, <span class="type">unsigned</span> num_maps)</span></span><br><span class="line">&#123;</span><br><span class="line">kfree(<span class="built_in">map</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pinmux-ops"><a href="#pinmux-ops" class="headerlink" title="pinmux_ops"></a>pinmux_ops</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinmux_ops - pinmux operations, to be implemented by pin controller</span></span><br><span class="line"><span class="comment"> * drivers that support pinmuxing</span></span><br><span class="line"><span class="comment"> * @request: called by the core to see if a certain pin can be made</span></span><br><span class="line"><span class="comment"> *available for muxing. This is called by the core to acquire the pins</span></span><br><span class="line"><span class="comment"> *before selecting any actual mux setting across a function. The driver</span></span><br><span class="line"><span class="comment"> *is allowed to answer &quot;no&quot; by returning a negative error code</span></span><br><span class="line"><span class="comment"> * @free: the reverse function of the request() callback, frees a pin after</span></span><br><span class="line"><span class="comment"> *being requested</span></span><br><span class="line"><span class="comment"> * @get_functions_count: returns number of selectable named functions available</span></span><br><span class="line"><span class="comment"> *in this pinmux driver</span></span><br><span class="line"><span class="comment"> * @get_function_name: return the function name of the muxing selector,</span></span><br><span class="line"><span class="comment"> *called by the core to figure out which mux setting it shall map a</span></span><br><span class="line"><span class="comment"> *certain device to</span></span><br><span class="line"><span class="comment"> * @get_function_groups: return an array of groups names (in turn</span></span><br><span class="line"><span class="comment"> *referencing pins) connected to a certain function selector. The group</span></span><br><span class="line"><span class="comment"> *name can be used with the generic @pinctrl_ops to retrieve the</span></span><br><span class="line"><span class="comment"> *actual pins affected. The applicable groups will be returned in</span></span><br><span class="line"><span class="comment"> *@groups and the number of groups in @num_groups</span></span><br><span class="line"><span class="comment"> * @set_mux: enable a certain muxing function with a certain pin group. The</span></span><br><span class="line"><span class="comment"> *driver does not need to figure out whether enabling this function</span></span><br><span class="line"><span class="comment"> *conflicts some other use of the pins in that group, such collisions</span></span><br><span class="line"><span class="comment"> *are handled by the pinmux subsystem. The @func_selector selects a</span></span><br><span class="line"><span class="comment"> *certain function whereas @group_selector selects a certain set of pins</span></span><br><span class="line"><span class="comment"> *to be used. On simple controllers the latter argument may be ignored</span></span><br><span class="line"><span class="comment"> * @gpio_request_enable: requests and enables GPIO on a certain pin.</span></span><br><span class="line"><span class="comment"> *Implement this only if you can mux every pin individually as GPIO. The</span></span><br><span class="line"><span class="comment"> *affected GPIO range is passed along with an offset(pin number) into that</span></span><br><span class="line"><span class="comment"> *specific GPIO range - function selectors and pin groups are orthogonal</span></span><br><span class="line"><span class="comment"> *to this, the core will however make sure the pins do not collide.</span></span><br><span class="line"><span class="comment"> * @gpio_disable_free: free up GPIO muxing on a certain pin, the reverse of</span></span><br><span class="line"><span class="comment"> *@gpio_request_enable</span></span><br><span class="line"><span class="comment"> * @gpio_set_direction: Since controllers may need different configurations</span></span><br><span class="line"><span class="comment"> *depending on whether the GPIO is configured as input or output,</span></span><br><span class="line"><span class="comment"> *a direction selector function may be implemented as a backing</span></span><br><span class="line"><span class="comment"> *to the GPIO controllers that need pin muxing.</span></span><br><span class="line"><span class="comment"> * @strict: do not allow simultaneous use of the same pin for GPIO and another</span></span><br><span class="line"><span class="comment"> *function. Check both gpio_owner and mux_owner strictly before approving</span></span><br><span class="line"><span class="comment"> *the pin request.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> &#123;</span></span><br><span class="line">    <span class="comment">// 查看是否可以将某个引脚设置为可用于复用</span></span><br><span class="line"><span class="type">int</span> (*request) (<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="type">unsigned</span> offset);</span><br><span class="line">    <span class="comment">// request() 回调的反向函数，在请求后释放引脚</span></span><br><span class="line"><span class="type">int</span> (*<span class="built_in">free</span>) (<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="type">unsigned</span> offset);</span><br><span class="line">    <span class="comment">// 返回此 Pinmux 驱动程序中可选择的命名函数数量</span></span><br><span class="line"><span class="type">int</span> (*get_functions_count) (<span class="keyword">struct</span> pinctrl_dev *pctldev);</span><br><span class="line">    <span class="comment">// 返回复用选择器的函数名称，核心调用此函数来确定应将某个设备映射到哪个复用设置</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *(*get_function_name) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">  <span class="type">unsigned</span> selector);</span><br><span class="line">    <span class="comment">// 返回与某个函数选择器相关联的一组组名称（依次引用引脚）</span></span><br><span class="line"><span class="type">int</span> (*get_function_groups) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">  <span class="type">unsigned</span> selector,</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> **groups,</span><br><span class="line">  <span class="type">unsigned</span> *num_groups);</span><br><span class="line">    <span class="comment">// 使用特定引脚组启用特定复用功能</span></span><br><span class="line"><span class="type">int</span> (*set_mux) (<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="type">unsigned</span> func_selector,</span><br><span class="line"><span class="type">unsigned</span> group_selector);</span><br><span class="line">    <span class="comment">// 在特定引脚上请求并启用 GPIO</span></span><br><span class="line"><span class="type">int</span> (*gpio_request_enable) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">    <span class="keyword">struct</span> pinctrl_gpio_range *range,</span><br><span class="line">    <span class="type">unsigned</span> offset);</span><br><span class="line">    <span class="comment">// 在特定引脚上释放 GPIO 复用</span></span><br><span class="line"><span class="type">void</span> (*gpio_disable_free) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">   <span class="keyword">struct</span> pinctrl_gpio_range *range,</span><br><span class="line">   <span class="type">unsigned</span> offset);</span><br><span class="line">    <span class="comment">// 根据 GPIO 配置为输入或输出而进行不同的配置</span></span><br><span class="line"><span class="type">int</span> (*gpio_set_direction) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">   <span class="keyword">struct</span> pinctrl_gpio_range *range,</span><br><span class="line">   <span class="type">unsigned</span> offset,</span><br><span class="line">   <span class="type">bool</span> input);</span><br><span class="line">    <span class="comment">// 不允许将同一引脚同时用于 GPIO 和其他功能。在批准引脚请求之前，严格检查 gpio_owner 和 mux_owner</span></span><br><span class="line"><span class="type">bool</span> strict;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>struct pinmux_ops</code> 是一个用于描述引脚复用操作的结构体。它定义了一组函数指针，这些函数指针指向了引脚控制器驱动程序中实现的具体功能。通过实现这些函数，引脚控制器驱动程序可以与核心交互，并提供引脚复用的功能。核心可以通过调用这些函数来请求、释放引脚，设置复用功能，操作 GPIO 等。这个结构体的设计允许引脚控制器驱动程序根据具体的硬件需求和功能定义自己的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> <span class="title">rockchip_pmx_ops</span> =</span> &#123;</span><br><span class="line">.get_functions_count= rockchip_pmx_get_funcs_count,</span><br><span class="line">.get_function_name= rockchip_pmx_get_func_name,</span><br><span class="line">.get_function_groups= rockchip_pmx_get_groups,</span><br><span class="line">.set_mux= rockchip_pmx_set,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="get-functions-count"><a href="#get-functions-count" class="headerlink" title="get_functions_count"></a><code>get_functions_count</code></h4><blockquote><p>返回在该引脚控制器驱动程序中可选择的命名函数的数量。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pmx_get_funcs_count</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> info-&gt;nfunctions;<span class="comment">// 返回引脚复用功能的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-function-name"><a href="#get-function-name" class="headerlink" title="get_function_name"></a><code>get_function_name</code></h4><blockquote><p>返回复用选择器的函数名称</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">rockchip_pmx_get_func_name</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span></span><br><span class="line"><span class="params">  <span class="type">unsigned</span> selector)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> info-&gt;functions[selector].name;<span class="comment">// 返回引脚复用功能的名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get-function-groups"><a href="#get-function-groups" class="headerlink" title="get_function_groups"></a><code>get_function_groups</code></h4><blockquote><p>返回与某个函数选择器相关联的一组组名称（依次引用引脚）。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pmx_get_groups</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> selector, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> **groups,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> * <span class="type">const</span> num_groups)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line"></span><br><span class="line">*groups = info-&gt;functions[selector].groups;<span class="comment">// 返回引脚复用功能对应的引脚组数组</span></span><br><span class="line">*num_groups = info-&gt;functions[selector].ngroups;<span class="comment">// 返回引脚组的数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-mux"><a href="#set-mux" class="headerlink" title="set_mux"></a><code>set_mux</code></h4><blockquote><p>用于启用特定的复用功能。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pmx_set</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="type">unsigned</span> selector,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> group)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> *pins = info-&gt;groups[group].pins;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_config</span> *<span class="title">data</span> =</span> info-&gt;groups[group].data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> info-&gt;dev;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_bank</span> *<span class="title">bank</span>;</span></span><br><span class="line"><span class="type">int</span> cnt, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">dev_dbg(dev, <span class="string">&quot;enable function %s group %s\n&quot;</span>,</span><br><span class="line">info-&gt;functions[selector].name, info-&gt;groups[group].name);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * for each pin in the pin group selected, program the corresponding</span></span><br><span class="line"><span class="comment"> * pin function number in the config register.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 针对所选的引脚组中的每个引脚，将相应的引脚功能号码编程到配置寄存器中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; info-&gt;groups[group].npins; cnt++) &#123;</span><br><span class="line">bank = pin_to_bank(info, pins[cnt]);</span><br><span class="line">ret = rockchip_set_mux(bank, pins[cnt] - bank-&gt;pin_base,</span><br><span class="line">       data[cnt].func);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &amp;&amp; cnt) &#123;</span><br><span class="line"><span class="comment">/* revert the already done pin settings */</span></span><br><span class="line">        <span class="comment">/* 恢复已经设置的引脚设置 */</span></span><br><span class="line"><span class="keyword">for</span> (cnt--; cnt &gt;= <span class="number">0</span> &amp;&amp; !data[cnt].func; cnt--)</span><br><span class="line">rockchip_set_mux(bank, pins[cnt] - bank-&gt;pin_base, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pinconf-ops"><a href="#pinconf-ops" class="headerlink" title="pinconf_ops"></a>pinconf_ops</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinconf_ops - pin config operations, to be implemented by</span></span><br><span class="line"><span class="comment"> * pin configuration capable drivers.</span></span><br><span class="line"><span class="comment"> * @is_generic: for pin controllers that want to use the generic interface,</span></span><br><span class="line"><span class="comment"> *this flag tells the framework that it&#x27;s generic.</span></span><br><span class="line"><span class="comment"> * @pin_config_get: get the config of a certain pin, if the requested config</span></span><br><span class="line"><span class="comment"> *is not available on this controller this should return -ENOTSUPP</span></span><br><span class="line"><span class="comment"> *and if it is available but disabled it should return -EINVAL</span></span><br><span class="line"><span class="comment"> * @pin_config_set: configure an individual pin</span></span><br><span class="line"><span class="comment"> * @pin_config_group_get: get configurations for an entire pin group; should</span></span><br><span class="line"><span class="comment"> *return -ENOTSUPP and -EINVAL using the same rules as pin_config_get.</span></span><br><span class="line"><span class="comment"> * @pin_config_group_set: configure all pins in a group</span></span><br><span class="line"><span class="comment"> * @pin_config_dbg_show: optional debugfs display hook that will provide</span></span><br><span class="line"><span class="comment"> *per-device info for a certain pin in debugfs</span></span><br><span class="line"><span class="comment"> * @pin_config_group_dbg_show: optional debugfs display hook that will provide</span></span><br><span class="line"><span class="comment"> *per-device info for a certain group in debugfs</span></span><br><span class="line"><span class="comment"> * @pin_config_config_dbg_show: optional debugfs display hook that will decode</span></span><br><span class="line"><span class="comment"> *and display a driver&#x27;s pin configuration parameter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line"><span class="type">bool</span> is_generic;<span class="comment">// 是否为通用引脚配置操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     <span class="comment">// 获取引脚配置信息</span></span><br><span class="line"><span class="type">int</span> (*pin_config_get) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">       <span class="type">unsigned</span> pin,</span><br><span class="line">       <span class="type">unsigned</span> <span class="type">long</span> *config);</span><br><span class="line">    <span class="comment">// 设置引脚配置信息</span></span><br><span class="line"><span class="type">int</span> (*pin_config_set) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">       <span class="type">unsigned</span> pin,</span><br><span class="line">       <span class="type">unsigned</span> <span class="type">long</span> *configs,</span><br><span class="line">       <span class="type">unsigned</span> num_configs);</span><br><span class="line">    <span class="comment">// 获取引脚组配置信息</span></span><br><span class="line"><span class="type">int</span> (*pin_config_group_get) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">     <span class="type">unsigned</span> selector,</span><br><span class="line">     <span class="type">unsigned</span> <span class="type">long</span> *config);</span><br><span class="line">    <span class="comment">// 设置引脚组配置信息</span></span><br><span class="line"><span class="type">int</span> (*pin_config_group_set) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">     <span class="type">unsigned</span> selector,</span><br><span class="line">     <span class="type">unsigned</span> <span class="type">long</span> *configs,</span><br><span class="line">     <span class="type">unsigned</span> num_configs);</span><br><span class="line">    <span class="comment">// 调试函数，显示引脚配置信息</span></span><br><span class="line"><span class="type">void</span> (*pin_config_dbg_show) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">     <span class="keyword">struct</span> seq_file *s,</span><br><span class="line">     <span class="type">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 调试函数，显示引脚组配置信息</span></span><br><span class="line"><span class="type">void</span> (*pin_config_group_dbg_show) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">   <span class="keyword">struct</span> seq_file *s,</span><br><span class="line">   <span class="type">unsigned</span> selector);</span><br><span class="line">    <span class="comment">// 调试函数，显示引脚配置的具体信息</span></span><br><span class="line"><span class="type">void</span> (*pin_config_config_dbg_show) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">    <span class="keyword">struct</span> seq_file *s,</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> config);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结构体 pinconf_ops，用于<strong>定义引脚配置操作</strong>的函数指针。每个函数指针都对应了一个特定的操作，如获取引脚配置、设置引脚配置、获取引脚组配置等。这些函数在驱动程序中实现，用于对硬件引脚进行配置和控制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> <span class="title">rockchip_pinconf_ops</span> =</span> &#123;</span><br><span class="line">.pin_config_get= rockchip_pinconf_get,<span class="comment">// 获取引脚配置的函数</span></span><br><span class="line">.pin_config_set= rockchip_pinconf_set,<span class="comment">// 设置引脚配置的函数</span></span><br><span class="line">.is_generic= <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="pin-config-get"><a href="#pin-config-get" class="headerlink" title="pin_config_get"></a><code>pin_config_get</code></h4><blockquote><p>获取引脚配置信息。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get the pin config settings for a specified pin */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pinconf_get</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="type">unsigned</span> <span class="type">int</span> pin,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> *config)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_bank</span> *<span class="title">bank</span> =</span> pin_to_bank(info, pin);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gpio</span> =</span> &amp;bank-&gt;gpio_chip;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pin_config_param</span> <span class="title">param</span> =</span> pinconf_to_config_param(*config);</span><br><span class="line">u16 arg;</span><br><span class="line"><span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (param) &#123;</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_BIAS_DISABLE:<span class="comment">// 检查上下拉电阻是否禁用</span></span><br><span class="line"><span class="keyword">if</span> (rockchip_get_pull(bank, pin - bank-&gt;pin_base) != param)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">arg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_BIAS_PULL_UP:</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_BIAS_PULL_DOWN:</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_BIAS_BUS_HOLD:<span class="comment">// 检查上下拉电阻是否有效，并获取当前的上下拉电阻配置</span></span><br><span class="line"><span class="keyword">if</span> (!rockchip_pinconf_pull_valid(info-&gt;ctrl, param))</span><br><span class="line"><span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rockchip_get_pull(bank, pin - bank-&gt;pin_base) != param)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">arg = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_OUTPUT:<span class="comment">// 检查引脚是否配置为 GPIO 输出模式</span></span><br><span class="line">rc = rockchip_get_mux(bank, pin - bank-&gt;pin_base);</span><br><span class="line"><span class="keyword">if</span> (rc != RK_FUNC_GPIO)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!gpio || !gpio-&gt;get) &#123;</span><br><span class="line">arg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取引脚的输出状态</span></span><br><span class="line">rc = gpio-&gt;get(gpio, pin - bank-&gt;pin_base);</span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">arg = rc ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_DRIVE_STRENGTH:</span><br><span class="line"><span class="comment">/* rk3288 is the first with per-pin drive-strength */</span></span><br><span class="line">        <span class="comment">// 仅支持某些芯片（如 rk3288）的每个引脚独立的驱动强度设置</span></span><br><span class="line"><span class="keyword">if</span> (!info-&gt;ctrl-&gt;drv_calc_reg)</span><br><span class="line"><span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line"><span class="comment">// 获取引脚的驱动强度配置</span></span><br><span class="line">rc = rockchip_get_drive_perpin(bank, pin - bank-&gt;pin_base);</span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">arg = rc;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_INPUT_SCHMITT_ENABLE:</span><br><span class="line">        <span class="comment">// 仅支持某些芯片的施密特触发设置</span></span><br><span class="line"><span class="keyword">if</span> (!info-&gt;ctrl-&gt;schmitt_calc_reg)</span><br><span class="line"><span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line"><span class="comment">// 获取引脚的施密特触发配置</span></span><br><span class="line">rc = rockchip_get_schmitt(bank, pin - bank-&gt;pin_base);</span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">arg = rc;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_SLEW_RATE:</span><br><span class="line">        <span class="comment">// 仅支持某些芯片的引脚驱动速率设置</span></span><br><span class="line"><span class="keyword">if</span> (!info-&gt;ctrl-&gt;slew_rate_calc_reg)</span><br><span class="line"><span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line"><span class="comment">// 获取引脚的驱动速率配置</span></span><br><span class="line">rc = rockchip_get_slew_rate(bank, pin - bank-&gt;pin_base);</span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">arg = rc;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:<span class="comment">// 不支持的配置参数</span></span><br><span class="line"><span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*config = pinconf_to_config_packed(param, arg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="pin-config-set"><a href="#pin-config-set" class="headerlink" title="pin_config_set"></a><code>pin_config_set</code></h4><blockquote><p> 设置引脚配置信息。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set the pin config settings for a specified pin */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pinconf_set</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="type">unsigned</span> <span class="type">int</span> pin,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> *configs, <span class="type">unsigned</span> num_configs)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_bank</span> *<span class="title">bank</span> =</span> pin_to_bank(info, pin);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gpio</span> =</span> &amp;bank-&gt;gpio_chip;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pin_config_param</span> <span class="title">param</span>;</span></span><br><span class="line">u32 arg;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_configs; i++) &#123;</span><br><span class="line">param = pinconf_to_config_param(configs[i]);</span><br><span class="line">arg = pinconf_to_config_argument(configs[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (param == PIN_CONFIG_OUTPUT || param == PIN_CONFIG_INPUT_ENABLE) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check for gpio driver not being probed yet.</span></span><br><span class="line"><span class="comment"> * The lock makes sure that either gpio-probe has completed</span></span><br><span class="line"><span class="comment"> * or the gpio driver hasn&#x27;t probed yet.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 检查 GPIO 驱动程序是否已经探测到。</span></span><br><span class="line"><span class="comment">* 锁定确保 GPIO 探测完成或者 GPIO 驱动程序尚未探测到。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mutex_lock(&amp;bank-&gt;deferred_lock);</span><br><span class="line"><span class="keyword">if</span> (!gpio || !gpio-&gt;direction_output) &#123;</span><br><span class="line">                <span class="comment">// 如果驱动程序尚未探测到，则将配置信息延迟处理并返回。</span></span><br><span class="line">rc = rockchip_pinconf_defer_pin(bank, pin - bank-&gt;pin_base, param,</span><br><span class="line">arg);</span><br><span class="line">mutex_unlock(&amp;bank-&gt;deferred_lock);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;bank-&gt;deferred_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (param) &#123;</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_BIAS_DISABLE:</span><br><span class="line">            <span class="comment">// 禁用上下拉电阻</span></span><br><span class="line">rc =  rockchip_set_pull(bank, pin - bank-&gt;pin_base,</span><br><span class="line">param);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_BIAS_PULL_UP:</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_BIAS_PULL_DOWN:</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_BIAS_BUS_HOLD:</span><br><span class="line">            <span class="comment">// 检查上下拉电阻是否有效</span></span><br><span class="line"><span class="keyword">if</span> (!rockchip_pinconf_pull_valid(info-&gt;ctrl, param))</span><br><span class="line"><span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!arg)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">// 设置上下拉电阻</span></span><br><span class="line">rc = rockchip_set_pull(bank, pin - bank-&gt;pin_base,</span><br><span class="line">param);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_OUTPUT:</span><br><span class="line">            <span class="comment">// 设置引脚复用功能为 GPIO</span></span><br><span class="line">rc = rockchip_set_mux(bank, pin - bank-&gt;pin_base,</span><br><span class="line">      RK_FUNC_GPIO);</span><br><span class="line"><span class="keyword">if</span> (rc != RK_FUNC_GPIO)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">// 设置引脚为输出模式</span></span><br><span class="line">rc = gpio-&gt;direction_output(gpio, pin - bank-&gt;pin_base,</span><br><span class="line">    arg);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_INPUT_ENABLE:</span><br><span class="line">            <span class="comment">// 设置引脚复用功能为 GPIO</span></span><br><span class="line">rc = rockchip_set_mux(bank, pin - bank-&gt;pin_base,</span><br><span class="line">      RK_FUNC_GPIO);</span><br><span class="line"><span class="keyword">if</span> (rc != RK_FUNC_GPIO)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">// 设置引脚为输入模式</span></span><br><span class="line">rc = gpio-&gt;direction_input(gpio, pin - bank-&gt;pin_base);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_DRIVE_STRENGTH:</span><br><span class="line"><span class="comment">/* rk3288 is the first with per-pin drive-strength */</span></span><br><span class="line">            <span class="comment">// 仅支持某些芯片（如 rk3288）的每个引脚独立的驱动强度设置</span></span><br><span class="line"><span class="keyword">if</span> (!info-&gt;ctrl-&gt;drv_calc_reg)</span><br><span class="line"><span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line"><span class="comment">// 设置引脚的驱动强度</span></span><br><span class="line">rc = rockchip_set_drive_perpin(bank,</span><br><span class="line">pin - bank-&gt;pin_base, arg);</span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_INPUT_SCHMITT_ENABLE:</span><br><span class="line">            <span class="comment">// 仅支持某些芯片的施密特触发设置</span></span><br><span class="line"><span class="keyword">if</span> (!info-&gt;ctrl-&gt;schmitt_calc_reg)</span><br><span class="line"><span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line"><span class="comment">// 设置引脚的施密特触发模式</span></span><br><span class="line">rc = rockchip_set_schmitt(bank,</span><br><span class="line">  pin - bank-&gt;pin_base, arg);</span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIN_CONFIG_SLEW_RATE:</span><br><span class="line">            <span class="comment">// 仅支持某些芯片的引脚驱动速率设置</span></span><br><span class="line"><span class="keyword">if</span> (!info-&gt;ctrl-&gt;slew_rate_calc_reg)</span><br><span class="line"><span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line"><span class="comment">// 设置引脚的驱动速率</span></span><br><span class="line">rc = rockchip_set_slew_rate(bank,</span><br><span class="line">    pin - bank-&gt;pin_base, arg);</span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:<span class="comment">// 不支持的配置参数</span></span><br><span class="line"><span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">/* for each config */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251216154950779.jpg" alt="pinctrl"></p><h1 id="pinctrl-bind-pins"><a href="#pinctrl-bind-pins" class="headerlink" title="pinctrl_bind_pins()"></a>pinctrl_bind_pins()</h1><p><strong>引脚的复用关系是在什么时候被设置的？</strong></p><p>以 485 控制引脚的设备树节点和对应的 pinctrl 设备树节点进行举例，要添加的 485 设备树内容如下所示</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">rk_485_ctl:</span> <span class="title class_">rk-485-ctl</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;topeet,rs485_ctl&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> <span class="number">22</span> GPIO_ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;rk_485_gpio</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">&amp;pinctrl</span> <span class="punctuation">&#123;</span></span><br><span class="line">rk_485<span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">rk_485_gpio:</span><span class="title class_">rk-485-gpio</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">rockchip,pins</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3</span> <span class="number">13</span> RK_FUNC_GPIO <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当上面编写的 485 设备树跟驱动匹配成功之后，就会进入相应驱动中的 probe 函数，在probe 函数中就可以对设备树中描述的 485 使能引脚进行拉高和拉低的操作，从而控制 485 的接收和发送。</p><p>所以可以猜测在进入驱动的 probe 函数之前就已经使用 pinctrl 子系统对引脚进行了复用，在设备模型中，我们已经知道了驱动中的 probe 函数是在内核源码目录下的<code>drivers/base/dd.c</code>文件中加载执行的，然后找到 <code>really_probe</code> 函数中与 probe 函数加载相<br>关的代码，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">really_probe</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = -EPROBE_DEFER;</span><br><span class="line"><span class="type">int</span> local_trigger_count = <span class="type">atomic_read</span>(&amp;deferred_trigger_count);</span><br><span class="line"><span class="type">bool</span> test_remove = IS_ENABLED(CONFIG_DEBUG_TEST_DRIVER_REMOVE) &amp;&amp;</span><br><span class="line">   !drv-&gt;suppress_bind_attrs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (defer_all_probes) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Value of defer_all_probes can be set only by</span></span><br><span class="line"><span class="comment"> * device_block_probing() which, in turn, will call</span></span><br><span class="line"><span class="comment"> * wait_for_device_probe() right after that to avoid any races.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dev_dbg(dev, <span class="string">&quot;Driver %s force probe deferral\n&quot;</span>, drv-&gt;name);</span><br><span class="line">driver_deferred_probe_add(dev);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = device_links_check_suppliers(dev);</span><br><span class="line"><span class="keyword">if</span> (ret == -EPROBE_DEFER)</span><br><span class="line">driver_deferred_probe_add_trigger(dev, local_trigger_count);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="type">atomic_inc</span>(&amp;probe_count);</span><br><span class="line">pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: probing driver %s with device %s\n&quot;</span>,</span><br><span class="line"> drv-&gt;bus-&gt;name, __func__, drv-&gt;name, dev_name(dev));</span><br><span class="line"><span class="keyword">if</span> (!list_empty(&amp;dev-&gt;devres_head)) &#123;</span><br><span class="line">dev_crit(dev, <span class="string">&quot;Resources present before probing\n&quot;</span>);</span><br><span class="line">ret = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">re_probe:</span><br><span class="line">dev-&gt;driver = drv;<span class="comment">// 将设备的驱动程序指针设置为当前驱动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* If using pinctrl, bind pins now before probing */</span></span><br><span class="line">    <span class="comment">/* 如果使用了 pinctrl，在探测之前绑定引脚 */</span></span><br><span class="line">ret = pinctrl_bind_pins(dev);<span class="comment">// 绑定设备的引脚</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> pinctrl_bind_failed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;bus-&gt;dma_configure) &#123;<span class="comment">// 配置 DMA</span></span><br><span class="line">ret = dev-&gt;bus-&gt;dma_configure(dev);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> probe_failed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = driver_sysfs_add(dev);<span class="comment">// 添加驱动程序的 sysfs 接口</span></span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;%s: driver_sysfs_add(%s) failed\n&quot;</span>,</span><br><span class="line">       __func__, dev_name(dev));</span><br><span class="line"><span class="keyword">goto</span> probe_failed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;activate) &#123;</span><br><span class="line">ret = dev-&gt;pm_domain-&gt;activate(dev);<span class="comment">// 激活电源管理域</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> probe_failed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;bus-&gt;probe) &#123;</span><br><span class="line">ret = dev-&gt;bus-&gt;probe(dev);<span class="comment">// 如果总线的探测函数存在，则调用总线的探测函数</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> probe_failed;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;probe) &#123;</span><br><span class="line">ret = drv-&gt;probe(dev);<span class="comment">// 否则调用驱动程序的探测函数</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> probe_failed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = device_add_groups(dev, drv-&gt;dev_groups);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_err(dev, <span class="string">&quot;device_add_groups() failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> dev_groups_failed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev_has_sync_state(dev)) &#123;</span><br><span class="line">ret = device_create_file(dev, &amp;dev_attr_state_synced);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_err(dev, <span class="string">&quot;state_synced sysfs add failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> dev_sysfs_state_synced_failed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (test_remove) &#123;</span><br><span class="line">test_remove = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">device_remove_file(dev, &amp;dev_attr_state_synced);</span><br><span class="line">device_remove_groups(dev, drv-&gt;dev_groups);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;bus-&gt;remove)<span class="comment">// 如果总线的移除函数存在，则调用总线的移除函数</span></span><br><span class="line">dev-&gt;bus-&gt;remove(dev);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;remove)<span class="comment">// 否则调用驱动程序的移除函数</span></span><br><span class="line">drv-&gt;remove(dev);</span><br><span class="line"></span><br><span class="line">devres_release_all(dev);<span class="comment">// 释放设备资源</span></span><br><span class="line">arch_teardown_dma_ops(dev);</span><br><span class="line">kfree(dev-&gt;dma_range_map);</span><br><span class="line">dev-&gt;dma_range_map = <span class="literal">NULL</span>;</span><br><span class="line">driver_sysfs_remove(dev);<span class="comment">// 移除驱动程序的 sysfs 接口</span></span><br><span class="line">dev-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">dev_set_drvdata(dev, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)</span><br><span class="line">dev-&gt;pm_domain-&gt;dismiss(dev);<span class="comment">// 解除电源管理域的激活状态</span></span><br><span class="line">pm_runtime_reinit(dev);<span class="comment">// 重新初始化电源管理运行时</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> re_probe;<span class="comment">// 重新进行设备的探测</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pinctrl_init_done(dev);<span class="comment">// 完成引脚控制器的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;sync)</span><br><span class="line">dev-&gt;pm_domain-&gt;sync(dev);<span class="comment">// 同步电源管理域</span></span><br><span class="line"></span><br><span class="line">driver_bound(dev);<span class="comment">// 驱动程序与设备绑定成功</span></span><br><span class="line">ret = <span class="number">1</span>;</span><br><span class="line">pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: bound device %s to driver %s\n&quot;</span>,</span><br><span class="line"> drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">dev_sysfs_state_synced_failed:</span><br><span class="line">device_remove_groups(dev, drv-&gt;dev_groups);</span><br><span class="line">dev_groups_failed:</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;bus-&gt;remove)</span><br><span class="line">dev-&gt;bus-&gt;remove(dev);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;remove)</span><br><span class="line">drv-&gt;remove(dev);</span><br><span class="line">probe_failed:</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">     BUS_NOTIFY_DRIVER_NOT_BOUND, dev);</span><br><span class="line">pinctrl_bind_failed:</span><br><span class="line">device_links_no_driver(dev);</span><br><span class="line">devres_release_all(dev);</span><br><span class="line">arch_teardown_dma_ops(dev);</span><br><span class="line">kfree(dev-&gt;dma_range_map);</span><br><span class="line">dev-&gt;dma_range_map = <span class="literal">NULL</span>;</span><br><span class="line">driver_sysfs_remove(dev);</span><br><span class="line">dev-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">dev_set_drvdata(dev, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)</span><br><span class="line">dev-&gt;pm_domain-&gt;dismiss(dev);</span><br><span class="line">pm_runtime_reinit(dev);</span><br><span class="line">dev_pm_set_driver_flags(dev, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="keyword">case</span> -EPROBE_DEFER:</span><br><span class="line"><span class="comment">/* Driver requested deferred probing */</span></span><br><span class="line">dev_dbg(dev, <span class="string">&quot;Driver %s requests probe deferral\n&quot;</span>, drv-&gt;name);</span><br><span class="line">driver_deferred_probe_add_trigger(dev, local_trigger_count);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> -ENODEV:</span><br><span class="line"><span class="keyword">case</span> -ENXIO:</span><br><span class="line">pr_debug(<span class="string">&quot;%s: probe of %s rejects match %d\n&quot;</span>,</span><br><span class="line"> drv-&gt;name, dev_name(dev), ret);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">/* driver matched but the probe failed */</span></span><br><span class="line">pr_warn(<span class="string">&quot;%s: probe of %s failed with error %d\n&quot;</span>,</span><br><span class="line">drv-&gt;name, dev_name(dev), ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ignore errors returned by -&gt;probe so that the next driver can try</span></span><br><span class="line"><span class="comment"> * its luck.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">done:<span class="comment">// 执行完成后的处理逻辑</span></span><br><span class="line"><span class="type">atomic_dec</span>(&amp;probe_count);</span><br><span class="line">wake_up_all(&amp;probe_waitqueue);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用了 pinctrl 就会调用第 39 行的 <code>pinctrl_bind_pins()</code>函数进行设备引脚的绑定，然后根据线索跳转到 <code>pinctrl_bind_pins</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/base/pinctrl.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pinctrl_bind_pins() - called by the device core before probe</span></span><br><span class="line"><span class="comment"> * @dev: the device that is just about to probe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinctrl_bind_pins</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="comment">// 检查设备是否重用了节点</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;of_node_reused)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 为设备的引脚分配内存空间</span></span><br><span class="line">dev-&gt;pins = devm_kzalloc(dev, <span class="keyword">sizeof</span>(*(dev-&gt;pins)), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;pins)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取设备的 pinctrl 句柄</span></span><br><span class="line">dev-&gt;pins-&gt;p = devm_pinctrl_get(dev);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;p)) &#123;</span><br><span class="line">dev_dbg(dev, <span class="string">&quot;no pinctrl handle\n&quot;</span>);</span><br><span class="line">ret = PTR_ERR(dev-&gt;pins-&gt;p);</span><br><span class="line"><span class="keyword">goto</span> cleanup_alloc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找设备的默认 pinctrl 状态</span></span><br><span class="line">dev-&gt;pins-&gt;default_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">PINCTRL_STATE_DEFAULT);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;default_state)) &#123;</span><br><span class="line">dev_dbg(dev, <span class="string">&quot;no default pinctrl state\n&quot;</span>);</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> cleanup_get;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找设备的初始化 pinctrl 状态</span></span><br><span class="line">dev-&gt;pins-&gt;init_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">PINCTRL_STATE_INIT);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;init_state)) &#123;</span><br><span class="line"><span class="comment">/* Not supplying this state is perfectly legal */</span></span><br><span class="line">        <span class="comment">/* 不提供此状态是完全合法的 */</span></span><br><span class="line">dev_dbg(dev, <span class="string">&quot;no init pinctrl state\n&quot;</span>);</span><br><span class="line"><span class="comment">// 选择默认的 pinctrl 状态</span></span><br><span class="line">ret = pinctrl_select_state(dev-&gt;pins-&gt;p,</span><br><span class="line">   dev-&gt;pins-&gt;default_state);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 选择初始化的 pinctrl 状态</span></span><br><span class="line">ret = pinctrl_select_state(dev-&gt;pins-&gt;p, dev-&gt;pins-&gt;init_state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_dbg(dev, <span class="string">&quot;failed to activate initial pinctrl state\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> cleanup_get;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If power management is enabled, we also look for the optional</span></span><br><span class="line"><span class="comment"> * sleep and idle pin states, with semantics as defined in</span></span><br><span class="line"><span class="comment"> * &lt;linux/pinctrl/pinctrl-state.h&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果启用了电源管理，我们还会寻找可选的睡眠和空闲的引脚状态，其语义在</span></span><br><span class="line"><span class="comment">* &lt;linux/pinctrl/pinctrl-state.h&gt; 中定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dev-&gt;pins-&gt;sleep_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">PINCTRL_STATE_SLEEP);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;sleep_state))</span><br><span class="line"><span class="comment">/* Not supplying this state is perfectly legal */</span></span><br><span class="line">        <span class="comment">/* 不提供此状态是完全合法的 */</span></span><br><span class="line">dev_dbg(dev, <span class="string">&quot;no sleep pinctrl state\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">dev-&gt;pins-&gt;idle_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">PINCTRL_STATE_IDLE);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;idle_state))</span><br><span class="line"><span class="comment">/* Not supplying this state is perfectly legal */</span></span><br><span class="line">        <span class="comment">/* 不提供此状态是完全合法的 */</span></span><br><span class="line">dev_dbg(dev, <span class="string">&quot;no idle pinctrl state\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If no pinctrl handle or default state was found for this device,</span></span><br><span class="line"><span class="comment"> * let&#x27;s explicitly free the pin container in the device, there is</span></span><br><span class="line"><span class="comment"> * no point in keeping it around.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/* 如果对于此设备没有找到 pinctrl 句柄或默认状态，</span></span><br><span class="line"><span class="comment">* 让我们明确释放设备中的引脚容器，因为保留它没有意义。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">cleanup_get:</span><br><span class="line">devm_pinctrl_put(dev-&gt;pins-&gt;p);</span><br><span class="line">cleanup_alloc:</span><br><span class="line">devm_kfree(dev, dev-&gt;pins);</span><br><span class="line">dev-&gt;pins = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return deferrals */</span></span><br><span class="line"><span class="keyword">if</span> (ret == -EPROBE_DEFER)<span class="comment">/* 返回延迟 */</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"><span class="comment">/* Return serious errors */</span></span><br><span class="line"><span class="keyword">if</span> (ret == -EINVAL)<span class="comment">/* 返回严重错误 */</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"><span class="comment">/* We ignore errors like -ENOENT meaning no pinctrl state */</span></span><br><span class="line"><span class="comment">/* 我们忽略诸如 -ENOENT 的错误，表示没有 pinctrl 状态 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于<code>struct device</code>结构体:</p><p>其中含有<code>struct dev_pin_info    *pins;</code>成员表示该设备的引脚信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span><span class="comment">// 内核对象，用于设备的管理</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span>*<span class="title">parent</span>;</span><span class="comment">// 指向父设备的指针</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_private</span>*<span class="title">p</span>;</span><span class="comment">// 私有数据指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*init_name; <span class="comment">/* initial name of the device */</span> <span class="comment">// 设备的初始名称</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> *<span class="title">type</span>;</span><span class="comment">// 设备类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span>*<span class="title">bus</span>;</span><span class="comment">/* type of bus device is on */</span> <span class="comment">// 设备所在的总线类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span><span class="comment">/* which driver has allocated this</span></span><br><span class="line"><span class="comment">   device */</span> <span class="comment">// 分配该设备的驱动程序</span></span><br><span class="line"><span class="type">void</span>*platform_data;<span class="comment">/* Platform specific data, device</span></span><br><span class="line"><span class="comment">   core doesn&#x27;t touch it */</span> <span class="comment">// 平台特定的数据，设备核心不会修改它</span></span><br><span class="line"><span class="type">void</span>*driver_data;<span class="comment">/* Driver data, set and get with</span></span><br><span class="line"><span class="comment">   dev_set_drvdata/dev_get_drvdata */</span> <span class="comment">// 驱动程序的数据，使用 dev_set/get_drvdata 来设置和获取</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROVE_LOCKING</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span><span class="title">lockdep_mutex</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span><span class="title">mutex</span>;</span><span class="comment">/* mutex to synchronize calls to* its driver.*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_links_info</span><span class="title">links</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_info</span><span class="title">power</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_domain</span>*<span class="title">pm_domain</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ENERGY_MODEL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">em_perf_domain</span>*<span class="title">em_pd</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ_DOMAIN</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span>*<span class="title">msi_domain</span>;</span> <span class="comment">// 设备的通用 MSI IRQ 域</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PINCTRL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span>*<span class="title">pins</span>;</span><span class="comment">// 设备的引脚信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="struct-dev-pin-info-结构体"><a href="#struct-dev-pin-info-结构体" class="headerlink" title="struct dev_pin_info 结构体"></a>struct dev_pin_info 结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct dev_pin_info - pin state container for devices</span></span><br><span class="line"><span class="comment"> * @p: pinctrl handle for the containing device</span></span><br><span class="line"><span class="comment"> * @default_state: the default state for the handle, if found</span></span><br><span class="line"><span class="comment"> * @init_state: the state at probe time, if found</span></span><br><span class="line"><span class="comment"> * @sleep_state: the state at suspend time, if found</span></span><br><span class="line"><span class="comment"> * @idle_state: the state at idle (runtime suspend) time, if found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span>                 <span class="comment">// 引脚控制器指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">default_state</span>;</span><span class="comment">// 默认状态指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">init_state</span>;</span><span class="comment">// 初始化状态指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">sleep_state</span>;</span><span class="comment">// 睡眠状态指针 仅在支持电源管理时可用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">idle_state</span>;</span><span class="comment">// 空闲状态指针 仅在支持电源管理时可用</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><code>struct pinctrl *p</code>：引脚控制器指针。该指针指向设备所使用的引脚控制器对象，用于对设备的引脚进行控制和配置。</p></li><li><p><code>struct pinctrl_state *default_state</code>：默认状态指针。该指针指向设备的默认引脚配置状态，表示设备在正常操作时的引脚配置。</p></li><li><p><code>struct pinctrl_state *init_state</code>：初始化状态指针。该指针指向设备的初始化引脚配置状态，表示设备在初始化阶段的引脚配置。</p></li><li><code>struct pinctrl_state *sleep_state</code>：睡眠状态指针（仅在支持电源管理时可用）。该指针指向设备的引脚配置状态，表示设备在进入睡眠状态时的引脚配置。</li><li><code>struct pinctrl_state *idle_state</code>：空闲状态指针（仅在支持电源管理时可用）。该指针指向设备的引脚配置状态，表示设备在空闲状态时的引脚配置。</li></ul><p>仍以485控制引脚为例</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">rk_485_ctl:</span> <span class="title class_">rk-485-ctl</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;topeet,rs485_ctl&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> <span class="number">22</span> GPIO_ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;rk_485_gpio</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">&amp;pinctrl</span> <span class="punctuation">&#123;</span></span><br><span class="line">rk_485<span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">rk_485_gpio:</span><span class="title class_">rk-485-gpio</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">rockchip,pins</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3</span> <span class="number">13</span> RK_FUNC_GPIO <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中第 4 行的 pinctrl-names 属性指定了设备所使用的引脚控制器为 default，即第 5 行的 pinctrl-0，而 pinctrl-0 的值为 pinctrl 节点中的 rk_485_gpio，所以 <code>struct pinctrl_state *default_state</code> 这一默认状态结构体指针会用来存放 11 行的引脚复用信息，而在上一章节中也提到了设备树中的 pinctrl 节点会转换为 pinctrl_map 结构体，那么 <code>struct pinctrl_state *default_state</code> 必然会跟 <code>pinctrl_map</code> 结构体建立联系。</p><h2 id="devm-pinctrl-get"><a href="#devm-pinctrl-get" class="headerlink" title="devm_pinctrl_get()"></a>devm_pinctrl_get()</h2><p><code>pinctrl_bind_pins()</code>函数中通过<code>dev-&gt;pins-&gt;p = devm_pinctrl_get(dev);</code>来获取设备的pinctrl句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/core.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * devm_pinctrl_get() - Resource managed pinctrl_get()</span></span><br><span class="line"><span class="comment"> * @dev: the device to obtain the handle for</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If there is a need to explicitly destroy the returned struct pinctrl,</span></span><br><span class="line"><span class="comment"> * devm_pinctrl_put() should be used, rather than plain pinctrl_put().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> pinctrl *<span class="title function_">devm_pinctrl_get</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> **<span class="title">ptr</span>, *<span class="title">p</span>;</span></span><br><span class="line"><span class="comment">// 为存储引脚控制器句柄的指针分配内存</span></span><br><span class="line">ptr = devres_alloc(devm_pinctrl_release, <span class="keyword">sizeof</span>(*ptr), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!ptr)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取设备的引脚控制器句柄</span></span><br><span class="line">p = pinctrl_get(dev);</span><br><span class="line"><span class="keyword">if</span> (!IS_ERR(p)) &#123;</span><br><span class="line">        <span class="comment">// 如果获取成功，将引脚控制器句柄存储在指针中</span></span><br><span class="line">*ptr = p;</span><br><span class="line">        <span class="comment">// 将指针添加到设备资源中</span></span><br><span class="line">devres_add(dev, ptr);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果获取失败，释放之前分配的指针内存</span></span><br><span class="line">devres_free(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(devm_pinctrl_get);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见通过pinctrl_get获取引脚控制器句柄</p><h3 id="pinctrl-get"><a href="#pinctrl-get" class="headerlink" title="pinctrl_get()"></a>pinctrl_get()</h3><p><code>devm_pinctrl_get()</code>函数中通过<code>pinctrl_get()</code>函数获取引脚控制器句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/core.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pinctrl_get() - retrieves the pinctrl handle for a device</span></span><br><span class="line"><span class="comment"> * @dev: the device to obtain the handle for</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> pinctrl *<span class="title function_">pinctrl_get</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="comment">// 检查设备指针是否为空</span></span><br><span class="line"><span class="keyword">if</span> (WARN_ON(!dev))</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * See if somebody else (such as the device core) has already</span></span><br><span class="line"><span class="comment"> * obtained a handle to the pinctrl for this device. In that case,</span></span><br><span class="line"><span class="comment"> * return another pointer to it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 查看是否有其他组件（如设备核心）已经获取了此设备的引脚控制器句柄。</span></span><br><span class="line"><span class="comment">* 在这种情况下，返回对该句柄的另一个指针。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">p = find_pinctrl(dev);</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">dev_dbg(dev, <span class="string">&quot;obtain a copy of previously claimed pinctrl\n&quot;</span>);</span><br><span class="line">kref_get(&amp;p-&gt;users);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建并返回设备的引脚控制器句柄</span></span><br><span class="line"><span class="keyword">return</span> create_pinctrl(dev, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pinctrl_get);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在返回值中使用 <code>create_pinctrl</code> 函数，该函数会创建并返回设备的引脚控制器句柄</p><h3 id="create-pinctrl"><a href="#create-pinctrl" class="headerlink" title="create_pinctrl()"></a>create_pinctrl()</h3><p><code>pinctrl_get()</code>最后调用<code>create_pinctrl()</code>创建并返回设备的引脚控制器句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/core.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> pinctrl *<span class="title function_">create_pinctrl</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> pinctrl_dev *pctldev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *devname;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_maps</span> *<span class="title">maps_node</span>;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * create the state cookie holder struct pinctrl for each</span></span><br><span class="line"><span class="comment"> * mapping, this is what consumers will get when requesting</span></span><br><span class="line"><span class="comment"> * a pin control handle with pinctrl_get()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 为每个映射创建状态 cookie 持有者 struct pinctrl。</span></span><br><span class="line"><span class="comment">* 这是当使用 pinctrl_get() 请求引脚控制句柄时消费者将获得的对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">p = kzalloc(<span class="keyword">sizeof</span>(*p), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">p-&gt;dev = dev;</span><br><span class="line">INIT_LIST_HEAD(&amp;p-&gt;states);</span><br><span class="line">INIT_LIST_HEAD(&amp;p-&gt;dt_maps);</span><br><span class="line"></span><br><span class="line">ret = pinctrl_dt_to_map(p, pctldev);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">kfree(p);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">devname = dev_name(dev);</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;pinctrl_maps_mutex);</span><br><span class="line"><span class="comment">/* Iterate over the pin control maps to locate the right ones */</span></span><br><span class="line">    <span class="comment">/* 遍历引脚控制映射以定位正确的映射 */</span></span><br><span class="line">for_each_maps(maps_node, i, <span class="built_in">map</span>) &#123;</span><br><span class="line"><span class="comment">/* Map must be for this device */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="built_in">map</span>-&gt;dev_name, devname))<span class="comment">/* 映射必须适用于此设备 */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If pctldev is not null, we are claiming hog for it,</span></span><br><span class="line"><span class="comment"> * that means, setting that is served by pctldev by itself.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Thus we must skip map that is for this device but is served</span></span><br><span class="line"><span class="comment"> * by other device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果 pctldev 不为空，我们正在声明它的独占使用权，</span></span><br><span class="line"><span class="comment">* 这意味着它自己提供了该设置。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 因此，我们必须跳过适用于此设备但由其他设备提供的映射。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (pctldev &amp;&amp;</span><br><span class="line">    <span class="built_in">strcmp</span>(dev_name(pctldev-&gt;dev), <span class="built_in">map</span>-&gt;ctrl_dev_name))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">ret = add_setting(p, pctldev, <span class="built_in">map</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * At this point the adding of a setting may:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - Defer, if the pinctrl device is not yet available</span></span><br><span class="line"><span class="comment"> * - Fail, if the pinctrl device is not yet available,</span></span><br><span class="line"><span class="comment"> *   AND the setting is a hog. We cannot defer that, since</span></span><br><span class="line"><span class="comment"> *   the hog will kick in immediately after the device</span></span><br><span class="line"><span class="comment"> *   is registered.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the error returned was not -EPROBE_DEFER then we</span></span><br><span class="line"><span class="comment"> * accumulate the errors to see if we end up with</span></span><br><span class="line"><span class="comment"> * an -EPROBE_DEFER later, as that is the worst case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在这一点上，添加设置可能会导致：</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* - 延迟，如果引脚控制设备尚不可用</span></span><br><span class="line"><span class="comment">* - 失败，如果引脚控制设备尚不可用，</span></span><br><span class="line"><span class="comment">* 并且该设置是一个独占设置。我们不能推迟它，因为</span></span><br><span class="line"><span class="comment">* 该独占设置会在设备注册后立即生效。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 如果返回的错误不是 -EPROBE_DEFER，则我们将</span></span><br><span class="line"><span class="comment">* 累积错误，以查看是否最终得到 -EPROBE_DEFER，</span></span><br><span class="line"><span class="comment">* 因为那是最糟糕的情况。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (ret == -EPROBE_DEFER) &#123;</span><br><span class="line">pinctrl_free(p, <span class="literal">false</span>);</span><br><span class="line">mutex_unlock(&amp;pinctrl_maps_mutex);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;pinctrl_maps_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* If some other error than deferral occurred, return here */</span></span><br><span class="line">        <span class="comment">/* 如果发生了除推迟以外的其他错误，则在此处返回 */</span></span><br><span class="line">pinctrl_free(p, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kref_init(&amp;p-&gt;users);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add the pinctrl handle to the global list */</span></span><br><span class="line">    <span class="comment">/* 将引脚控制句柄添加到全局列表 */</span></span><br><span class="line">mutex_lock(&amp;pinctrl_list_mutex);</span><br><span class="line">list_add_tail(&amp;p-&gt;node, &amp;pinctrl_list);</span><br><span class="line">mutex_unlock(&amp;pinctrl_list_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>三个重要结构体：</p><ul><li><code>struct pinctrl</code></li><li><code>struct pinctrl_maps</code></li><li><code>struct pinctrl_map</code></li></ul><p><code>for_each_maps</code>定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏定义：用于遍历映射表链表中的每个映射表条目</span></span><br><span class="line"><span class="comment">// _maps_node_: 遍历时使用的映射表节点指针</span></span><br><span class="line"><span class="comment">// _i_: 遍历时使用的计数器变量</span></span><br><span class="line"><span class="comment">// _map_: 遍历时使用的映射表条目指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_maps(_maps_node_, _i_, _map_) \</span></span><br><span class="line"><span class="meta">list_for_each_entry(_maps_node_, &amp;pinctrl_maps, node) \ <span class="comment">// 遍历映射表链表中的每个节点</span></span></span><br><span class="line"><span class="keyword">for</span> (_i_ = <span class="number">0</span>, _map_ = &amp;_maps_node_-&gt;maps[_i_]; \ <span class="comment">// 初始化计数器和映射表条目指针</span></span><br><span class="line">_i_ &lt; _maps_node_-&gt;num_maps; \ <span class="comment">// 循环条件：计数器小于当前节点的映射表数量</span></span><br><span class="line">_i_++, _map_ = &amp;_maps_node_-&gt;maps[_i_]) <span class="comment">// 每次循环增加计数器并更新映射表条目指针</span></span><br></pre></td></tr></table></figure><h4 id="pinctrl-结构体"><a href="#pinctrl-结构体" class="headerlink" title="pinctrl 结构体"></a>pinctrl 结构体</h4><p><code>struct pinctrl</code> 结构体用于表示引脚控制器。</p><p>引脚控制器是硬件系统中管理和控制引脚（GPIO）的组件，它负责配置引脚的功能、电气属性等，该结构体定义在内核源码目录下的<code>drivers/pinctrl/core.h</code>文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinctrl - per-device pin control state holder</span></span><br><span class="line"><span class="comment"> * @node: global list node</span></span><br><span class="line"><span class="comment"> * @dev: the device using this pin control handle</span></span><br><span class="line"><span class="comment"> * @states: a list of states for this device</span></span><br><span class="line"><span class="comment"> * @state: the current state</span></span><br><span class="line"><span class="comment"> * @dt_maps: the mapping table chunks dynamically parsed from device tree for</span></span><br><span class="line"><span class="comment"> *this device, if any</span></span><br><span class="line"><span class="comment"> * @users: reference count</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span><span class="comment">// 用于将引脚控制器添加到全局列表的链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span><span class="comment">// 关联的设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">states</span>;</span> <span class="comment">// 存储引脚配置状态的链表，用于跟踪不同的引脚配置状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">state</span>;</span><span class="comment">// 当前应用的引脚配置状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dt_maps</span>;</span><span class="comment">// 存储设备树中定义的引脚映射信息的链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">users</span>;</span><span class="comment">// 引脚控制器的引用计数，用于跟踪引脚控制器的引用数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="pinctrl-maps-结构体"><a href="#pinctrl-maps-结构体" class="headerlink" title="pinctrl_maps 结构体"></a>pinctrl_maps 结构体</h4><p><code>struct pinctrl_maps</code> 类型的变量 maps_node 用于遍历引脚控制映射，引脚控制器映射描述了不同引脚控制器的功能和配置与实际硬件引脚之间的对应关系，该结构体定义在内核源码目录下的<code>drivers/pinctrl/core.h</code>文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinctrl_maps - a list item containing part of the mapping table</span></span><br><span class="line"><span class="comment"> * @node: mapping table list node</span></span><br><span class="line"><span class="comment"> * @maps: array of mapping table entries</span></span><br><span class="line"><span class="comment"> * @num_maps: the number of entries in @maps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_maps</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span> <span class="comment">// 引脚控制器映射链表节点，用于将该映射添加到全局列表</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> *<span class="title">maps</span>;</span><span class="comment">// 指向引脚控制器映射数组的指针</span></span><br><span class="line"><span class="type">unsigned</span> num_maps;<span class="comment">// 引脚控制器映射数组中的映射数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>pinctrl_map</code>结构体在<code>dt_node_to_map</code>中创建</p><h4 id="pinctrl-dt-to-map"><a href="#pinctrl-dt-to-map" class="headerlink" title="pinctrl_dt_to_map()"></a>pinctrl_dt_to_map()</h4><p><code>create_pinctrl()</code>中通过调用 <code>pinctrl_dt_to_map</code> 函数将设备树中定义的引脚映射信息转换为 <code>struct pinctrl_map</code> 结构，并将其添加到 <code>p-&gt;dt_maps</code> 链表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/devicetree.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinctrl_dt_to_map</span><span class="params">(<span class="keyword">struct</span> pinctrl *p, <span class="keyword">struct</span> pinctrl_dev *pctldev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> p-&gt;dev-&gt;of_node;<span class="comment">// 获取引脚控制器关联设备的设备树节点</span></span><br><span class="line"><span class="type">int</span> state, ret;</span><br><span class="line"><span class="type">char</span> *propname;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">prop</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *statename;</span><br><span class="line"><span class="type">const</span> __be32 *<span class="built_in">list</span>;</span><br><span class="line"><span class="type">int</span> size, config;</span><br><span class="line">phandle phandle;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np_config</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CONFIG_OF enabled, p-&gt;dev not instantiated from DT */</span></span><br><span class="line">    <span class="comment">/* 如果 CONFIG_OF 启用，且 p-&gt;dev 不是从设备树实例化而来 */</span></span><br><span class="line"><span class="keyword">if</span> (!np) &#123;</span><br><span class="line"><span class="keyword">if</span> (of_have_populated_dt())</span><br><span class="line">dev_dbg(p-&gt;dev,</span><br><span class="line"><span class="string">&quot;no of_node; not parsing pinctrl DT\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We may store pointers to property names within the node */</span></span><br><span class="line">    <span class="comment">/* 节点内部存储属性名称的指针 */</span></span><br><span class="line">of_node_get(np);<span class="comment">//增加设备树节点的引用计数，以确保在解析过程中节点不会被释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* For each defined state ID */</span></span><br><span class="line">    <span class="comment">/* 对于每个定义的状态 ID */</span></span><br><span class="line"><span class="keyword">for</span> (state = <span class="number">0</span>; ; state++) &#123;</span><br><span class="line"><span class="comment">/* Retrieve the pinctrl-* property */</span></span><br><span class="line">        <span class="comment">/* 获取 pinctrl-* 属性 */</span></span><br><span class="line">propname = kasprintf(GFP_KERNEL, <span class="string">&quot;pinctrl-%d&quot;</span>, state);</span><br><span class="line"><span class="keyword">if</span> (!propname)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">prop = of_find_property(np, propname, &amp;size);</span><br><span class="line">kfree(propname);</span><br><span class="line"><span class="keyword">if</span> (!prop) &#123;</span><br><span class="line"><span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">of_node_put(np);</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">list</span> = prop-&gt;value;</span><br><span class="line">size /= <span class="keyword">sizeof</span>(*<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Determine whether pinctrl-names property names the state */</span></span><br><span class="line">        <span class="comment">/* 判断 pinctrl-names 属性是否命名了该状态 */</span></span><br><span class="line">ret = of_property_read_string_index(np, <span class="string">&quot;pinctrl-names&quot;</span>,</span><br><span class="line">    state, &amp;statename);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If not, statename is just the integer state ID. But rather</span></span><br><span class="line"><span class="comment"> * than dynamically allocate it and have to free it later,</span></span><br><span class="line"><span class="comment"> * just point part way into the property name for the string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果未命名，则 statename 仅是整数状态 ID。但是，为了避免动态分配和之后要释放的麻烦，</span></span><br><span class="line"><span class="comment">* 可以直接将 statename 指向属性名称的一部分。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">statename = prop-&gt;name + <span class="built_in">strlen</span>(<span class="string">&quot;pinctrl-&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* For every referenced pin configuration node in it */</span></span><br><span class="line">        <span class="comment">/* 对于其中的每个引用的引脚配置节点 */</span></span><br><span class="line"><span class="keyword">for</span> (config = <span class="number">0</span>; config &lt; size; config++) &#123;</span><br><span class="line">phandle = be32_to_cpup(<span class="built_in">list</span>++);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Look up the pin configuration node */</span></span><br><span class="line">            <span class="comment">/* 查找引脚配置节点 */</span></span><br><span class="line">np_config = of_find_node_by_phandle(phandle);</span><br><span class="line"><span class="keyword">if</span> (!np_config) &#123;</span><br><span class="line">dev_err(p-&gt;dev,</span><br><span class="line"><span class="string">&quot;prop %s index %i invalid phandle\n&quot;</span>,</span><br><span class="line">prop-&gt;name, config);</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Parse the node */</span></span><br><span class="line">            <span class="comment">/* 解析节点 */</span></span><br><span class="line">ret = dt_to_map_one_config(p, pctldev, statename,</span><br><span class="line">   np_config);</span><br><span class="line">of_node_put(np_config);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* No entries in DT? Generate a dummy state table entry */</span></span><br><span class="line">        <span class="comment">/* 如果在设备树中没有条目，则生成一个虚拟状态表条目 */</span></span><br><span class="line"><span class="keyword">if</span> (!size) &#123;</span><br><span class="line">ret = dt_remember_dummy_state(p, statename);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">pinctrl_dt_free_maps(p);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于每个定义的状态 ID，循环解析引脚控制器的映射信息具体会执行以下步骤：</p><ul><li>构造属性名称字符串 propname，例如 “pinctrl-0”、”pinctrl-1” 等等。</li><li>使用 <code>of_find_property</code> 函数获取设备树节点 np 中的属性 propname 的值，并得到属性值的大小 size。如果属性不存在，则判断是否是第一个状态 ID，如果是，则释放节点引用并返回 -ENODEV 表示设备树节点中没有有效的 pinctrl 描述。否则，跳出循环。</li><li>将属性值转换为指针列表 list，并计算列表的大小。</li><li>如果设备树中的 pinctrl-names 属性命名了该状态，则使用 <code>of_property_read_string_index</code> 函数读取属性值，并将状态名称存储在 statename 变量中。否则，将 statename 指向属性名称的一部分，即去除 “pinctrl-“ 前缀。</li><li>对于每个引用的引脚配置节点，执行以下步骤：<ul><li>将 list 指针指向的 phandle 值转换为本地字节序。</li><li>使用 <code>of_find_node_by_phandle</code> 函数根据 phandle 查找引脚配置节点，并将其存储在 np_config 变量中。如果找不到引脚配置节点，则打印错误信息并返回 -EINVAL。</li><li>调用 <code>dt_to_map_one_config</code> 函数，将引脚配置节点的信息解析为 pinctrl 映射，并存储在 pctldev 中。</li><li>递减引脚配置节点的引用计数。</li><li>如果在设备树中没有条目，则生成一个虚拟状态表条目，以便后续处理。</li></ul></li></ul><p>其中<code>dt_to_map_one_config</code> 函数需要特别注意，该函数会从设备树节点中解析出引脚控制器的映射表，并将其存储起来，该函数的具体内容如下所示:</p><h5 id="dt-to-map-one-config"><a href="#dt-to-map-one-config" class="headerlink" title="dt_to_map_one_config()"></a>dt_to_map_one_config()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dt_to_map_one_config</span><span class="params">(<span class="keyword">struct</span> pinctrl *p,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> pinctrl_dev *hog_pctldev,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *statename,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> device_node *np_config)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np_pctldev</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> *<span class="title">map</span>;</span></span><br><span class="line"><span class="type">unsigned</span> num_maps;</span><br><span class="line"><span class="type">bool</span> allow_default = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find the pin controller containing np_config */</span></span><br><span class="line">    <span class="comment">/* 查找包含 np_config 的引脚控制器 */</span></span><br><span class="line">np_pctldev = of_node_get(np_config);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">/* 如果不允许默认配置，则读取 pinctrl-use-default 属性 */</span></span><br><span class="line"><span class="keyword">if</span> (!allow_default)</span><br><span class="line">allow_default = of_property_read_bool(np_pctldev,</span><br><span class="line">      <span class="string">&quot;pinctrl-use-default&quot;</span>);</span><br><span class="line"><span class="comment">/* 获取 np_pctldev 的父节点 */</span></span><br><span class="line">np_pctldev = of_get_next_parent(np_pctldev);</span><br><span class="line">        <span class="comment">/* 如果没有父节点或者父节点是根节点，则释放 np_pctldev 引用并返回 */</span></span><br><span class="line"><span class="keyword">if</span> (!np_pctldev || of_node_is_root(np_pctldev)) &#123;</span><br><span class="line">of_node_put(np_pctldev);</span><br><span class="line">            <span class="comment">/* 检查是否延迟探测驱动程序状态 */</span></span><br><span class="line">ret = driver_deferred_probe_check_state(p-&gt;dev);</span><br><span class="line"><span class="comment">/* keep deferring if modules are enabled */</span></span><br><span class="line">            <span class="comment">/* 如果启用了模块并且不允许默认配置，并且返回值是 -ENODEV，则延迟探测 */</span></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_MODULES) &amp;&amp; !allow_default &amp;&amp; ret &lt; <span class="number">0</span>)</span><br><span class="line">ret = -EPROBE_DEFER;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* If we&#x27;re creating a hog we can use the passed pctldev */</span></span><br><span class="line">        <span class="comment">/* 如果正在创建一个 hog，可以使用传递的 pctldev */</span></span><br><span class="line"><span class="keyword">if</span> (hog_pctldev &amp;&amp; (np_pctldev == p-&gt;dev-&gt;of_node)) &#123;</span><br><span class="line">pctldev = hog_pctldev;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/* 通过 np_pctldev 获取 pinctrl_dev 结构体 */</span></span><br><span class="line">pctldev = get_pinctrl_dev_from_of_node(np_pctldev);</span><br><span class="line">        <span class="comment">/* 如果获取到了 pinctrl_dev 结构体，则跳出循环 */</span></span><br><span class="line"><span class="keyword">if</span> (pctldev)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* Do not defer probing of hogs (circular loop) */</span></span><br><span class="line">        <span class="comment">/* 不要推迟探测 hogs（循环） */</span></span><br><span class="line"><span class="keyword">if</span> (np_pctldev == p-&gt;dev-&gt;of_node) &#123;</span><br><span class="line">of_node_put(np_pctldev);</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">of_node_put(np_pctldev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Call pinctrl driver to parse device tree node, and</span></span><br><span class="line"><span class="comment"> * generate mapping table entries</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 调用 pinctrl 驱动程序解析设备树节点，并生成映射表条目</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ops = pctldev-&gt;desc-&gt;pctlops;</span><br><span class="line">    <span class="comment">/* 检查 pinctrl 驱动程序是否支持设备树, 即是否实现了 dt_node_to_map 方法。如果不支持，返回错误码。 */</span></span><br><span class="line"><span class="keyword">if</span> (!ops-&gt;dt_node_to_map) &#123;</span><br><span class="line">dev_err(p-&gt;dev, <span class="string">&quot;pctldev %s doesn&#x27;t support DT\n&quot;</span>,</span><br><span class="line">dev_name(pctldev-&gt;dev));</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 调用 pinctrl 驱动程序的 dt_node_to_map 方法 */</span></span><br><span class="line">ret = ops-&gt;dt_node_to_map(pctldev, np_config, &amp;<span class="built_in">map</span>, &amp;num_maps);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num_maps == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we have no valid maps (maybe caused by empty pinctrl node</span></span><br><span class="line"><span class="comment"> * or typing error) ther is no need remember this, so just</span></span><br><span class="line"><span class="comment"> * return.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dev_info(p-&gt;dev,</span><br><span class="line"> <span class="string">&quot;there is not valid maps for state %s\n&quot;</span>, statename);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Stash the mapping table chunk away for later use */</span></span><br><span class="line">    <span class="comment">/* 将映射表块存储起来以供后续使用 */</span></span><br><span class="line"><span class="keyword">return</span> dt_remember_or_free_map(p, statename, pctldev, <span class="built_in">map</span>, num_maps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第70行调用引脚控制器的 <code>dt_node_to_map</code> 方法，将设备树节点 np_config 转换为映射表条目。该方法会解析设备树节点，并根据节点信息生成映射表条目。具体的转换过程由各个pinctrl的驱动程序实现。</p><h5 id="dt-remember-or-free-map"><a href="#dt-remember-or-free-map" class="headerlink" title="dt_remember_or_free_map()"></a>dt_remember_or_free_map()</h5><p> <code>dt_to_map_one_config</code> 函数用于从设备树节点中解析出引脚控制器的映射表并存储起来，而存储的操作由函数 <code>dt_remember_or_free_map</code> 完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dt_remember_or_free_map</span><span class="params">(<span class="keyword">struct</span> pinctrl *p, <span class="type">const</span> <span class="type">char</span> *statename,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> pinctrl_dev *pctldev,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> pinctrl_map *<span class="built_in">map</span>, <span class="type">unsigned</span> num_maps)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dt_map</span> *<span class="title">dt_map</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize common mapping table entry fields */</span></span><br><span class="line">    <span class="comment">// 循环遍历映射表条目数组，为每个条目初始化公共字段 </span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_maps; i++) &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *devname;</span><br><span class="line"><span class="comment">// 通过 kstrdup_const 函数复制引脚控制器设备的名称，并将返回的指针赋值给 devname</span></span><br><span class="line">devname = kstrdup_const(dev_name(p-&gt;dev), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!devname)</span><br><span class="line"><span class="keyword">goto</span> err_free_map;</span><br><span class="line"><span class="comment">// 设置映射表条目的设备名称、状态名称和控制器设备名称 </span></span><br><span class="line"><span class="built_in">map</span>[i].dev_name = devname;</span><br><span class="line"><span class="built_in">map</span>[i].name = statename;</span><br><span class="line"><span class="keyword">if</span> (pctldev)</span><br><span class="line"><span class="built_in">map</span>[i].ctrl_dev_name = dev_name(pctldev-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remember the converted mapping table entries */</span></span><br><span class="line">    <span class="comment">/* 记录转换后的映射表条目 */</span></span><br><span class="line">dt_map = kzalloc(<span class="keyword">sizeof</span>(*dt_map), GFP_KERNEL);<span class="comment">//使用 kzalloc 分配内存空间，并将返回的指针赋值给 dt_map</span></span><br><span class="line"><span class="keyword">if</span> (!dt_map)</span><br><span class="line"><span class="keyword">goto</span> err_free_map;</span><br><span class="line"><span class="comment">// 将传入的 pctldev、map 和 num_maps 分别赋值给 dt_map 的对应字段</span></span><br><span class="line">dt_map-&gt;pctldev = pctldev;</span><br><span class="line">dt_map-&gt;<span class="built_in">map</span> = <span class="built_in">map</span>;</span><br><span class="line">dt_map-&gt;num_maps = num_maps;</span><br><span class="line">list_add_tail(&amp;dt_map-&gt;node, &amp;p-&gt;dt_maps);<span class="comment">// 使用 list_add_tail 函数将 dt_map 添加到 p-&gt;dt_maps 链表中</span></span><br><span class="line"><span class="comment">/* 注册映射表条目 */</span></span><br><span class="line"><span class="keyword">return</span> pinctrl_register_mappings(<span class="built_in">map</span>, num_maps);</span><br><span class="line"></span><br><span class="line">err_free_map:</span><br><span class="line">    <span class="comment">/* 释放映射表条目内存 */</span></span><br><span class="line">dt_free_map(pctldev, <span class="built_in">map</span>, num_maps);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数传递参数：</p><ul><li><strong>p</strong>：指向 <code>struct pinctrl</code> 结构体的指针，表示引脚控制器的上下文。</li><li><strong>statename</strong>：指向状态名称的指针，表示要设置的状态的名称。</li><li><strong>pctldev</strong>：指向 <code>struct pinctrl_dev</code> 结构体的指针，表示引脚控制器设备。</li><li><strong>map</strong>：指向 <code>struct pinctrl_map</code> 结构体数组的指针，表示解析得到的映射表条目。</li><li><strong>num_maps</strong>：表示映射表条目的数量</li></ul><h5 id="pinctrl-dt-map-结构体"><a href="#pinctrl-dt-map-结构体" class="headerlink" title="pinctrl_dt_map 结构体"></a>pinctrl_dt_map 结构体</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dt_map</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span><span class="comment">//用于将映射表结构体添加到 pinctrl 的 dt_maps 链表中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span><span class="comment">// 引脚控制器设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> *<span class="title">map</span>;</span><span class="comment">// 映射表条目数组</span></span><br><span class="line"><span class="type">unsigned</span> num_maps;<span class="comment">//映射表条目数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="pinctrl-register-mappings"><a href="#pinctrl-register-mappings" class="headerlink" title="pinctrl_register_mappings()"></a>pinctrl_register_mappings()</h5><p><code>dt_remember_or_free_map()</code>最后用 <code>pinctrl_register_mappings()</code> 函数注册映射表条目。该函数将映射表条目注册到 pinctrl 子系统，以便后续可以通过相关接口进行引脚配置和管理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pinctrl_register_mappings() - register a set of pin controller mappings</span></span><br><span class="line"><span class="comment"> * @maps: the pincontrol mappings table to register. Note the pinctrl-core</span></span><br><span class="line"><span class="comment"> *keeps a reference to the passed in maps, so they should _not_ be</span></span><br><span class="line"><span class="comment"> *marked with __initdata.</span></span><br><span class="line"><span class="comment"> * @num_maps: the number of maps in the mapping table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// maps 指向映射表条目数组的指针</span></span><br><span class="line"><span class="comment">// num_maps 映射表条目数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinctrl_register_mappings</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pinctrl_map *maps,</span></span><br><span class="line"><span class="params">      <span class="type">unsigned</span> num_maps)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_maps</span> *<span class="title">maps_node</span>;</span></span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">&quot;add %u pinctrl maps\n&quot;</span>, num_maps);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* First sanity check the new mapping */</span></span><br><span class="line">    <span class="comment">/* 首先对新映射表进行合法性检查 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_maps; i++) &#123;</span><br><span class="line">        <span class="comment">// 检查设备名称是否存在</span></span><br><span class="line"><span class="keyword">if</span> (!maps[i].dev_name) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;failed to register map %s (%d): no device given\n&quot;</span>,</span><br><span class="line">       maps[i].name, i);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查映射表名称是否存在</span></span><br><span class="line"><span class="keyword">if</span> (!maps[i].name) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;failed to register map %d: no map name given\n&quot;</span>,</span><br><span class="line">       i);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于引脚映射类型和配置映射类型，检查引脚控制设备名称是否存在</span></span><br><span class="line"><span class="keyword">if</span> (maps[i].type != PIN_MAP_TYPE_DUMMY_STATE &amp;&amp;</span><br><span class="line">!maps[i].ctrl_dev_name) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;failed to register map %s (%d): no pin control device given\n&quot;</span>,</span><br><span class="line">       maps[i].name, i);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (maps[i].type) &#123;</span><br><span class="line"><span class="keyword">case</span> PIN_MAP_TYPE_DUMMY_STATE:<span class="comment">// 对于虚拟状态映射类型，不进行验证</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:<span class="comment">// 对于复用组映射类型，进行引脚复用映射验证</span></span><br><span class="line">ret = pinmux_validate_map(&amp;maps[i], i);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line"><span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:<span class="comment">// 对于配置映射类型，进行引脚配置映射验证</span></span><br><span class="line">ret = pinconf_validate_map(&amp;maps[i], i);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:<span class="comment">// 对于无效的映射类型，返回错误</span></span><br><span class="line">pr_err(<span class="string">&quot;failed to register map %s (%d): invalid type given\n&quot;</span>,</span><br><span class="line">       maps[i].name, i);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分配映射表节点内存</span></span><br><span class="line">maps_node = kzalloc(<span class="keyword">sizeof</span>(*maps_node), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!maps_node)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="comment">// 设置映射表节点的映射表和映射表数量</span></span><br><span class="line">maps_node-&gt;maps = maps;</span><br><span class="line">maps_node-&gt;num_maps = num_maps;</span><br><span class="line"><span class="comment">// 加锁并将映射表节点插入映射表链表末尾</span></span><br><span class="line">mutex_lock(&amp;pinctrl_maps_mutex);</span><br><span class="line">list_add_tail(&amp;maps_node-&gt;node, &amp;pinctrl_maps);</span><br><span class="line">mutex_unlock(&amp;pinctrl_maps_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pinctrl_register_mappings);</span><br></pre></td></tr></table></figure><p>可见<code>pinctrl_register_mappings</code> 函数的作用是注册一个引脚控制器的映射表<code>pinctrl_maps</code>，进行了一些参数合法性检查和验证，并将映射表节点插入到映射表链表中。</p><h4 id="add-setting"><a href="#add-setting" class="headerlink" title="add_setting()"></a>add_setting()</h4><p><code>create_pinctrl</code>函数中，通过 <code>ret = add_setting(p, pctldev, map);</code>将映射添加到引脚控制器中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">add_setting</span><span class="params">(<span class="keyword">struct</span> pinctrl *p, <span class="keyword">struct</span> pinctrl_dev *pctldev,</span></span><br><span class="line"><span class="params">       <span class="type">const</span> <span class="keyword">struct</span> pinctrl_map *<span class="built_in">map</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">state</span>;</span><span class="comment">// pinctrl_state对象指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting</span> *<span class="title">setting</span>;</span><span class="comment">// pinctrl_setting对象指针</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找pinctrl_state，如果不存在则创建新的pinctrl_state</span></span><br><span class="line">state = find_state(p, <span class="built_in">map</span>-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (!state)</span><br><span class="line">state = create_state(p, <span class="built_in">map</span>-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(state))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(state);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果映射类型为虚拟状态映射类型，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>-&gt;type == PIN_MAP_TYPE_DUMMY_STATE)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配pinctrl_setting的内存空间</span></span><br><span class="line">setting = kzalloc(<span class="keyword">sizeof</span>(*setting), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!setting)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">setting-&gt;type = <span class="built_in">map</span>-&gt;type;<span class="comment">// 设置pinctrl_setting的映射类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pctldev)<span class="comment">// 设置pinctrl_setting的引脚控制设备</span></span><br><span class="line">setting-&gt;pctldev = pctldev;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">setting-&gt;pctldev =</span><br><span class="line">get_pinctrl_dev_from_devname(<span class="built_in">map</span>-&gt;ctrl_dev_name);</span><br><span class="line"><span class="keyword">if</span> (!setting-&gt;pctldev) &#123;</span><br><span class="line">kfree(setting);</span><br><span class="line"><span class="comment">/* Do not defer probing of hogs (circular loop) */</span></span><br><span class="line">        <span class="comment">// 如果引脚控制设备不存在，返回错误</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="built_in">map</span>-&gt;ctrl_dev_name, <span class="built_in">map</span>-&gt;dev_name))</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * OK let us guess that the driver is not there yet, and</span></span><br><span class="line"><span class="comment"> * let&#x27;s defer obtaining this pinctrl handle to later...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dev_info(p-&gt;dev, <span class="string">&quot;unknown pinctrl device %s in map entry, deferring probe&quot;</span>,</span><br><span class="line"><span class="built_in">map</span>-&gt;ctrl_dev_name);</span><br><span class="line"><span class="keyword">return</span> -EPROBE_DEFER;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置pinctrl_setting的设备名称</span></span><br><span class="line">setting-&gt;dev_name = <span class="built_in">map</span>-&gt;dev_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (<span class="built_in">map</span>-&gt;type) &#123;</span><br><span class="line"><span class="keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:</span><br><span class="line">        <span class="comment">// 对于复用组映射类型，执行pinctrl_map到pinctrl_setting的转换</span></span><br><span class="line">ret = pinmux_map_to_setting(<span class="built_in">map</span>, setting);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line"><span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:</span><br><span class="line">        <span class="comment">// 对于配置映射类型，执行pinctrl_map到pinctrl_setting的转换</span></span><br><span class="line">ret = pinconf_map_to_setting(<span class="built_in">map</span>, setting);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">kfree(setting);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将pinctrl_setting插入状态对象的设置链表末尾</span></span><br><span class="line">list_add_tail(&amp;setting-&gt;node, &amp;state-&gt;settings);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li><p>对于复用组映射类型（<strong>PIN_MAP_TYPE_MUX_GROUP</strong>），调用 <code>pinmux_map_to_setting</code> 函数执行引脚复用映射到设置对象的转换。</p></li><li><p>对于配置映射类型（<strong>PIN_MAP_TYPE_CONFIGS_PIN</strong> 或 <strong>PIN_MAP_TYPE_CONFIGS_GROUP</strong>），调用 <code>pinconf_map_to_setting</code> 函数执行引脚配置映射到设置对象的转换。</p></li></ul><p>add_setting 函数的最终目的就是将传入的 <code>const struct pinctrl_map *map</code> 的参数值传入到 <code>struct pinctrl_setting</code> 类型的变量中，从而进一步提取 pinctrl_map 结构体类型变量中的内容。</p><h5 id="pinctrl-state-结构体"><a href="#pinctrl-state-结构体" class="headerlink" title="pinctrl_state 结构体"></a>pinctrl_state 结构体</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinctrl_state - a pinctrl state for a device</span></span><br><span class="line"><span class="comment"> * @node: list node for struct pinctrl&#x27;s @states field</span></span><br><span class="line"><span class="comment"> * @name: the name of this state</span></span><br><span class="line"><span class="comment"> * @settings: a list of settings for this state</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span><span class="comment">// 链表节点，用于将状态对象连接到引脚控制器对象的状态链表</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;<span class="comment">// 状态对象的名称字符串指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">settings</span>;</span><span class="comment">// pinctrl_setting对象链表，包含该状态的所有设置对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="pinctrl-setting-结构体"><a href="#pinctrl-setting-结构体" class="headerlink" title="pinctrl_setting 结构体"></a>pinctrl_setting 结构体</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/core.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinctrl_setting - an individual mux or config setting</span></span><br><span class="line"><span class="comment"> * @node: list node for struct pinctrl_settings&#x27;s @settings field</span></span><br><span class="line"><span class="comment"> * @type: the type of setting</span></span><br><span class="line"><span class="comment"> * @pctldev: pin control device handling to be programmed. Not used for</span></span><br><span class="line"><span class="comment"> *   PIN_MAP_TYPE_DUMMY_STATE.</span></span><br><span class="line"><span class="comment"> * @dev_name: the name of the device using this state</span></span><br><span class="line"><span class="comment"> * @data: Data specific to the setting type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span> <span class="comment">// 链表节点，用于将设置对象连接到状态对象的设置链表</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pinctrl_map_type</span> <span class="title">type</span>;</span> <span class="comment">// 映射类型，表示设置对象的类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span> <span class="comment">// 引脚控制设备对象指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *dev_name; <span class="comment">// 设备名称字符串指针</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_mux</span> <span class="title">mux</span>;</span> <span class="comment">// 复用组映射类型的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_configs</span> <span class="title">configs</span>;</span> <span class="comment">// 配置映射类型的数据结构</span></span><br><span class="line">&#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="create-state"><a href="#create-state" class="headerlink" title="create_state()"></a>create_state()</h5><p><code>add_setting()</code>函数中，根据映射表条目的名称，使用 <code>find_state()</code> 函数在引脚控制器对象中查找对应的状态对象，在此之前我们并没有设置状态对象，所以会进入到第二个 if 判断，通过<code>state = create_state(p, map-&gt;name)</code>创建一个state</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> pinctrl_state *<span class="title function_">create_state</span><span class="params">(<span class="keyword">struct</span> pinctrl *p,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">state</span>;</span></span><br><span class="line"><span class="comment">// 为 pinctrl_state 结构体分配内存</span></span><br><span class="line">state = kzalloc(<span class="keyword">sizeof</span>(*state), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!state)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"><span class="comment">// 设置状态的名称</span></span><br><span class="line">state-&gt;name = name;</span><br><span class="line">    <span class="comment">// 初始化状态的设置列表</span></span><br><span class="line">INIT_LIST_HEAD(&amp;state-&gt;settings);</span><br><span class="line"><span class="comment">// 将状态添加到 pinctrl 的状态链表中</span></span><br><span class="line">list_add_tail(&amp;state-&gt;node, &amp;p-&gt;states);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="pinmux-map-to-setting"><a href="#pinmux-map-to-setting" class="headerlink" title="pinmux_map_to_setting()"></a>pinmux_map_to_setting()</h5><p><code>add_setting()</code>函数中对于复用组映射类型（<strong>PIN_MAP_TYPE_MUX_GROUP</strong>），调用 <code>pinmux_map_to_setting</code> 函数执行引脚复用映射到设置对象的转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/pinmux.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinmux_map_to_setting</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pinctrl_map *<span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> pinctrl_setting *setting)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span> =</span> setting-&gt;pctldev;<span class="comment">// 获取引脚控制设备指针</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">pmxops</span> =</span> pctldev-&gt;desc-&gt;pmxops;<span class="comment">// 获取引脚复用操作指针</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> * <span class="type">const</span> *groups; <span class="comment">// 引脚复用组数组</span></span><br><span class="line"><span class="type">unsigned</span> num_groups; <span class="comment">// 引脚复用组数量</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *group; <span class="comment">// 引脚复用组名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pmxops) &#123;<span class="comment">// 检查引脚控制设备是否支持引脚复用操作</span></span><br><span class="line">dev_err(pctldev-&gt;dev, <span class="string">&quot;does not support mux function\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将映射表中的复用函数名称转换为复用函数的选择器，并将其保存在设置对象的 data.mux.func 字段中</span></span><br><span class="line">ret = pinmux_func_name_to_selector(pctldev, <span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(pctldev-&gt;dev, <span class="string">&quot;invalid function %s in map table\n&quot;</span>,</span><br><span class="line"><span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">setting-&gt;data.mux.func = ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过调用引脚复用操作对象的 get_function_groups 函数查询复用函数对应的复用组信息，</span></span><br><span class="line">    <span class="comment">// 获取复用组的名称数组和数量，并将它们保存在 groups 和 num_groups 变量中。</span></span><br><span class="line">ret = pmxops-&gt;get_function_groups(pctldev, setting-&gt;data.mux.func,</span><br><span class="line">  &amp;groups, &amp;num_groups);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(pctldev-&gt;dev, <span class="string">&quot;can&#x27;t query groups for function %s\n&quot;</span>,</span><br><span class="line"><span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!num_groups) &#123;</span><br><span class="line">dev_err(pctldev-&gt;dev,</span><br><span class="line"><span class="string">&quot;function %s can&#x27;t be selected on any group\n&quot;</span>,</span><br><span class="line"><span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">map</span>-&gt;data.mux.group) &#123;<span class="comment">// 根据映射表中指定的复用组名称或者选择第一个复用组名称，并在复用组数组中查找对应的索引</span></span><br><span class="line">group = <span class="built_in">map</span>-&gt;data.mux.group;</span><br><span class="line">ret = match_string(groups, num_groups, group);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(pctldev-&gt;dev,</span><br><span class="line"><span class="string">&quot;invalid group \&quot;%s\&quot; for function \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">group, <span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">group = groups[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过调用引脚控制设备对象的 pinctrl_get_group_selector </span></span><br><span class="line">    <span class="comment">// 函数获取复用组的选择器，并将它保存在设置对象的 data.mux.group</span></span><br><span class="line">ret = pinctrl_get_group_selector(pctldev, group);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(pctldev-&gt;dev, <span class="string">&quot;invalid group %s in map table\n&quot;</span>,</span><br><span class="line"><span class="built_in">map</span>-&gt;data.mux.group);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">setting-&gt;data.mux.group = ret;<span class="comment">// 设置设置对象的复用组选择器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="pinconf-map-to-setting"><a href="#pinconf-map-to-setting" class="headerlink" title="pinconf_map_to_setting()"></a>pinconf_map_to_setting()</h5><p><code>add_settings</code>函数中对于配置映射类型（<strong>PIN_MAP_TYPE_CONFIGS_PIN</strong> 或 <strong>PIN_MAP_TYPE_CONFIGS_GROUP</strong>），调用 <code>pinconf_map_to_setting</code> 函数执行引脚配置映射到设置对象的转换。</p><p>该函数的作用是将pinctrl_map引脚配置映射转换为pinctrl_setting设置对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/pinconf.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinconf_map_to_setting</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pinctrl_map *<span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> pinctrl_setting *setting)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span> =</span> setting-&gt;pctldev;<span class="comment">// 获取引脚控制设备指针</span></span><br><span class="line"><span class="type">int</span> pin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (setting-&gt;type) &#123;</span><br><span class="line"><span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:<span class="comment">// 针对单个引脚的配置</span></span><br><span class="line">pin = pin_get_from_name(pctldev,</span><br><span class="line"><span class="built_in">map</span>-&gt;data.configs.group_or_pin);<span class="comment">// 通过引脚名称获取引脚号</span></span><br><span class="line"><span class="keyword">if</span> (pin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(pctldev-&gt;dev, <span class="string">&quot;could not map pin config for \&quot;%s\&quot;&quot;</span>,</span><br><span class="line"><span class="built_in">map</span>-&gt;data.configs.group_or_pin);</span><br><span class="line"><span class="keyword">return</span> pin;</span><br><span class="line">&#125;</span><br><span class="line">setting-&gt;data.configs.group_or_pin = pin;<span class="comment">// 设置设置对象的引脚号</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:<span class="comment">// 针对引脚组的配置</span></span><br><span class="line">pin = pinctrl_get_group_selector(pctldev,</span><br><span class="line"> <span class="built_in">map</span>-&gt;data.configs.group_or_pin);<span class="comment">// 获取引脚组的选择器</span></span><br><span class="line"><span class="keyword">if</span> (pin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(pctldev-&gt;dev, <span class="string">&quot;could not map group config for \&quot;%s\&quot;&quot;</span>,</span><br><span class="line"><span class="built_in">map</span>-&gt;data.configs.group_or_pin);</span><br><span class="line"><span class="keyword">return</span> pin;</span><br><span class="line">&#125;</span><br><span class="line">setting-&gt;data.configs.group_or_pin = pin; <span class="comment">// 设置设置对象的引脚组选择器</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setting-&gt;data.configs.num_configs = <span class="built_in">map</span>-&gt;data.configs.num_configs;<span class="comment">// 设置设置对象的配置数量</span></span><br><span class="line">setting-&gt;data.configs.configs = <span class="built_in">map</span>-&gt;data.configs.configs;<span class="comment">// 设置设置对象的配置指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于针对单个引脚的配置，通过调用 <code>pin_get_from_name</code> 函数，根据映射表中的引脚名称获取引脚号，并将其设置到设置对象的 <code>data.configs.group_or_pin</code> 字段中。如果获取引脚号失败，则返回错误。</p><p>对于针对引脚组的配置，它通过调用 <code>pinctrl_get_group_selector</code> 函数，根据映射表中的引脚组名称获取引脚组的选择器，并将其设置到设置对象的 <code>data.configs.group_or_pin</code> 字段中</p><h2 id="pinctrl-lookup-state"><a href="#pinctrl-lookup-state" class="headerlink" title="pinctrl_lookup_state()"></a>pinctrl_lookup_state()</h2><p><code>pinctrl_bind_pins()</code>通过<code>dev-&gt;pins-&gt;default_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,PINCTRL_STATE_DEFAULT);</code> 查找设备的默认 pinctrl 状态，并将其赋值给 <code>dev-&gt;pins-&gt;default_state</code>。如果查找失败，函数会打印一条调试信息，并将返回值设置为 0，表示继续执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pinctrl_lookup_state() - retrieves a state handle from a pinctrl handle</span></span><br><span class="line"><span class="comment"> * @p: the pinctrl handle to retrieve the state from</span></span><br><span class="line"><span class="comment"> * @name: the state name to retrieve</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> pinctrl_state *<span class="title function_">pinctrl_lookup_state</span><span class="params">(<span class="keyword">struct</span> pinctrl *p,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">state</span>;</span></span><br><span class="line"><span class="comment">// 在状态链表中查找指定名称的状态对象</span></span><br><span class="line">state = find_state(p, name);</span><br><span class="line"><span class="keyword">if</span> (!state) &#123;</span><br><span class="line"><span class="keyword">if</span> (pinctrl_dummy_state) &#123;</span><br><span class="line"><span class="comment">/* create dummy state */</span></span><br><span class="line">            <span class="comment">/* 创建虚拟状态 */</span></span><br><span class="line">dev_dbg(p-&gt;dev, <span class="string">&quot;using pinctrl dummy state (%s)\n&quot;</span>,</span><br><span class="line">name);</span><br><span class="line">            <span class="comment">// 如果找不到 指定的状态对象，并且存在虚拟状态，则创建一个虚拟状态对象</span></span><br><span class="line">state = create_state(p, name);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果找不到指定的状态对象，并且不存在虚拟状态，则返回错误指针 -ENODEV</span></span><br><span class="line">state = ERR_PTR(-ENODEV);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pinctrl_lookup_state);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="pinctrl-select-state"><a href="#pinctrl-select-state" class="headerlink" title="pinctrl_select_state()"></a>pinctrl_select_state()</h2><p><code>pinctrl_bind_pins()</code>使用<code>pinctrl_select_state()</code>函数<code>ret = pinctrl_select_state(dev-&gt;pins-&gt;p,dev-&gt;pins-&gt;default_state);</code>选择并切换到指定的 pinctrl_state（引脚控制状态）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pinctrl_select_state() - select/activate/program a pinctrl state to HW</span></span><br><span class="line"><span class="comment"> * @p: the pinctrl handle for the device that requests configuration</span></span><br><span class="line"><span class="comment"> * @state: the state handle to select/activate/program</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinctrl_select_state</span><span class="params">(<span class="keyword">struct</span> pinctrl *p, <span class="keyword">struct</span> pinctrl_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;state == state)<span class="comment">// 如果当前状态已经是要选择的状态，则无需进行任何操作，直接返回 0 表示成功</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 调用 pinctrl_commit_state 函数来应用并切换到新的状态</span></span><br><span class="line"><span class="keyword">return</span> pinctrl_commit_state(p, state);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pinctrl_select_state);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="pinctrl-commit-state"><a href="#pinctrl-commit-state" class="headerlink" title="pinctrl_commit_state()"></a>pinctrl_commit_state()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pinctrl_commit_state() - select/activate/program a pinctrl state to HW</span></span><br><span class="line"><span class="comment"> * @p: the pinctrl handle for the device that requests configuration</span></span><br><span class="line"><span class="comment"> * @state: the state handle to select/activate/program</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pinctrl_commit_state</span><span class="params">(<span class="keyword">struct</span> pinctrl *p, <span class="keyword">struct</span> pinctrl_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting</span> *<span class="title">setting</span>, *<span class="title">setting2</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">old_state</span> =</span> p-&gt;state;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;state) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For each pinmux setting in the old state, forget SW&#x27;s record</span></span><br><span class="line"><span class="comment"> * of mux owner for that pingroup. Any pingroups which are</span></span><br><span class="line"><span class="comment"> * still owned by the new state will be re-acquired by the call</span></span><br><span class="line"><span class="comment"> * to pinmux_enable_setting() in the loop below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 对于旧状态中的每个引脚复用设置，取消 SW 记录的该引脚组的复用所有者。</span></span><br><span class="line"><span class="comment">* 任何仍由新状态拥有的引脚组将在下面循环中的 pinmux_enable_setting() 调用中重新获取。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">list_for_each_entry(setting, &amp;p-&gt;state-&gt;settings, node) &#123;</span><br><span class="line"><span class="keyword">if</span> (setting-&gt;type != PIN_MAP_TYPE_MUX_GROUP)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">pinmux_disable_setting(setting);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p-&gt;state = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Apply all the settings for the new state */</span></span><br><span class="line">    <span class="comment">/* 应用新状态的所有设置 */</span></span><br><span class="line">list_for_each_entry(setting, &amp;state-&gt;settings, node) &#123;</span><br><span class="line"><span class="keyword">switch</span> (setting-&gt;type) &#123;</span><br><span class="line"><span class="keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:</span><br><span class="line">            <span class="comment">// 对于引脚复用设置（PIN_MAP_TYPE_MUX_GROUP），调用 pinmux_enable_setting()函数来启用该设置。</span></span><br><span class="line">ret = pinmux_enable_setting(setting);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line"><span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:</span><br><span class="line">            <span class="comment">// 对于引脚配置设置（PIN_MAP_TYPE_CONFIGS_PIN 或 PIN_MAP_TYPE_CONFIGS_GROUP），调用 pinconf_apply_setting()函数来应用该设置</span></span><br><span class="line">ret = pinconf_apply_setting(setting);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果应用设置失败，则回滚新状态的设置</span></span><br><span class="line"><span class="keyword">goto</span> unapply_new_state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do not link hogs (circular dependency) */</span></span><br><span class="line"><span class="keyword">if</span> (p != setting-&gt;pctldev-&gt;p)</span><br><span class="line">pinctrl_link_add(setting-&gt;pctldev, p-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p-&gt;state = state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">unapply_new_state:</span><br><span class="line">    <span class="comment">// 回滚新状态的设置</span></span><br><span class="line">dev_err(p-&gt;dev, <span class="string">&quot;Error applying setting, reverse things back\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">list_for_each_entry(setting2, &amp;state-&gt;settings, node) &#123;</span><br><span class="line"><span class="keyword">if</span> (&amp;setting2-&gt;node == &amp;setting-&gt;node)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * All we can do here is pinmux_disable_setting.</span></span><br><span class="line"><span class="comment"> * That means that some pins are muxed differently now</span></span><br><span class="line"><span class="comment"> * than they were before applying the setting (We can&#x27;t</span></span><br><span class="line"><span class="comment"> * &quot;unmux a pin&quot;!), but it&#x27;s not a big deal since the pins</span></span><br><span class="line"><span class="comment"> * are free to be muxed by another apply_setting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (setting2-&gt;type == PIN_MAP_TYPE_MUX_GROUP)</span><br><span class="line">pinmux_disable_setting(setting2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There&#x27;s no infinite recursive loop here because p-&gt;state is NULL */</span></span><br><span class="line"><span class="keyword">if</span> (old_state)</span><br><span class="line">pinctrl_select_state(p, old_state);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>pinctrl_commit_state()</code>函数遍历新状态的所有设置，并根据设置的类型执行相应的操作：</p><ul><li><p>对于引脚复用设置（PIN_MAP_TYPE_MUX_GROUP），调用 <code>pinmux_enable_setting()</code>函数来启用该设置。</p></li><li><p>对于引脚配置设置（PIN_MAP_TYPE_CONFIGS_PIN 或 PIN_MAP_TYPE_CONFIGS_GROUP），调用 <code>pinconf_apply_setting()</code>函数来应用该设置。</p></li><li>对于其他类型的设置，将返回一个错误码（-EINVAL）。</li></ul><h3 id="pinmux-enable-setting"><a href="#pinmux-enable-setting" class="headerlink" title="pinmux_enable_setting()"></a>pinmux_enable_setting()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//drivers/pinctrl/pinmux.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinmux_enable_setting</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pinctrl_setting *setting)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span> =</span> setting-&gt;pctldev;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">pctlops</span> =</span> pctldev-&gt;desc-&gt;pctlops;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">ops</span> =</span> pctldev-&gt;desc-&gt;pmxops;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> *pins = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> num_pins = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pin_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line"><span class="comment">// 如果 pctlops-&gt;get_group_pins 函数存在，则调用该函数获取组中的引脚信息，并将引脚信息存储在 pins 和 num_pins 变量中</span></span><br><span class="line"><span class="keyword">if</span> (pctlops-&gt;get_group_pins)</span><br><span class="line">ret = pctlops-&gt;get_group_pins(pctldev, setting-&gt;data.mux.group,</span><br><span class="line">      &amp;pins, &amp;num_pins);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret) &#123;<span class="comment">// 如果获取引脚信息失败，发出警告并将 num_pins 设置为 0</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *gname;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* errors only affect debug data, so just warn */</span></span><br><span class="line">        <span class="comment">// 错误只影响调试数据，因此只发出警告</span></span><br><span class="line">gname = pctlops-&gt;get_group_name(pctldev,</span><br><span class="line">setting-&gt;data.mux.group);</span><br><span class="line">dev_warn(pctldev-&gt;dev,</span><br><span class="line"> <span class="string">&quot;could not get pins for group %s\n&quot;</span>,</span><br><span class="line"> gname);</span><br><span class="line">num_pins = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try to allocate all pins in this group, one by one */</span></span><br><span class="line">    <span class="comment">// 逐个申请组中的引脚</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_pins; i++) &#123;</span><br><span class="line">        <span class="comment">// 使用 pin_request 函数申请引脚，并传入引脚控制器设备、引脚编号、设备名称和其他参数</span></span><br><span class="line">ret = pin_request(pctldev, pins[i], setting-&gt;dev_name, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *gname;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pname;</span><br><span class="line"><span class="comment">// 分配引脚后，使用 pin_desc_get 函数获取引脚描述符，并将复用设置指针指向引脚复用信息。</span></span><br><span class="line">desc = pin_desc_get(pctldev, pins[i]);</span><br><span class="line">pname = desc ? desc-&gt;name : <span class="string">&quot;non-existing&quot;</span>;</span><br><span class="line">gname = pctlops-&gt;get_group_name(pctldev,</span><br><span class="line">setting-&gt;data.mux.group);</span><br><span class="line">dev_err(pctldev-&gt;dev,</span><br><span class="line"><span class="string">&quot;could not request pin %d (%s) from group %s &quot;</span></span><br><span class="line"><span class="string">&quot; on device %s\n&quot;</span>,</span><br><span class="line">pins[i], pname, gname,</span><br><span class="line">pinctrl_dev_get_name(pctldev));</span><br><span class="line"><span class="keyword">goto</span> err_pin_request;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now that we have acquired the pins, encode the mux setting */</span></span><br><span class="line">    <span class="comment">// 分配引脚后，编码复用设置</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_pins; i++) &#123;</span><br><span class="line">desc = pin_desc_get(pctldev, pins[i]);</span><br><span class="line"><span class="keyword">if</span> (desc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">dev_warn(pctldev-&gt;dev,</span><br><span class="line"> <span class="string">&quot;could not get pin desc for pin %d\n&quot;</span>,</span><br><span class="line"> pins[i]);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">desc-&gt;mux_setting = &amp;(setting-&gt;data.mux);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 ops-&gt;set_mux 函数设置引脚复用，传入引脚控制器设备、复用功能和组信息，以便设置引脚复用。</span></span><br><span class="line">ret = ops-&gt;set_mux(pctldev, setting-&gt;data.mux.func,</span><br><span class="line">   setting-&gt;data.mux.group);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err_set_mux;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_set_mux:</span><br><span class="line">    <span class="comment">// 复用设置失败，清除复用设置</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_pins; i++) &#123;</span><br><span class="line">desc = pin_desc_get(pctldev, pins[i]);</span><br><span class="line"><span class="keyword">if</span> (desc)</span><br><span class="line">desc-&gt;mux_setting = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">err_pin_request:</span><br><span class="line"><span class="comment">/* On error release all taken pins */</span></span><br><span class="line">    <span class="comment">// 在错误发生时释放已申请的引脚</span></span><br><span class="line"><span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">pin_free(pctldev, pins[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="pinconf-apply-setting"><a href="#pinconf-apply-setting" class="headerlink" title="pinconf_apply_setting()"></a>pinconf_apply_setting()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/pinconf.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinconf_apply_setting</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pinctrl_setting *setting)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span> =</span> setting-&gt;pctldev;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> *<span class="title">ops</span> =</span> pctldev-&gt;desc-&gt;confops;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ops) &#123;<span class="comment">// 检查是否存在 pinconf 操作函数集</span></span><br><span class="line">dev_err(pctldev-&gt;dev, <span class="string">&quot;missing confops\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据设置类型选择相应的操作</span></span><br><span class="line"><span class="keyword">switch</span> (setting-&gt;type) &#123;</span><br><span class="line"><span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:<span class="comment">//表示对单个引脚进行配置设置</span></span><br><span class="line"><span class="keyword">if</span> (!ops-&gt;pin_config_set) &#123;<span class="comment">// 检查是否存在 pin_config_set 操作函数</span></span><br><span class="line">dev_err(pctldev-&gt;dev, <span class="string">&quot;missing pin_config_set op\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 调用 pin_config_set 函数设置单个引脚的配置</span></span><br><span class="line">ret = ops-&gt;pin_config_set(pctldev,</span><br><span class="line">setting-&gt;data.configs.group_or_pin,</span><br><span class="line">setting-&gt;data.configs.configs,</span><br><span class="line">setting-&gt;data.configs.num_configs);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(pctldev-&gt;dev,</span><br><span class="line"><span class="string">&quot;pin_config_set op failed for pin %d\n&quot;</span>,</span><br><span class="line">setting-&gt;data.configs.group_or_pin);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:<span class="comment">// 表示对引脚组进行配置设置</span></span><br><span class="line"><span class="keyword">if</span> (!ops-&gt;pin_config_group_set) &#123;<span class="comment">// 检查是否存在 pin_config_group_set 操作函数</span></span><br><span class="line">dev_err(pctldev-&gt;dev,</span><br><span class="line"><span class="string">&quot;missing pin_config_group_set op\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 调用 pin_config_group_set 函数设置引脚组的配置</span></span><br><span class="line">ret = ops-&gt;pin_config_group_set(pctldev,</span><br><span class="line">setting-&gt;data.configs.group_or_pin,</span><br><span class="line">setting-&gt;data.configs.configs,</span><br><span class="line">setting-&gt;data.configs.num_configs);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(pctldev-&gt;dev,</span><br><span class="line"><span class="string">&quot;pin_config_group_set op failed for group %d\n&quot;</span>,</span><br><span class="line">setting-&gt;data.configs.group_or_pin);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251216154951470.jpg" alt="pinctrl"></p><h1 id="引脚复用是在什么时候设置的"><a href="#引脚复用是在什么时候设置的" class="headerlink" title="引脚复用是在什么时候设置的"></a>引脚复用是在什么时候设置的</h1><ul><li>猜想 1 </li></ul><p>第一个猜想是在加载 LED 驱动的时候进行的 pinctrl 引脚复用。当 LED 灯的设备树和驱动匹配之后，就会进入驱动中编写的 probe<br>函 数 ， 在 此 之 前 会 执 行 <code>drivers/base/dd.c</code> 文 件 中 的<code>really_probe</code> 函 数 中 的 子 函 数<code>pinctrl_bind_pins</code>，该函数会为给定的设备绑定引脚，并在绑定过程中选择和设置适当的 pinctrl状态。具体的绑定细节可以去前面的章节中查找。</p><ul><li>猜想 2 </li></ul><p>第二种猜想是在加载 pinctrl 驱动的时候完成的引脚复用，因为 pinctrl 子系统也是符合设备模型的规范 ，也会 执 行 相 应的 probe 函数，所以同样的加在 pinctrl 驱动时也会执行<code>drivers/base/dd.c</code>文件中的 <code>really_probe</code> 函数中的子函数 <code>pinctrl_bind_pins</code>，那这时会进行pinctrl 管脚的复用设置吗，接下来我们对此进行深入的分析。</p><p>在 pinctrl 的 probe 函数执行之前，会调用 <code>pinctrl_bind_pins</code> 函数，根据前面的内容可知，根据函数的嵌套，首先会调用的 <code>create_pinctrl</code> 函数创建 <code>struct pinctrl</code> 类型的引脚控制器，然后在<code>create_pinctrl</code>调用 <code>pinctrl_dt_to_map</code> 函数将设备树中定义的引脚映射信息转换为 <code>struct pinctrl_map</code> 结构，并将其添加到 <code>p-&gt;dt_maps</code> 链表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/devicetree.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinctrl_dt_to_map</span><span class="params">(<span class="keyword">struct</span> pinctrl *p, <span class="keyword">struct</span> pinctrl_dev *pctldev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> p-&gt;dev-&gt;of_node;<span class="comment">// 获取引脚控制器关联设备的设备树节点</span></span><br><span class="line"><span class="type">int</span> state, ret;</span><br><span class="line"><span class="type">char</span> *propname;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">prop</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *statename;</span><br><span class="line"><span class="type">const</span> __be32 *<span class="built_in">list</span>;</span><br><span class="line"><span class="type">int</span> size, config;</span><br><span class="line">phandle phandle;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np_config</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CONFIG_OF enabled, p-&gt;dev not instantiated from DT */</span></span><br><span class="line">    <span class="comment">/* 如果 CONFIG_OF 启用，且 p-&gt;dev 不是从设备树实例化而来 */</span></span><br><span class="line"><span class="keyword">if</span> (!np) &#123;</span><br><span class="line"><span class="keyword">if</span> (of_have_populated_dt())</span><br><span class="line">dev_dbg(p-&gt;dev,</span><br><span class="line"><span class="string">&quot;no of_node; not parsing pinctrl DT\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We may store pointers to property names within the node */</span></span><br><span class="line">    <span class="comment">/* 节点内部存储属性名称的指针 */</span></span><br><span class="line">of_node_get(np);<span class="comment">//增加设备树节点的引用计数，以确保在解析过程中节点不会被释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* For each defined state ID */</span></span><br><span class="line">    <span class="comment">/* 对于每个定义的状态 ID */</span></span><br><span class="line"><span class="keyword">for</span> (state = <span class="number">0</span>; ; state++) &#123;</span><br><span class="line"><span class="comment">/* Retrieve the pinctrl-* property */</span></span><br><span class="line">        <span class="comment">/* 获取 pinctrl-* 属性 */</span></span><br><span class="line">propname = kasprintf(GFP_KERNEL, <span class="string">&quot;pinctrl-%d&quot;</span>, state);</span><br><span class="line"><span class="keyword">if</span> (!propname)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">prop = of_find_property(np, propname, &amp;size);</span><br><span class="line">kfree(propname);</span><br><span class="line"><span class="keyword">if</span> (!prop) &#123;</span><br><span class="line"><span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">of_node_put(np);</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">list</span> = prop-&gt;value;</span><br><span class="line">size /= <span class="keyword">sizeof</span>(*<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Determine whether pinctrl-names property names the state */</span></span><br><span class="line">        <span class="comment">/* 判断 pinctrl-names 属性是否命名了该状态 */</span></span><br><span class="line">ret = of_property_read_string_index(np, <span class="string">&quot;pinctrl-names&quot;</span>,</span><br><span class="line">    state, &amp;statename);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If not, statename is just the integer state ID. But rather</span></span><br><span class="line"><span class="comment"> * than dynamically allocate it and have to free it later,</span></span><br><span class="line"><span class="comment"> * just point part way into the property name for the string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果未命名，则 statename 仅是整数状态 ID。但是，为了避免动态分配和之后要释放的麻烦，</span></span><br><span class="line"><span class="comment">* 可以直接将 statename 指向属性名称的一部分。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">statename = prop-&gt;name + <span class="built_in">strlen</span>(<span class="string">&quot;pinctrl-&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* For every referenced pin configuration node in it */</span></span><br><span class="line">        <span class="comment">/* 对于其中的每个引用的引脚配置节点 */</span></span><br><span class="line"><span class="keyword">for</span> (config = <span class="number">0</span>; config &lt; size; config++) &#123;</span><br><span class="line">phandle = be32_to_cpup(<span class="built_in">list</span>++);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Look up the pin configuration node */</span></span><br><span class="line">            <span class="comment">/* 查找引脚配置节点 */</span></span><br><span class="line">np_config = of_find_node_by_phandle(phandle);</span><br><span class="line"><span class="keyword">if</span> (!np_config) &#123;</span><br><span class="line">dev_err(p-&gt;dev,</span><br><span class="line"><span class="string">&quot;prop %s index %i invalid phandle\n&quot;</span>,</span><br><span class="line">prop-&gt;name, config);</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Parse the node */</span></span><br><span class="line">            <span class="comment">/* 解析节点 */</span></span><br><span class="line">ret = dt_to_map_one_config(p, pctldev, statename,</span><br><span class="line">   np_config);</span><br><span class="line">of_node_put(np_config);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* No entries in DT? Generate a dummy state table entry */</span></span><br><span class="line">        <span class="comment">/* 如果在设备树中没有条目，则生成一个虚拟状态表条目 */</span></span><br><span class="line"><span class="keyword">if</span> (!size) &#123;</span><br><span class="line">ret = dt_remember_dummy_state(p, statename);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">pinctrl_dt_free_maps(p);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关键点在于：这里传递过来的是 pinctrl 的设备树节点，在 32 行在 for 循环中会获取 <code>pinctrl-*</code> 属性，而<strong>在 pinctrl 节点中并没有该属性，<code>pinctrl-*</code> 属性是在一系列的设备节点中添加的</strong>，所以会在这里返回错误，同样的错误会一层层的向上级函数传递，最终导致 <code>pinctrl_bind_pins()</code> 函数返回错误，从而不能设置引脚的复用，即：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_bind_pins</span><br><span class="line">create_pinctr</span><br><span class="line"><span class="function"><span class="title">pinctrl_dt_to_map</span> -&gt;</span> 报错</span><br></pre></td></tr></table></figure><p>所以猜想 2 是不正确的。</p><p>而瑞芯微的pinctrl驱动中的probe有这样一个调用关系：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rockchip pinctrl<span class="emphasis">_probe</span></span><br><span class="line"><span class="emphasis">rockchip_pinctrl_registér</span></span><br><span class="line"><span class="emphasis">devm_pinctrl_register</span></span><br><span class="line"><span class="emphasis">pinctrl_register</span></span><br><span class="line"><span class="emphasis">pinctrl_enable</span></span><br><span class="line"><span class="emphasis">pinctrl_claim_hogs</span></span><br><span class="line"><span class="emphasis">create_</span>pinctr</span><br></pre></td></tr></table></figure><p>从上面的调用关系可以得到 pinctrl 的 probe 函数最后也会调用 <code>create_pinctrl</code> 来创建 <code>struct pinctrl</code> 类型的引脚控制器，从而实现 pinctrl 引脚复用设置，同样的这是的设置也是不成功的，<code>pinctrl_claim_hogs</code> 函数定义在内核源码目录下的<code>drivers/pinctrl/core.c</code>文件中</p>]]></content>
    
    
    <summary type="html">基于Linux 5.10, 瑞芯微 rk3568 pinctrl 驱动分析</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
    <category term="driver" scheme="https://even629.com/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>面试经典150题 P97 交错字符串</title>
    <link href="https://even629.com/posts/97/"/>
    <id>https://even629.com/posts/97/</id>
    <published>2025-12-16T05:48:13.000Z</published>
    <updated>2025-12-16T05:48:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-16</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：</p><div class="tag link"><a class="link-card" title="P97 交错字符串" href="https://leetcode.cn/problems/interleaving-string/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P97 交错字符串</p><p class="url">https://leetcode.cn/problems/interleaving-string/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div><p>设$ \texttt{dp[i][j]}\ $表示 $ \texttt{s1[0..=i-1]}$（其中 $1 \leq i \leq \texttt{s1.length()}$）和 $\texttt{s2[0..=j-1]}$（其中 $1 \leq j \leq \texttt{s2.length()}$）能交错组成 $\texttt{s3[0..=i+j-1]}$。$dp[0][0]$ 表示 $\texttt{s1}$、$\texttt{s2}$ 和 $\texttt{s3}$ 均取空字符串。</p><script type="math/tex; mode=display">\texttt{ dp[0][0] = true}    \\</script><ul><li>只考虑s1, 即<code>s1[0..=i-1]</code>能否交错组成<code>s3[0..i-1]</code>，显然</li></ul><script type="math/tex; mode=display">\texttt{dp[i][0] = dp[i-1][0]  \&\& (s3[i - 1] == s1[i- 1]);} \\</script><ul><li>同理，只考虑s2有：</li></ul><script type="math/tex; mode=display">\texttt{dp[0][j] = dp[0][j-1]  \&\& (s3[j - 1] == s2[j- 1]);} \\</script><ul><li>同时考虑s1和s2有：</li></ul><script type="math/tex; mode=display">\texttt{from\_s1 = dp[i-1][j] \&\& (s1[i-1] == s3[i+j-1]);} \\</script><script type="math/tex; mode=display">\texttt{from\_s2 = dp[i][j-1] \&\& (s2[j-1] == s3[i+j-1]);} \\</script><script type="math/tex; mode=display">\texttt{dp[i][j] = from\_s1 || from\_s2;} \\</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="type">int</span> n1 = s<span class="number">1.l</span>ength(), n2 = s<span class="number">2.l</span>ength(), n3 = s<span class="number">3.l</span>ength();</span><br><span class="line">                <span class="type">int</span> i, j;</span><br><span class="line">                <span class="type">bool</span> from_s1, from_s2;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (n1 + n2 != n3) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt; <span class="built_in">dp</span>(n1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n2 + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">                <span class="comment">// dp[i][j] 表示 s1[0..=i-1] 和s2[0..=j-1]可以交错组成s3[0..=i+j-1]</span></span><br><span class="line">                <span class="comment">// dp[0][0] 表示空字符串</span></span><br><span class="line"></span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">                        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] &amp;&amp; (s3[i - <span class="number">1</span>] == s1[i - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] &amp;&amp; (s3[j - <span class="number">1</span>] == s2[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                                from_s1 = dp[i - <span class="number">1</span>][j] &amp;&amp; (s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]);</span><br><span class="line">                                from_s2 = dp[i][j - <span class="number">1</span>] &amp;&amp; (s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]);</span><br><span class="line">                                dp[i][j] = from_s1 || from_s2;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
    
    
    <summary type="html">动态规划</summary>
    
    
    
    <category term="algorithm" scheme="https://even629.com/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://even629.com/tags/algorithm/"/>
    
    <category term="动态规划" scheme="https://even629.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="leetcode面试经典150题" scheme="https://even629.com/tags/leetcode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试经典150题 P72 编辑距离</title>
    <link href="https://even629.com/posts/72/"/>
    <id>https://even629.com/posts/72/</id>
    <published>2025-12-16T02:38:13.000Z</published>
    <updated>2025-12-16T02:38:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-16</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：</p><div class="tag link"><a class="link-card" title="P72 编辑距离" href="https://leetcode.cn/problems/edit-distance/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P72 编辑距离</p><p class="url">https://leetcode.cn/problems/edit-distance/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div><p>这题和最长公共子序列类似：</p><p>设 $dp[i][j]$ 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最小操作数。</p><ul><li>初始化：<ul><li><code>word1[0..=i]</code>变为空字符需要i次操作，因此 $dp[i][0] = i$</li><li>空字符串变为word2[0..=j]需要j次操作，因此$dp[0][j] = j$</li></ul></li><li>对于<code>dp[i][j]</code>, $i,j \ge 1$，有：<ul><li>如果<code>word[i-1]==word[j-1]</code>，那么不需要操作，$dp[i][j]=dp[i-1]dp[j-1]$</li><li>否则 $dp[i][j] = min( dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1] ) + 1$<ul><li>$dp[i-1][j]+1$ , 表示删除 <code>word1[i-1]</code></li><li>$dp[i][j-1]+1$ , 表示插入 <code>word2[j-1]</code></li><li>$dp[i-1][j-1]+1$ , 表示替换<code>word1[i-1]</code> 为 <code>word2[j-1]</code></li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="comment">// 设 dp[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最小操作数。</span></span><br><span class="line">                <span class="type">int</span> i, j;</span><br><span class="line">                <span class="type">int</span> m = word<span class="number">1.l</span>ength(), n = word<span class="number">2.l</span>ength();</span><br><span class="line">                vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                        <span class="comment">// word1[0..=i]变为空字符需要i次操作</span></span><br><span class="line">                        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                        <span class="comment">// 空字符串变为word2[0..=j]需要j次操作</span></span><br><span class="line">                        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                                        <span class="comment">// 不需要额外操作</span></span><br><span class="line">                                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">// dp[i-1][j]（删除 word1[i-1]）</span></span><br><span class="line">                                        <span class="comment">// dp[i][j-1]（插入 word2[j-1]）</span></span><br><span class="line">                                        <span class="comment">// dp[i-1][j-1]（替换 word1[i-1] 为 word2[j-1]）</span></span><br><span class="line">                                        </span><br><span class="line">                                        dp[i][j] = std::<span class="built_in">min</span>(&#123; dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j],</span><br><span class="line">                                                              dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &#125;) +</span><br><span class="line">                                                   <span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> dp[m][n];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
    
    
    <summary type="html">动态规划</summary>
    
    
    
    <category term="algorithm" scheme="https://even629.com/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://even629.com/tags/algorithm/"/>
    
    <category term="动态规划" scheme="https://even629.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="leetcode面试经典150题" scheme="https://even629.com/tags/leetcode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试经典150题 P221 最大正方形</title>
    <link href="https://even629.com/posts/221/"/>
    <id>https://even629.com/posts/221/</id>
    <published>2025-12-15T04:30:13.000Z</published>
    <updated>2025-12-15T04:30:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-15</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P221 最大正方形" href="https://leetcode.cn/problems/maximal-square/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P221 最大正方形</p><p class="url">https://leetcode.cn/problems/maximal-square/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>dp[i][j]暴力更新状态<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt; &amp;matrix)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="type">int</span> i, j, k, m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">                <span class="comment">// dp[i][j]表示以matrix[i][j]为右下角的全1正方形大小</span></span><br><span class="line">                vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">                <span class="type">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                                        max_len = <span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> only1;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (dp[i][j] == <span class="number">1</span> &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                                        <span class="comment">// dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</span></span><br><span class="line">                                        only1 = <span class="literal">true</span>;</span><br><span class="line">                                        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= dp[i - <span class="number">1</span>][j - <span class="number">1</span>]; k++) &#123; <span class="comment">//boundary</span></span><br><span class="line">                                                <span class="keyword">if</span> (dp[i][j - k] == <span class="number">0</span>) &#123;</span><br><span class="line">                                                        only1 = <span class="literal">false</span>;</span><br><span class="line">                                                        <span class="keyword">break</span>;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                                <span class="keyword">if</span> (dp[i - k][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                                                        only1 = <span class="literal">false</span>;</span><br><span class="line">                                                        <span class="keyword">break</span>;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="comment">// k-1</span></span><br><span class="line">                                        <span class="keyword">if</span> (only1) &#123;</span><br><span class="line">                                                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                dp[i][j] = (k - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        max_len = std::<span class="built_in">max</span>(dp[i][j], max_len);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> max_len * max_len;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>实际dp更新方程:<br>when dp[i][j] == 1:</p><script type="math/tex; mode=display">dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt; &amp;matrix)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="type">int</span> i, j, m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">                <span class="comment">// dp[i][j]表示以matrix[i][j]为右下角的全1正方形大小</span></span><br><span class="line">                vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">                <span class="type">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                                        max_len = <span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">bool</span> only1;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (dp[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                                        dp[i][j] = std::<span class="built_in">min</span>(&#123; dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &#125;) + <span class="number">1</span>;</span><br><span class="line">                                        max_len = std::<span class="built_in">max</span>(dp[i][j], max_len);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> max_len * max_len;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
    
    
    <summary type="html">动态规划</summary>
    
    
    
    <category term="algorithm" scheme="https://even629.com/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://even629.com/tags/algorithm/"/>
    
    <category term="动态规划" scheme="https://even629.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="leetcode面试经典150题" scheme="https://even629.com/tags/leetcode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试经典150题 P5 最长回文子串</title>
    <link href="https://even629.com/posts/5/"/>
    <id>https://even629.com/posts/5/</id>
    <published>2025-12-15T02:48:13.000Z</published>
    <updated>2025-12-15T02:48:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-15</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P5 最长回文子串" href="https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P5 最长回文子串</p><p class="url">https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>记dp[i][j]为s[i..j]的回文子串长度，如果s[i..j]不是回文子串，那dp[i][j]=0, 否则, dp[i][j] = j-i+1;<br>因此，子长度len = j-i+1 是否为回文子串依赖len-1的回文子串，所以在循环时要按len长度递增循环。<br>初始化时:<br>len == 1 时， dp[i][i] = 1;<br>len == 2 时，dp[i][i+1] = 2 (if s[i] == s[i+1]);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="type">int</span> i, j, len, end_idx, n = s.<span class="built_in">size</span>();</span><br><span class="line">                <span class="type">int</span> max_len = <span class="number">1</span>, reti = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// dp[i][j] 为0表示s[i..j]不是回文串,大于0表示j-i+1</span></span><br><span class="line">                vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// len == 1</span></span><br><span class="line">                        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                len = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i + len - <span class="number">1</span> &lt; n; i++) &#123; <span class="comment">// len == 2</span></span><br><span class="line">                        <span class="keyword">if</span> (s[i] == s[i + len - <span class="number">1</span>]) &#123;</span><br><span class="line">                                dp[i][i + len - <span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                                <span class="keyword">if</span> (dp[i][i + len - <span class="number">1</span>] &gt; max_len) &#123;</span><br><span class="line">                                        max_len = dp[i][i + len - <span class="number">1</span>];</span><br><span class="line">                                        reti = i;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (len = <span class="number">3</span>; len &lt;= n; len++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (i = <span class="number">0</span>; i + len - <span class="number">1</span> &lt; n; i++) &#123; <span class="comment">// s[i..i+len-1]</span></span><br><span class="line">                                end_idx = i + len - <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">if</span> (s[i] == s[end_idx] &amp;&amp; dp[i + <span class="number">1</span>][end_idx - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                                        dp[i][end_idx] = dp[i + <span class="number">1</span>][end_idx - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                                        <span class="keyword">if</span> (dp[i][end_idx] &gt; max_len) &#123;</span><br><span class="line">                                                max_len = dp[i][end_idx];</span><br><span class="line">                                                reti = i;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> s.<span class="built_in">substr</span>(reti, max_len);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
    
    
    <summary type="html">动态规划</summary>
    
    
    
    <category term="algorithm" scheme="https://even629.com/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://even629.com/tags/algorithm/"/>
    
    <category term="动态规划" scheme="https://even629.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="leetcode面试经典150题" scheme="https://even629.com/tags/leetcode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试经典150题 P63 不同路径 II</title>
    <link href="https://even629.com/posts/63/"/>
    <id>https://even629.com/posts/63/</id>
    <published>2025-12-13T12:18:13.000Z</published>
    <updated>2025-12-13T12:18:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-13</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P63 不同路径 II" href="https://leetcode.cn/problems/unique-paths-ii/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P63 不同路径 II</p><p class="url">https://leetcode.cn/problems/unique-paths-ii/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>注意要考虑 m==n==1 时的特殊情况。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;obstacleGrid)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="type">int</span> i, j, m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">if</span> (m == <span class="number">1</span> &amp;&amp; n == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// dp[i][j]表示到达grid[i][j]的不同路径的数量</span></span><br><span class="line">                vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (obstacleGrid[i - <span class="number">1</span>][<span class="number">0</span>] != <span class="number">1</span> &amp;&amp;</span><br><span class="line">                            obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span>) &#123;</span><br><span class="line">                                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j - <span class="number">1</span>] != <span class="number">1</span> &amp;&amp;</span><br><span class="line">                            obstacleGrid[<span class="number">0</span>][j] != <span class="number">1</span>) &#123;</span><br><span class="line">                                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (obstacleGrid[i - <span class="number">1</span>][j] == <span class="number">1</span> &amp;&amp;</span><br><span class="line">                                    obstacleGrid[i][j - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                                        <span class="keyword">continue</span>; <span class="comment">// set default as 0</span></span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obstacleGrid[i - <span class="number">1</span>][j] == <span class="number">1</span> &amp;&amp;</span><br><span class="line">                                           obstacleGrid[i][j - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                                        dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obstacleGrid[i - <span class="number">1</span>][j] == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                           obstacleGrid[i][j - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                                        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><!-- flag of hidden posts -->]]></content>
    
    
    <summary type="html">动态规划</summary>
    
    
    
    <category term="algorithm" scheme="https://even629.com/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://even629.com/tags/algorithm/"/>
    
    <category term="动态规划" scheme="https://even629.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="leetcode面试经典150题" scheme="https://even629.com/tags/leetcode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试经典150题 P64 最小路径和</title>
    <link href="https://even629.com/posts/64/"/>
    <id>https://even629.com/posts/64/</id>
    <published>2025-12-13T06:26:13.000Z</published>
    <updated>2025-12-13T06:26:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-13</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P64 最小路径和" href="https://leetcode.cn/problems/minimum-path-sum/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P64 最小路径和</p><p class="url">https://leetcode.cn/problems/minimum-path-sum/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div><br>由于只能向右或向下，那某一点的上一步只能是左或上，设置dp[i][j]表示到达grid[i][j]的最小路径长度。<br>有：</p><script type="math/tex; mode=display">dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;grid)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="comment">// dp[i][j]表示到达grid[i][j]的最小路径长度</span></span><br><span class="line">                <span class="type">int</span> i, j, m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">                vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">                dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">                        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                                dp[i][j] = std::<span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
    
    
    <summary type="html">动态规划</summary>
    
    
    
    <category term="algorithm" scheme="https://even629.com/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://even629.com/tags/algorithm/"/>
    
    <category term="动态规划" scheme="https://even629.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="leetcode面试经典150题" scheme="https://even629.com/tags/leetcode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试经典150题 P139 单词拆分</title>
    <link href="https://even629.com/posts/139/"/>
    <id>https://even629.com/posts/139/</id>
    <published>2025-12-13T02:56:13.000Z</published>
    <updated>2025-12-13T02:56:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-13</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P139 单词拆分" href="https://leetcode.cn/problems/word-break/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P139 单词拆分</p><p class="url">https://leetcode.cn/problems/word-break/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>dp[i] 表示 s[0..i-1] 这个前缀是否可以被成功拆分成字典里的单词。dp[0] = true，即空字符串可被拆分。<br>dp[i]等于true的条件是，dp<a href="0 &lt;= j &lt; i">j</a>为true，且s.substr(j, i-j)是wordDict中的一个单词。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::unordered_set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt; &amp;wordDict)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="type">int</span> i, j, n = s.<span class="built_in">size</span>();</span><br><span class="line">                <span class="function">unordered_set&lt;string&gt; <span class="title">dict</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">                <span class="comment">// dp[i] 表示 s[0..i-1] 这个前缀是否可以被成功拆分</span></span><br><span class="line">                <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">                dp[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 空字符串可以被拆分</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) &#123; <span class="comment">// s[0..i-1]</span></span><br><span class="line">                                <span class="comment">//</span></span><br><span class="line">                                <span class="keyword">if</span> (dp[j] &amp;&amp; dict.<span class="built_in">count</span>(s.<span class="built_in">substr</span>(j, i - j))) &#123;</span><br><span class="line">                                        dp[i] = <span class="literal">true</span>;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> dp[n];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
    
    
    <summary type="html">动态规划</summary>
    
    
    
    <category term="algorithm" scheme="https://even629.com/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://even629.com/tags/algorithm/"/>
    
    <category term="动态规划" scheme="https://even629.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="leetcode面试经典150题" scheme="https://even629.com/tags/leetcode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试经典150题 P300 最长递增子序列</title>
    <link href="https://even629.com/posts/300/"/>
    <id>https://even629.com/posts/300/</id>
    <published>2025-12-12T03:13:13.000Z</published>
    <updated>2025-12-12T03:13:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-12</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P300 最长递增子序列" href="https://leetcode.cn/problems/longest-increasing-subsequence/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P300 最长递增子序列</p><p class="url">https://leetcode.cn/problems/longest-increasing-subsequence/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><script type="math/tex; mode=display">dp[i] = max(dp[j])_{( 0 \le j < i , nums[j] < nums[i])} + 1;</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="comment">// dp[i] 以nums[i]结尾的最长严格递增子序列的长度</span></span><br><span class="line">                <span class="comment">// dp[i] = max&#123;dp[j]&#125;(nums[j]&lt;nums[i] &amp;&amp; j&lt;i) + 1;</span></span><br><span class="line">                <span class="type">int</span> i, j, n = nums.<span class="built_in">size</span>();</span><br><span class="line">                <span class="type">int</span> max_val = INT_MIN;</span><br><span class="line">                <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                        max_val = INT_MIN;</span><br><span class="line">                        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                                        max_val = std::<span class="built_in">max</span>(max_val, dp[j]);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (max_val != INT_MIN) &#123;</span><br><span class="line">                                dp[i] = max_val + <span class="number">1</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                dp[i] = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> *std::<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
    
    
    <summary type="html">动态规划</summary>
    
    
    
    <category term="algorithm" scheme="https://even629.com/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://even629.com/tags/algorithm/"/>
    
    <category term="动态规划" scheme="https://even629.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="leetcode面试经典150题" scheme="https://even629.com/tags/leetcode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试经典150题 P322 零钱兑换</title>
    <link href="https://even629.com/posts/322/"/>
    <id>https://even629.com/posts/322/</id>
    <published>2025-12-12T02:26:13.000Z</published>
    <updated>2025-12-12T02:26:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-12</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P322 零钱兑换" href="https://leetcode.cn/problems/coin-change/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P322 零钱兑换</p><p class="url">https://leetcode.cn/problems/coin-change/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>原本是BFS写法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> amount)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="type">int</span> i, j, n = coins.<span class="built_in">size</span>();</span><br><span class="line">                <span class="type">int</span> curr;</span><br><span class="line">                <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">                dp[amount] = <span class="number">0</span>;</span><br><span class="line">                queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">                que.<span class="built_in">push</span>(amount);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        curr = que.<span class="built_in">front</span>();</span><br><span class="line">                        que.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (curr - coins[i] &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                    dp[curr - coins[i]] == <span class="number">-1</span>) &#123;</span><br><span class="line">                                        dp[curr - coins[i]] = dp[curr] + <span class="number">1</span>;</span><br><span class="line">                                        que.<span class="built_in">push</span>(curr - coins[i]);</span><br><span class="line">                                        <span class="keyword">if</span> (curr - coins[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                                                <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>经典背包问题dp，以amount=3,为例<br>[<br>F(3) = \min\big(F(3 - c_1),\; F(3 - c_2),\; F(3 - c_3)\big) + 1<br>]</p><p>[<br>= \min\big(F(3 - 1),\; F(3 - 2),\; F(3 - 3)\big) + 1<br>]</p><p>[<br>= \min\big(F(2),\; F(1),\; F(0)\big) + 1<br>]</p><p>[<br>= \min(1,\; 1,\; 0) + 1<br>]</p><p>[<br>= 1<br>]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> amount)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="type">int</span> i, j, n = coins.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">                <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">                dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (i - coins[j] &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                    dp[i - coins[j]] != INT_MAX) &#123;</span><br><span class="line">                                        dp[i] = std::<span class="built_in">min</span>(dp[i - coins[j]] + <span class="number">1</span>,</span><br><span class="line">                                                         dp[i]);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> dp[amount] == INT_MAX ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
    
    
    <summary type="html">动态规划</summary>
    
    
    
    <category term="algorithm" scheme="https://even629.com/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://even629.com/tags/algorithm/"/>
    
    <category term="动态规划" scheme="https://even629.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="leetcode面试经典150题" scheme="https://even629.com/tags/leetcode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试经典150题 P198 打家劫舍</title>
    <link href="https://even629.com/posts/198/"/>
    <id>https://even629.com/posts/198/</id>
    <published>2025-12-12T01:14:13.000Z</published>
    <updated>2025-12-12T01:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-12</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P198 打家劫舍" href="https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P198 打家劫舍</p><p class="url">https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>动态规划，记dp[i][0]表示不选择nums[i]的最大值，dp[i][1]表示选择nums[i]的最大值，那么有：</p><script type="math/tex; mode=display">dp[i][0] = max(dp[i-1][0], dp[i-1][1]);</script><script type="math/tex; mode=display">dp[i][1] = dp[i-1][0] + nums[i];</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="type">int</span> i, n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">                <span class="comment">// 不选择nums[i]，选择nums[i]</span></span><br><span class="line">                dp[<span class="number">0</span>] = &#123; <span class="number">0</span>, nums[<span class="number">0</span>] &#125;;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                        dp[i][<span class="number">0</span>] = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>],</span><br><span class="line">                                            dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">                        dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Solution S;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        S.<span class="built_in">rob</span>(nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
    
    
    <summary type="html">动态规划</summary>
    
    
    
    <category term="algorithm" scheme="https://even629.com/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://even629.com/tags/algorithm/"/>
    
    <category term="动态规划" scheme="https://even629.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="leetcode面试经典150题" scheme="https://even629.com/tags/leetcode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试经典150题 P373 查找和最小的K对数字</title>
    <link href="https://even629.com/posts/373/"/>
    <id>https://even629.com/posts/373/</id>
    <published>2025-12-08T09:30:13.000Z</published>
    <updated>2025-12-08T09:30:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-08</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P373 查找和最小的K对数字" href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P373 查找和最小的K对数字</p><p class="url">https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>这题不能用双指针，因为不是线性的，用堆解决的核心是先把 {nums1[0],nums2[j]} 都放入堆中(0 &lt;= j &lt;= nums2.size()),然后从堆中去除最小和的那一对{i,j}, j 不变的情况下比它大的值中{i+1, j}最小。</p><p>那为什么可以让j不变呢？因为 j 的推进（即 j+1）已经在初始化阶段全部加入堆({num1[0], nums2[j]})</p><p>示例 1 的 <code>nums1 = [1, 7, 11]</code>，<code>nums2 = [2, 4, 6]</code>。我们把每个数对的和算出来，可以得到一个矩阵 $ M $，其中 $ M_{i,j} = nums1[i] + nums2[j] $。 </p><script type="math/tex; mode=display">M =  \begin{bmatrix} 3 & 5 & 7 \\ 9 & 11 & 13 \\ 13 & 15 & 17 \end{bmatrix}</script><p>由于 <code>nums2</code> 是递增的，所以矩阵每一行都是递增的。问题相当于： 合并 $ n $ 个升序列表，找前 $ k $ 小元素。（其中 $ n $ 是 <code>nums1</code> 的长度） 根据 P23 合并 K 个升序链表 的堆的做法：</p><ol><li>把矩阵每一行的第一个数 $ M_{i,0} $ 及其位置 $ (i, 0) $ 加到最小堆中。 </li><li>循环 $ k $ 次。 </li><li>每次循环，弹出堆顶，把堆顶 $ M<em>{i,j} $ 的对应数对加入答案，把堆顶右边元素 $ M</em>{i,j+1} $ 及其位置 $ (i, j+1) $ 入堆。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br><span class="line"><span class="keyword">using</span> std::priority_queue;</span><br><span class="line"><span class="keyword">using</span> std::array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums1,</span><br><span class="line">                                            vector&lt;<span class="type">int</span>&gt; &amp;nums2, <span class="type">int</span> k)</span><br><span class="line">        &#123;</span><br><span class="line">                vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">                <span class="keyword">if</span> (nums<span class="number">1.</span><span class="built_in">empty</span>() || nums<span class="number">2.</span><span class="built_in">empty</span>() || k == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> cmp = [&amp;](<span class="type">const</span> array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; &amp;a, <span class="type">const</span> array&lt;<span class="type">int</span>, <span class="number">2</span>&gt; &amp;b) &#123;</span><br><span class="line">                        <span class="keyword">return</span> nums1[a[<span class="number">0</span>]] + nums2[a[<span class="number">1</span>]] &gt;</span><br><span class="line">                               nums1[b[<span class="number">0</span>]] + nums2[b[<span class="number">1</span>]];</span><br><span class="line">                &#125;;</span><br><span class="line">                priority_queue&lt;array&lt;<span class="type">int</span>, 2&gt;, vector&lt;array&lt;<span class="type">int</span>, 2&gt; &gt;,</span><br><span class="line">                               <span class="keyword">decltype</span>(cmp)&gt;</span><br><span class="line">                        <span class="built_in">pq</span>(cmp);</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums<span class="number">1.</span><span class="built_in">size</span>() &amp;&amp; i &lt; k; i++) &#123;</span><br><span class="line">                        pq.<span class="built_in">push</span>(&#123; i, <span class="number">0</span> &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (k-- &amp;&amp; !pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> [i, j] = pq.<span class="built_in">top</span>();</span><br><span class="line">                        pq.<span class="built_in">pop</span>();</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123; nums1[i], nums2[j] &#125;);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; nums<span class="number">2.</span><span class="built_in">size</span>()) &#123;</span><br><span class="line">                                pq.<span class="built_in">push</span>(&#123; i, j<span class="number">+1</span> &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
    
    
    <summary type="html">堆</summary>
    
    
    
    <category term="algorithm" scheme="https://even629.com/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://even629.com/tags/algorithm/"/>
    
    <category term="堆" scheme="https://even629.com/tags/%E5%A0%86/"/>
    
    <category term="leetcode面试经典150题" scheme="https://even629.com/tags/leetcode%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8150%E9%A2%98/"/>
    
  </entry>
  
</feed>
